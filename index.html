<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>La Diaria ‚Äî v3.2 Responsive</title>
  <link rel="stylesheet" href="./style.css" />


</head>

<body class="layout">
  <div id="origin-warning" class="origin-warning hidden" role="alert">
    <div class="origin-warning__message">
      <strong>Atenci√≥n:</strong>
      Est√°s viendo el sistema en <span data-current-origin></span>. Los datos existentes viven en
      <span data-canonical-origin>http://localhost:3000</span>. Abre esa direcci√≥n para recuperar tu base.
    </div>
    <button type="button" class="origin-warning__close" data-close-warning aria-label="Cerrar aviso">&times;</button>
  </div>
  <aside class="sidebar expanded" id="sidebar">
    <div class="brand">LD v3.2</div>
    <button data-view="day"><span>üè†</span><i>Panel del d√≠a</i></button>
    <button data-view="hypo"><span>üß©</span><i>Hip√≥tesis</i></button>
    <button data-view="analysis"><span>üìä</span><i>Escenarios</i></button>
    <button data-view="geometry"><span>‚ú¥Ô∏è</span><i>Cruceta/Tri√°ngulo</i></button>
    <button data-view="memory"><span>üß†</span><i>Memoria</i></button>
    <button data-view="guide"><span>üìò</span><i>Gu√≠a de los Sue√±os</i></button>
    <button data-view="config"><span>‚öôÔ∏è</span><i>Configuraci√≥n</i></button>
    <button data-view="maint"><span>üõ†Ô∏è</span><i>Mantenimiento</i></button>
    <button data-view="modes"><span>üéÆ</span><i>Modos de juego</i></button>
  </aside>

  <main class="content">
    <header class="top">
      <h1>Sistema</h1>
      <button id="btn-toggle-sidebar" class="menu-btn">‚ò∞</button>
      <div class="badge">v3.2 ‚Ä¢ Oscuro + Dorado</div>
    </header>

    <div id="countdown-banner" class="countdown-banner">
      <div class="countdown-label" data-countdown-label>Tiempo para el pr√≥ximo sorteo</div>
      <div class="countdown-target" data-countdown-target>‚Äî</div>
      <div class="countdown-timer" data-countdown-timer>--:--:--</div>
    </div>

    <!-- PANEL DEL D√çA -->
    <section id="view-day" class="view">
      <h2>Panel del d√≠a</h2>
      <div class="row">
        <label>Fecha <input type="date" id="day-fecha" /></label>
        <label>Pa√≠s
          <select id="day-pais">
            <option>HN</option>
            <option>NI</option>
            <option>SV</option>
          </select>
        </label>
      </div>

      <div class="triple">
        <div class="slot">
          <div class="slot-header">
            <div class="slot-title">11 AM</div>
            <label class="slot-flag">
              <input type="checkbox" id="test-11" /> Modo prueba
            </label>
          </div>
          <div class="ball-row">
            <div class="ball" id="b-11">--</div>
            <div class="sym" id="s-11"></div>
          </div>
          <div class="row slot-controls">
            <input id="n-11" placeholder="00-99" />
          </div>
          <button class="ghost" data-hypo="11AM">Agregar hip√≥tesis para 11 AM</button>
        </div>

        <div class="slot">
          <div class="slot-header">
            <div class="slot-title">3 PM</div>
            <label class="slot-flag">
              <input type="checkbox" id="test-3" /> Modo prueba
            </label>
          </div>
          <div class="ball-row">
            <div class="ball" id="b-3">--</div>
            <div class="sym" id="s-3"></div>
          </div>
          <div class="row slot-controls">
            <input id="n-3" placeholder="00-99" />
          </div>
          <button class="ghost" data-hypo="3PM">Agregar hip√≥tesis para 3 PM</button>
        </div>

        <div class="slot">
          <div class="slot-header">
            <div class="slot-title">9 PM</div>
            <label class="slot-flag">
              <input type="checkbox" id="test-9" /> Modo prueba
            </label>
          </div>
          <div class="ball-row">
            <div class="ball" id="b-9">--</div>
            <div class="sym" id="s-9"></div>
          </div>
          <div class="row slot-controls">
            <input id="n-9" placeholder="00-99" />
          </div>
          <button class="ghost" data-hypo="9PM">Agregar hip√≥tesis para 9 PM</button>
        </div>
      </div>

      <div class="row" style="justify-content:center; margin-top:12px;">
        <button id="save-day" style="min-width:220px;">Guardar sorteos del d√≠a</button>
      </div>

      <div class="row" style="margin-top:20px;">
        <button id="btn-aprender-dia">Registrar resultados del d√≠a (aprendizaje)</button>
        <span class="hint">
          Confirma/Refuta hip√≥tesis pendientes seg√∫n los resultados v√°lidos de la fecha seleccionada.
        </span>
      </div>
    </section>

    <!-- HIP√ìTESIS -->
    <section id="view-hypo" class="view hidden">
      <h2>Hip√≥tesis manuales</h2>
      <div class="row">
        <label>Fecha <input type="date" id="h-fecha" /></label>
        <label>Turno
          <select id="h-turno">
            <option>11AM</option>
            <option>3PM</option>
            <option>9PM</option>
          </select>
        </label>
        <label>N√∫mero <input id="h-numero" placeholder="00-99" /></label>
      </div>
      <div class="row">
        <label style="flex:1">
          Texto / Raz√≥n
          <textarea id="h-texto" rows="3" placeholder="Describe tu hip√≥tesis..."></textarea>
        </label>
      </div>
      <!-- üîπ NUEVO BLOQUE: sorteos del d√≠a seleccionado -->
      <div id="h-draws-day" class="card-body"
        style="margin:10px 0; border:1px solid #444; border-radius:10px; padding:10px;">
        <p class="hint">Selecciona una fecha para ver los sorteos de ese d√≠a.</p>
      </div>
      <!-- üîπ FIN NUEVO BLOQUE -->
      <button id="h-guardar">Guardar hip√≥tesis</button>
      <h3>Historial</h3>
      <div id="h-list" class="cards hypo-list"></div>
    </section>



    <!-- ESCENARIOS -->
    <section id="view-analysis" class="view hidden">
      <h2>Escenarios y recomendaci√≥n</h2>
      <button id="btn-analizar">Analizar</button>
      <p class="hint">
        La <b>confianza (conf)</b> es una ponderaci√≥n heur√≠stica (0‚Äì100%).
      </p>
      <div class="cards" id="result-plan"></div>
      <div class="cards" id="result-escenarios"></div>
      <div class="cards" id="result-recomendacion"></div>

      <div id="transform-panel" class="card">
        <div class="card-head">üîÑ Transformaciones Visuales</div>
        <div class="row">
          <input id="t-numero" placeholder="Ej. 25" />
          <button id="t-ver">Ver transformaciones</button>
        </div>
        <div id="t-output"></div>
      </div>
    </section>

    <!-- GEOMETR√çA -->
    <section id="view-geometry" class="view hidden">
      <h2>Cruceta / Tri√°ngulo (visual)</h2>
      <div class="row">
        <label>Fecha <input type="date" id="g-fecha" /></label>
        <button id="g-generar">Generar</button>
      </div>
      <div class="geom-wrap">
        <div class="geom-card">
          <h3>Cruceta</h3>
          <div id="g-cruceta" class="cruceta"></div>
        </div>
        <div class="geom-card">
          <h3>Tri√°ngulo invertido</h3>
          <div id="g-tri" class="tri"></div>
        </div>
      </div>
    </section>

    <!-- MEMORIA -->
    <section id="view-memory" class="view hidden">
      <h2>Memoria simb√≥lica</h2>
      <button id="toggle-tech">Mostrar/Ocultar modo t√©cnico</button>
      <pre id="mem-out" class="hidden"></pre>
    </section>

    <!-- GU√çA -->
    <section id="view-guide" class="view hidden">
      <h2>Gu√≠a de los Sue√±os</h2>
      <p class="hint">
        Explora todos los n√∫meros (00‚Äì99), sus s√≠mbolos, familias y polaridades. <br />
        Los espacios vac√≠os est√°n reservados para las im√°genes futuras de cada s√≠mbolo.
      </p>
      <div id="guide-grid" class="guide-grid"></div>
    </section>

    <!-- CONFIGURACI√ìN -->
    <section id="view-config" class="view hidden">
      <h2>Configuraci√≥n</h2>
      <p>‚Ä¢ Sidebar expandido con nombres.</p>
      <p>‚Ä¢ Tema oscuro con acentos dorados y esferas animadas.</p>
    </section>

    <!-- MANTENIMIENTO -->
    <section id="view-maint" class="view hidden">
      <h2>Mantenimiento</h2>
      <div class="card">
        <div class="card-head">Duplicados</div>
        <div class="row">
          <button id="btn-list-dup">Revisar duplicados</button>
          <button id="btn-marktest-dup">Marcar seleccionados como modo prueba</button>
          <button id="btn-delete-dup">Eliminar seleccionados</button>
        </div>
        <div id="dup-out" class="card-body"></div>
      </div>
      <div class="card" style="margin-top:15px;">
        <div class="card-head">Todos los sorteos registrados</div>
        <div class="row">
          <button id="btn-list-all">Ver todos</button>
        </div>
        <div id="all-out" class="card-body"></div>
      </div>
      <div class="card" style="margin-top:15px;">
        <div class="card-head">Reiniciar base de datos</div>
        <div class="row">
          <button id="btn-nuke" style="background:#e04c41;border-color:#e04c41;color:#fff;">
            ‚ö†Ô∏è Borrar todo (reiniciar)
          </button>
        </div>
        <p class="hint">Usa con precauci√≥n: eliminar√° todos los sorteos, hip√≥tesis y reglas.</p>
      </div>


    </section>

    <section id="view-modes" class="view hidden">
      <h2>Modos de juego</h2>
      <div class="mode-form card">
        <div class="card-head">Crear/Editar modo</div>
        <div class="card-body mode-form-body">
          <div class="row mode-form-row">
            <label class="grow">
              <span class="label-title">Nombre</span>
              <input id="mode-name" placeholder="Ej. Columna 5" />
            </label>
            <label class="grow">
              <span class="label-title">Tipo</span>
              <select id="mode-type">
                <option value="manual">Manual</option>
                <option value="conversion_simple">Conversi√≥n simple</option>
                <option value="conversion_compuesta">Conversi√≥n compuesta</option>
                <option value="inversion_numero">Inversi√≥n de n√∫mero</option>
                <option value="suma_digitos">Suma de d√≠gitos</option>
                <option value="linea_1">Jugando con l√≠nea 1</option>
                <option value="linea_2">Jugando con l√≠nea 2</option>
                <option value="ajuste">Jugando con ajuste</option>
                <option value="por_salto">Por salto</option>
                <option value="por_repeticion">Por repetici√≥n</option>
                <option value="por_distraccion">Por distracci√≥n</option>
                <option value="cambia_eje">Por cambia de eje</option>
                <option value="por_narrativa">Por narrativa</option>
                <option value="por_familia">Por familia</option>
                <option value="patron">Patr√≥n (otros)</option>
              </select>
            </label>
          </div>
          <div class="row mode-form-row">
            <label class="grow">
              <span class="label-title">Operaci√≥n</span>
              <select id="mode-operation">
                <option value="">‚Äî Solo descriptivo ‚Äî</option>
                <option value="mirror">Invertir d√≠gitos</option>
                <option value="sum-digits">Suma de d√≠gitos (resultado completo)</option>
              <option value="sum-digits-keep-first">Suma de d√≠gitos (mantener primer d√≠gito)</option>
              <option value="add-constant">Sumar constante</option>
              <option value="sub-constant">Restar constante</option>
              <option value="neighbor">N√∫mero vecino (¬±1)</option>
              <option value="digit-map">Mapa de d√≠gitos (pares equivalentes)</option>
            </select>
          </label>
            <label class="grow">
              <span class="label-title">Par√°metro</span>
              <input id="mode-parameter" placeholder="Ej. 1" />
            </label>
            <label class="grow">
              <span class="label-title">Avance (turnos)</span>
              <select id="mode-offset">
                <option value="1">Siguiente turno</option>
                <option value="2">Dos turnos despu√©s</option>
                <option value="0">Mismo turno</option>
              </select>
            </label>
          </div>
          <label class="grow mode-desc">
            <span class="label-title">Descripci√≥n</span>
            <textarea id="mode-desc" rows="3" placeholder="Define el modo en tus palabras"></textarea>
          </label>
          <button id="mode-save">Guardar modo</button>
        </div>
      </div>

      <div class="mode-list card">
        <div class="card-head">Modos registrados</div>
        <div id="mode-list" class="card-body mode-list-body"></div>
      </div>
    </section>
  </main>

  <div id="toast-container" class="toast-container"></div>

  <script type="module">
    import { mostrarGuia } from "./src/guide-grid.js";
    import { DB } from "./src/storage.js";
    import { importarManual } from "./src/importer.js";
    import { crearHipotesis, actualizarHipotesis, registrarResultado } from "./src/narrative.js";
    import { analizarYProponer } from "./src/reasoning.js";
    import { generarCruceta, generarTrianguloInvertido, dibujarTrianguloInvertido } from "./src/geometry.js";
    import { cargarGuia, GUIA, getColorPolaridad } from "./src/loader.js";
    import { detectarPatrones } from "./src/pattern-detector.js";
    import { revisarDuplicados, marcarGrupoComoTest, borrarIds } from "./src/maintenance.js";
    import { mostrarTransformaciones } from "./src/transform-visual.js";
    import {
      rebuildKnowledge,
      obtenerPerfilesNumeros,
      generarPredicciones,
      describirPerfil,
      generarInsights,
      obtenerResumenPredicciones,
    } from "./src/learning.js";
    import {
      createMode,
      updateMode,
      deleteMode,
      listModesWithExamples,
      deleteModeExample,
      logModeUsage,
      listModeUsage,
    } from "./src/modes.js";
    import { evaluarModos } from "./src/mode-engine.js";

    await cargarGuia();

    const toastContainer = document.getElementById("toast-container");

    function showToast(message, { variant = "info", timeout = 4200 } = {}) {
      if (!toastContainer) {
        console.warn("Toast:", message);
        return;
      }
      const toast = document.createElement("div");
      toast.className = "toast";
      toast.dataset.variant = variant;
      const text = document.createElement("span");
      text.textContent = message;

      let hideTimer = null;
      const dismiss = () => {
        if (!toast || toast.classList.contains("hide")) return;
        toast.classList.add("hide");
        setTimeout(() => toast.remove(), 220);
      };

      const close = document.createElement("button");
      close.type = "button";
      close.innerHTML = "&times;";
      close.addEventListener("click", () => dismiss());

      toast.appendChild(text);
      toast.appendChild(close);
      toastContainer.appendChild(toast);

      hideTimer = setTimeout(dismiss, timeout);
      toast.addEventListener("mouseenter", () => clearTimeout(hideTimer));
      toast.addEventListener("mouseleave", () => {
        hideTimer = setTimeout(dismiss, 1800);
      });
    }

    const modeNameInput = document.getElementById("mode-name");
    const modeTypeSelect = document.getElementById("mode-type");
    const modeDescInput = document.getElementById("mode-desc");
    const modeOperationSelect = document.getElementById("mode-operation");
    const modeParamInput = document.getElementById("mode-parameter");
    const modeOffsetSelect = document.getElementById("mode-offset");
    const modeSaveBtn = document.getElementById("mode-save");
    let editingModeId = null;

    function resetModeForm() {
      editingModeId = null;
      if (modeNameInput) modeNameInput.value = "";
      if (modeTypeSelect) modeTypeSelect.value = "manual";
      if (modeDescInput) modeDescInput.value = "";
      if (modeOperationSelect) modeOperationSelect.value = "";
      if (modeParamInput) modeParamInput.value = "";
      if (modeOffsetSelect) modeOffsetSelect.value = "1";
      if (modeSaveBtn) modeSaveBtn.textContent = "Guardar modo";
    }

    function describeModoOperacion(mode = {}) {
      const op = mode.operacion || "";
      if (!op) return "";
      const params = mode.parametros ?? mode.parametro ?? {};
      const valor = typeof params === "object" && params !== null ? (params.valor ?? params.constante ?? params.raw) : params;
      const offset = Number.isFinite(mode.offset) ? mode.offset : null;

      const nombreOperacion = {
        mirror: "Invertir d√≠gitos",
        "sum-digits": "Suma de d√≠gitos",
        "sum-digits-keep-first": "Suma de d√≠gitos (mantener primer d√≠gito)",
        "add-constant": "Sumar constante",
        "sub-constant": "Restar constante",
        neighbor: "N√∫mero vecino",
      }[op] || op;

      let detalle = nombreOperacion;
      if (valor !== undefined && valor !== null && valor !== "") {
        detalle += ` ¬∑ param ${valor}`;
      }
      if (offset !== null) {
        const offsetTxt = offset === 0 ? "mismo turno" : offset === 1 ? "siguiente turno" : `${offset} turnos`;
        detalle += ` ¬∑ ${offsetTxt}`;
      }
      return detalle;
    }

    function buildModeParameters(operacion, rawValue) {
      if (!operacion) return null;
      if (operacion === "digit-map") {
        const valor = rawValue?.trim() || "0:1,2:5,3:8,4:7,6:9";
        return { mapa: valor };
      }
      if (!rawValue) return {};
      const numeric = Number(rawValue);
      if (!Number.isNaN(numeric) && rawValue.trim() !== "") {
        return { valor: numeric };
      }
      return { valor: rawValue };
    }

    async function refreshModesPanel() {
      const container = document.getElementById("mode-list");
      if (!container) return;
      const modes = await listModesWithExamples();
      container.innerHTML = "";
      if (!modes.length) {
        container.innerHTML = "<p class='hint'>A√∫n no hay modos registrados.</p>";
        if (!editingModeId) resetModeForm();
        return;
      }

      const dayFechaInput = document.getElementById("day-fecha");
      const dayPaisSelect = document.getElementById("day-pais");
      const paisOptions = Array.from(dayPaisSelect?.options || []).map((opt) => opt.value || opt.textContent || "");

      for (const mode of modes) {
        const item = document.createElement("div");
        item.className = "mode-item";

        const head = document.createElement("div");
        head.className = "mode-item-head";
        const titleWrap = document.createElement("div");
        const title = document.createElement("strong");
        title.textContent = mode.nombre;
        const chip = document.createElement("span");
        chip.className = "analysis-chip";
        chip.textContent = mode.tipo || "manual";
        titleWrap.appendChild(title);
        titleWrap.appendChild(chip);
        head.appendChild(titleWrap);

        const actions = document.createElement("div");
        actions.className = "mode-item-actions";

        const editBtn = document.createElement("button");
        editBtn.type = "button";
        editBtn.className = "btn-secondary";
        editBtn.textContent = "Editar";
        editBtn.addEventListener("click", () => {
          editingModeId = mode.id;
        if (modeNameInput) modeNameInput.value = mode.nombre || "";
        if (modeTypeSelect) modeTypeSelect.value = mode.tipo || "manual";
        if (modeDescInput) modeDescInput.value = mode.descripcion || "";
        if (modeOperationSelect) modeOperationSelect.value = mode.operacion || "";
        if (modeParamInput) {
          const params = mode.parametros ?? mode.parametro ?? {};
          let valor = "";
          if (mode.operacion === "digit-map") {
            if (typeof params === "object" && params !== null) valor = params.mapa ?? "";
            else valor = params ?? "";
          } else {
            valor = typeof params === "object" && params !== null ? (params.valor ?? params.constante ?? params.raw) : params;
          }
          modeParamInput.value = valor ?? "";
        }
        if (modeOffsetSelect) {
          const offsetVal = Number.isFinite(mode.offset) ? String(mode.offset) : "1";
          modeOffsetSelect.value = offsetVal;
          }
          if (modeSaveBtn) modeSaveBtn.textContent = "Actualizar modo";
          showToast(`Editando modo ${mode.nombre}`, { variant: "info", timeout: 2500 });
        });

        const deleteBtn = document.createElement("button");
        deleteBtn.type = "button";
        deleteBtn.className = "btn-danger";
        deleteBtn.textContent = "Eliminar";
        deleteBtn.addEventListener("click", async () => {
          const confirmar = await mostrarModal(
            "Eliminar modo",
            `¬øEliminar el modo "${mode.nombre}" y sus ejemplos?`,
            { okText: "Eliminar", cancelText: "Cancelar", okVariant: "danger" }
          );
          if (!confirmar) return;
          try {
            await deleteMode(mode.id);
            if (editingModeId === mode.id) resetModeForm();
            await refreshModesPanel();
            showToast("Modo eliminado.", { variant: "success" });
          } catch (err) {
            showToast(`No se pudo eliminar: ${err.message}`, { variant: "danger" });
          }
        });

        actions.appendChild(editBtn);
        actions.appendChild(deleteBtn);
        head.appendChild(actions);
        item.appendChild(head);

        const metaOperacion = describeModoOperacion(mode);
        if (metaOperacion) {
          const opMeta = document.createElement("div");
          opMeta.className = "mode-meta";
          opMeta.textContent = metaOperacion;
          item.appendChild(opMeta);
        }

        const desc = document.createElement("div");
        desc.className = "analysis-note";
        desc.textContent = mode.descripcion || "Sin descripci√≥n.";
        item.appendChild(desc);

        const exampleList = document.createElement("div");
        exampleList.className = "mode-example-list";
        if (mode.ejemplos?.length) {
          mode.ejemplos.forEach((ex) => {
            const row = document.createElement("div");
            row.className = "mode-example";
            const text = document.createElement("span");
            const nota = ex.nota ? ` ¬∑ ${ex.nota}` : "";
            text.textContent = `${ex.original} ‚Üí ${ex.resultado}${nota}`;
            text.style.flex = "1";
            const del = document.createElement("button");
            del.type = "button";
            del.className = "btn-ghost";
            del.textContent = "Eliminar";
            del.addEventListener("click", async () => {
              const ok = await mostrarModal(
                "Eliminar ejemplo",
                `¬øEliminar el ejemplo ${ex.original} ‚Üí ${ex.resultado}?`,
                { okText: "Eliminar", cancelText: "Cancelar", okVariant: "danger" }
              );
              if (!ok) return;
              await deleteModeExample(ex.id);
              showToast("Ejemplo eliminado.", { variant: "success" });
              await refreshModesPanel();
            });
            row.appendChild(text);
            row.appendChild(del);
            exampleList.appendChild(row);
          });
        } else {
          const empty = document.createElement("span");
          empty.className = "analysis-note";
          empty.textContent = "Sin ejemplos registrados.";
          exampleList.appendChild(empty);
        }
        item.appendChild(exampleList);

        const exampleForm = document.createElement("div");
        exampleForm.className = "mode-example";
        const exOriginal = document.createElement("input");
        exOriginal.placeholder = "Original";
        exOriginal.maxLength = 4;
        const exResultado = document.createElement("input");
        exResultado.placeholder = "Resultado";
        exResultado.maxLength = 4;
        const exNota = document.createElement("input");
        exNota.placeholder = "Nota";
        exNota.style.flex = "1";
        const exBtn = document.createElement("button");
        exBtn.type = "button";
        exBtn.className = "btn-secondary";
        exBtn.textContent = "Agregar";
        exBtn.addEventListener("click", async () => {
          const original = exOriginal.value.trim();
          const resultado = exResultado.value.trim();
          if (!original || !resultado) {
            showToast("Completa original y resultado.", { variant: "warning" });
            return;
          }
          try {
            await DB.addGameModeExample({
              modeId: mode.id,
              original,
              resultado,
              nota: exNota.value.trim() || "",
            });
            showToast("Ejemplo agregado.", { variant: "success" });
            await refreshModesPanel();
          } catch (err) {
            showToast(`No se pudo agregar el ejemplo: ${err.message}`,
              { variant: "danger" }
            );
          }
        });
        exampleForm.appendChild(exOriginal);
        exampleForm.appendChild(exResultado);
        exampleForm.appendChild(exNota);
        exampleForm.appendChild(exBtn);
        item.appendChild(exampleForm);

        const logForm = document.createElement("div");
        logForm.className = "mode-log-form";
        const logDate = document.createElement("input");
        logDate.type = "date";
        logDate.value = dayFechaInput?.value || "";
        const logPais = document.createElement("select");
        const defaultPaisOpt = document.createElement("option");
        defaultPaisOpt.value = "";
        defaultPaisOpt.textContent = "Pa√≠s";
        logPais.appendChild(defaultPaisOpt);
        const options = paisOptions.length ? paisOptions : ["HN", "NI", "SV"];
        options.forEach((p) => {
          const opt = document.createElement("option");
          opt.value = p;
          opt.textContent = p;
          if (dayPaisSelect?.value === p) opt.selected = true;
          logPais.appendChild(opt);
        });
        const logTurno = document.createElement("select");
        ["", "11AM", "3PM", "9PM"].forEach((turno) => {
          const opt = document.createElement("option");
          opt.value = turno;
          opt.textContent = turno || "Turno";
          logTurno.appendChild(opt);
        });
        const logNotas = document.createElement("input");
        logNotas.type = "text";
        logNotas.placeholder = "Notas";
        const logBtn = document.createElement("button");
        logBtn.type = "button";
        logBtn.className = "btn-secondary";
        logBtn.textContent = "Registrar uso";
        logBtn.addEventListener("click", async () => {
          if (!logDate.value) {
            showToast("Ingresa una fecha para registrar el modo.", { variant: "warning" });
            return;
          }
          try {
            await logModeUsage({
              modeId: mode.id,
              fecha: logDate.value,
              pais: logPais.value || null,
              turno: logTurno.value || null,
              notas: logNotas.value.trim() || null,
            });
            logNotas.value = "";
            showToast("Uso registrado.", { variant: "success" });
            await refreshModesPanel();
          } catch (err) {
            showToast(`No se pudo registrar el uso: ${err.message}`,
              { variant: "danger" }
            );
          }
        });
        logForm.appendChild(logDate);
        logForm.appendChild(logPais);
        logForm.appendChild(logTurno);
        logForm.appendChild(logNotas);
        logForm.appendChild(logBtn);
        item.appendChild(logForm);

        const logs = await listModeUsage({ modeId: mode.id });
        const recentLogs = logs
          .slice()
          .sort((a, b) => (b.createdAt || 0) - (a.createdAt || 0))
          .slice(0, 5);
        const logList = document.createElement("div");
        logList.className = "mode-log-list";
        if (!recentLogs.length) {
          const empty = document.createElement("span");
          empty.className = "analysis-note";
          empty.textContent = "Sin usos registrados.";
          logList.appendChild(empty);
        } else {
          recentLogs.forEach((log) => {
            const row = document.createElement("div");
            row.className = "mode-log-item";
            const fechaTxt = log.fecha || "(sin fecha)";
            const paisTxt = log.pais || "-";
            const turnoTxt = log.turno || "-";
            row.innerHTML = `<strong>${fechaTxt}</strong><span>${paisTxt}</span><span>${turnoTxt}</span>${log.notas ? `<span>${log.notas}</span>` : ""}`;
            logList.appendChild(row);
          });
        }
        item.appendChild(logList);

        container.appendChild(item);
      }

      if (modeSaveBtn) {
        modeSaveBtn.textContent = editingModeId ? "Actualizar modo" : "Guardar modo";
      }
    }

    resetModeForm();

    modeSaveBtn?.addEventListener("click", async () => {
      const nombre = modeNameInput?.value.trim();
      if (!nombre) {
        showToast("Ingresa un nombre para el modo.", { variant: "warning" });
        return;
      }
      const operacion = modeOperationSelect?.value || "";
      const parametroRaw = modeParamInput?.value.trim() || "";
      const offsetVal = modeOffsetSelect?.value ?? "";
      const offsetNumber = offsetVal === "" ? null : Number(offsetVal);
      const parametros = buildModeParameters(operacion, parametroRaw);

      const payload = {
        nombre,
        tipo: modeTypeSelect?.value || "manual",
        descripcion: modeDescInput?.value.trim() || "",
        operacion,
        parametros: operacion ? parametros ?? {} : null,
        offset: Number.isFinite(offsetNumber) ? offsetNumber : null,
      };
      try {
        if (editingModeId) {
          await updateMode(editingModeId, payload);
          showToast("Modo actualizado.", { variant: "success" });
        } else {
          await createMode(payload);
          showToast("Modo creado.", { variant: "success" });
        }
        resetModeForm();
        await refreshModesPanel();
      } catch (err) {
        showToast(`No se pudo guardar el modo: ${err.message}`, { variant: "danger" });
      }
    });

    const CANONICAL_ORIGIN = "http://localhost:3000";
    const FALLBACK_ORIGIN = "http://127.0.0.1:3000";
    const originBanner = document.getElementById("origin-warning");
    if (originBanner) {
      const origin = window.location.origin;
      const shouldWarn = origin !== CANONICAL_ORIGIN && origin !== FALLBACK_ORIGIN;
      if (shouldWarn) {
        originBanner.classList.remove("hidden");
        const currentEl = originBanner.querySelector("[data-current-origin]");
        const canonicalEl = originBanner.querySelector("[data-canonical-origin]");
        if (currentEl) {
          const { protocol, hostname, port } = window.location;
          const fallback = `${protocol}//${hostname}${port ? `:${port}` : ""}`;
          currentEl.textContent = origin || fallback;
        }
        if (canonicalEl) canonicalEl.textContent = CANONICAL_ORIGIN;
        originBanner
          .querySelector("[data-close-warning]")
          ?.addEventListener("click", () => originBanner.classList.add("hidden"));
      }
    }

    const todayISO = new Date().toISOString().slice(0, 10);
    ["day-fecha", "h-fecha", "g-fecha"].forEach((id) => {
      const el = document.getElementById(id);
      if (el && !el.value) el.value = todayISO;
    });

    const SLOT_CONFIG = [
      {
        key: "11AM",
        inputId: "n-11",
        checkboxId: "test-11",
        ballId: "b-11",
        symId: "s-11",
      },
      {
        key: "3PM",
        inputId: "n-3",
        checkboxId: "test-3",
        ballId: "b-3",
        symId: "s-3",
      },
      {
        key: "9PM",
        inputId: "n-9",
        checkboxId: "test-9",
        ballId: "b-9",
        symId: "s-9",
      },
    ];

    const DAY_MS = 24 * 60 * 60 * 1000;
    const formatNumber = (n) => String(n).padStart(2, "0");
    const parseISODate = (value) => {
      if (!value) return null;
      const date = new Date(`${value}T00:00:00`);
      return Number.isNaN(date.getTime()) ? null : date;
    };
    const formatISODate = (date) => {
      if (!(date instanceof Date) || Number.isNaN(date.getTime())) return null;
      return date.toISOString().slice(0, 10);
    };

    const getSymbol = (numero) => {
      const entry = GUIA[formatNumber(numero)];
      return entry?.simbolo || "";
    };

    const OPERACION_LABELS = {
      "": "",
      mirror: "Invertir",
      "sum-digits": "Suma d√≠gitos",
      "sum-digits-keep-first": "Suma d√≠gitos (mantiene)",
      "add-constant": "+Constante",
      "sub-constant": "-Constante",
      neighbor: "Vecino",
      "digit-map": "Mapa d√≠gitos",
    };

    const DOW_FULL_LABEL = [
      "Domingo",
      "Lunes",
      "Martes",
      "Mi√©rcoles",
      "Jueves",
      "Viernes",
      "S√°bado",
    ];

    function formatSampleDisplay(sample = {}) {
      const { fecha, horario } = sample;
      if (!fecha) return "";
      const dateObj = new Date(`${fecha}T00:00:00`);
      const dow = Number.isNaN(dateObj.getTime())
        ? ""
        : DOW_FULL_LABEL[dateObj.getDay()] || "";
      return `${dow} ${fecha} ${horario || ""}`.trim();
    }

    const getFilters = () => ({
      fecha: document.getElementById("day-fecha")?.value,
      pais: document.getElementById("day-pais")?.value,
    });

    function pickDraw(draws, fecha, pais, horario) {
      if (!fecha || !pais) return null;
      const matching = draws
        .filter((d) => d.fecha === fecha && d.pais === pais && d.horario === horario)
        .sort((a, b) => (a.createdAt || 0) - (b.createdAt || 0));
      if (!matching.length) return null;
      return matching
        .slice()
        .reverse()
        .find((d) => !d.isTest) ?? matching[matching.length - 1];
    }

    function formatBallContent(numero, symbol) {
      const numHtml = `<span class="ball-number">${numero}</span>`;
      const symHtml = symbol ? `<span class="ball-symbol">${symbol}</span>` : "";
      return `${numHtml}${symHtml}`;
    }

    function applyDrawToSlot(config, draw) {
      const ball = document.getElementById(config.ballId);
      const sym = document.getElementById(config.symId);
      if (!ball || !sym) return;
      if (!draw) {
        ball.innerHTML = formatBallContent("--", "");
        ball.classList.remove("small");
        ball.removeAttribute("data-numero");
        ball.style.borderColor = "";
        ball.style.color = "";
        sym.textContent = "";
        sym.removeAttribute("title");
        return;
      }
      const numero = formatNumber(draw.numero);
      const color = getColorPolaridad(draw.numero);
      const symbol = getSymbol(draw.numero);
      ball.innerHTML = formatBallContent(numero, symbol);
      ball.dataset.numero = numero;
      ball.classList.toggle("small", !!draw.isTest);
      ball.style.borderColor = color;
      ball.style.color = color;
      sym.textContent = "";
      sym.title = draw.isTest ? "Modo prueba" : symbol || "";
    }

    async function refreshSlots() {
      const { fecha, pais } = getFilters();
      const draws = await DB.listDraws({ excludeTest: false });
      SLOT_CONFIG.forEach((config) => {
        const draw = pickDraw(draws, fecha, pais, config.key);
        applyDrawToSlot(config, draw);
      });
    }

    const saveDayBtn = document.getElementById("save-day");
    saveDayBtn?.addEventListener("click", async () => {
      const { fecha, pais } = getFilters();
      if (!fecha || !pais) {
        showToast("Selecciona fecha y pa√≠s antes de guardar.", { variant: "warning" });
        return;
      }

      const payloads = [];
      for (const config of SLOT_CONFIG) {
        const input = document.getElementById(config.inputId);
        const raw = input?.value.trim() ?? "";
        if (!raw) continue;
        if (!/^\d{1,2}$/.test(raw)) {
          showToast(`N√∫mero inv√°lido en ${config.key}. Usa formato 00-99.`, { variant: "warning" });
          input?.focus();
          return;
        }
        const numero = parseInt(raw, 10);
        if (numero < 0 || numero > 99) {
          showToast(`El n√∫mero en ${config.key} debe estar entre 00 y 99.`, { variant: "warning" });
          input?.focus();
          return;
        }
        const symbol = getSymbol(numero);
        if (!symbol) {
          showToast(`El n√∫mero ${formatNumber(numero)} no tiene s√≠mbolo registrado. Revisa la gu√≠a antes de guardarlo.`, {
            variant: "danger",
          });
          input?.focus();
          return;
        }

        const testCheck = document.getElementById(config.checkboxId);
        payloads.push({ config, numero, input, testCheck, isTest: !!testCheck?.checked });
      }

      if (!payloads.length) {
        showToast("Ingresa al menos un n√∫mero antes de guardar.", { variant: "warning" });
        return;
      }

      try {
        for (const { config, numero, isTest } of payloads) {
          const opts = isTest ? { source: "test" } : {};
          await importarManual({ fecha, pais, horario: config.key, numero }, opts);
        }

        payloads.forEach(({ input, testCheck }) => {
          if (input) input.value = "";
          if (testCheck) testCheck.checked = false;
        });

        await refreshSlots();
        await rebuildKnowledge();

        const detail = payloads
          .map(({ config, numero }) => `${config.key} ${formatNumber(numero)}`)
          .join(" ¬∑ ");
        showToast(`Se guardaron ${payloads.length} sorteo(s): ${detail}.`, { variant: "success" });
      } catch (err) {
        console.error("saveDay error", err);
        showToast(`No se pudieron guardar los sorteos: ${err.message}`, { variant: "danger" });
      }
    });

    saveDayBtn?.addEventListener("click", () => {
      updateCountdownDisplay();
    });

    // === FUNCIONALIDAD: "Agregar hip√≥tesis para (hora)" ===
    document.querySelectorAll(".ghost[data-hypo]").forEach((btn) => {
      btn.addEventListener("click", async () => {
        const turno = btn.dataset.hypo;
        const { fecha, pais } = getFilters();
        if (!fecha || !pais) {
          mostrarAviso("Selecciona fecha y pa√≠s antes de agregar una hip√≥tesis.", { variant: "warning" });
          return;
        }

        // Crear peque√±o modal inline
        const modal = document.getElementById("sys-modal");
        const tEl = document.getElementById("modal-title");
        const mEl = document.getElementById("modal-msg");
        const okBtn = document.getElementById("modal-ok");
        const cancelBtn = document.getElementById("modal-cancel");

        tEl.textContent = `Hip√≥tesis para ${turno}`;
        mEl.innerHTML = `
      <label>Fecha: ${fecha}</label><br/>
      <label>Turno: ${turno}</label><br/>
      <label>N√∫mero: <input id="modal-num" type="number" min="0" max="99" style="width:60px"/></label><br/>
      <label>Raz√≥n: <textarea id="modal-text" rows="3" style="width:100%;margin-top:6px"></textarea></label>
    `;
        okBtn.textContent = "Guardar";
        cancelBtn.textContent = "Cancelar";
        modal.classList.remove("hidden");

        okBtn.onclick = async () => {
          const numeroRaw = document.getElementById("modal-num")?.value.trim() ?? "";
          const texto = document.getElementById("modal-text")?.value.trim() ?? "";
          if (!/^\d{1,2}$/.test(numeroRaw)) {
            mostrarAviso("Ingresa un n√∫mero v√°lido (00‚Äì99).", { variant: "warning" });
            return;
          }
          const numero = parseInt(numeroRaw, 10);
          const simbolo = getSymbol(numero);
          try {
            await crearHipotesis(numero, simbolo, texto, { fecha, turno });
            mostrarAviso(`Hip√≥tesis ${numero} ${simbolo} registrada para ${turno}.`, { variant: "success" });
          } catch (err) {
            console.error("hipo error", err);
            mostrarAviso(`Error al guardar la hip√≥tesis: ${err.message}`, { variant: "danger" });
          } finally {
            modal.classList.add("hidden");
          }
        };

        cancelBtn.onclick = () => {
          modal.classList.add("hidden");
        };
      });
    });


    const dayFecha = document.getElementById("day-fecha");
    const dayPais = document.getElementById("day-pais");
    dayFecha?.addEventListener("change", () => {
      refreshSlots();
      updateCountdownDisplay();
    });
    dayPais?.addEventListener("change", () => {
      refreshSlots();
      updateCountdownDisplay();
    });

    const countdownTargetEl = document.querySelector("[data-countdown-target]");
    const countdownTimerEl = document.querySelector("[data-countdown-timer]");
    let countdownInterval = null;
    const TURNOS = ["11AM", "3PM", "9PM"];
    const TURNO_SCHEDULE = {
      "11AM": { hour: 11, minute: 0 },
      "3PM": { hour: 15, minute: 0 },
      "9PM": { hour: 21, minute: 0 },
    };

    function computeNextSlot({ fecha } = {}) {
      const now = new Date();
      let baseDate;
      if (fecha) {
        baseDate = new Date(`${fecha}T00:00:00`);
        if (Number.isNaN(baseDate.getTime())) baseDate = new Date(now);
      } else {
        baseDate = new Date(now);
      }
      baseDate.setHours(0, 0, 0, 0);

      for (const turno of TURNOS) {
        const schedule = TURNO_SCHEDULE[turno];
        if (!schedule) continue;
        const candidate = new Date(baseDate);
        candidate.setHours(schedule.hour, schedule.minute, 0, 0);
        if (candidate <= now) continue;
        return { turno, datetime: candidate };
      }

      const firstSchedule = TURNO_SCHEDULE[TURNOS[0]];
      const nextDay = new Date(baseDate);
      nextDay.setDate(nextDay.getDate() + 1);
      nextDay.setHours(firstSchedule.hour, firstSchedule.minute, 0, 0);
      while (nextDay <= now) {
        nextDay.setDate(nextDay.getDate() + 1);
      }
      return { turno: TURNOS[0], datetime: nextDay };
    }

    function updateCountdownDisplay() {
      if (!countdownTargetEl || !countdownTimerEl) return;
      const { fecha, pais } = getFilters();
      const next = computeNextSlot({ fecha, pais });
      if (!next) {
        countdownTargetEl.textContent = "Sin horario";
        countdownTimerEl.textContent = "--:--:--";
        return;
      }

      const targetDate = next.datetime;
      const targetLabelDate = targetDate.toISOString().slice(0, 10);
      const targetLabelTime = targetDate.toLocaleTimeString("es-ES", { hour: "2-digit", minute: "2-digit" });
      const paisLabel = pais ? ` ¬∑ ${pais}` : "";
      countdownTargetEl.textContent = `${targetLabelDate} ${targetLabelTime}${paisLabel}`;
      const countdownLabelEl = document.querySelector("[data-countdown-label]");
      if (countdownLabelEl) {
        countdownLabelEl.textContent = `Tiempo para el sorteo ${next.turno}`;
      }

      const updateTimer = () => {
        const now = new Date();
        const diff = targetDate - now;
        if (diff <= 0) {
          countdownTimerEl.textContent = "00:00:00";
          if (countdownInterval) {
            clearInterval(countdownInterval);
            countdownInterval = null;
          }
          setTimeout(updateCountdownDisplay, 1000);
          return;
        }
        const hours = Math.floor(diff / (1000 * 60 * 60));
        const minutes = Math.floor((diff / (1000 * 60)) % 60);
        const seconds = Math.floor((diff / 1000) % 60);
        countdownTimerEl.textContent = `${String(hours).padStart(2, "0")}:${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`;
      };

      if (countdownInterval) clearInterval(countdownInterval);
      updateTimer();
      countdownInterval = setInterval(updateTimer, 1000);
    }

    updateCountdownDisplay();



    const btnAprender = document.getElementById("btn-aprender-dia");
    btnAprender?.addEventListener("click", async () => {
      const { fecha, pais } = getFilters();
      if (!fecha || !pais) {
        showToast("Selecciona fecha y pa√≠s para procesar el aprendizaje.", { variant: "warning" });
        return;
      }
      const draws = (await DB.listDraws({ excludeTest: true })).filter(
        (d) => d.fecha === fecha && d.pais === pais
      );
      if (!draws.length) {
        showToast("No hay sorteos reales registrados para esa fecha y pa√≠s.", { variant: "warning" });
        return;
      }
      const normalizedPais = (pais || "").trim().toUpperCase();
      const alreadyLogged = (await DB.getHypothesisLogs()).some(
        (log) =>
          log.fechaResultado === fecha &&
          ((log.paisResultado || "").trim().toUpperCase() === normalizedPais)
      );
      if (alreadyLogged) {
        showToast("Los resultados de ese d√≠a ya fueron procesados anteriormente.", {
          variant: "info",
          timeout: 3200,
        });
        return;
      }
      try {
        for (const draw of draws) {
          const simbolo = getSymbol(draw.numero);
          await registrarResultado({
            numero: draw.numero,
            simbolo,
            fecha: draw.fecha,
            pais: draw.pais,
            horario: draw.horario,
          });
        }
        await DB.closePredictionBatch({ fecha, pais });
        await rebuildKnowledge();
        await refreshHypotesis();
        showToast("Hip√≥tesis actualizadas con los resultados del d√≠a.", { variant: "success" });
      } catch (err) {
        console.error("aprendizaje error", err);
        showToast(`Error al registrar resultados: ${err.message}`, { variant: "danger" });
      }
    });

    const hypoFechaInput = document.getElementById("h-fecha");
    const hypoTurnoSelect = document.getElementById("h-turno");
    const hypoNumeroInput = document.getElementById("h-numero");
    const hypoTextoInput = document.getElementById("h-texto");
    const btnHipotesis = document.getElementById("h-guardar");
    let editingHypothesisId = null;

    function resetHypothesisForm() {
      editingHypothesisId = null;
      if (btnHipotesis) btnHipotesis.textContent = "Guardar hip√≥tesis";
      if (hypoNumeroInput) hypoNumeroInput.value = "";
      if (hypoTextoInput) hypoTextoInput.value = "";
    }

    async function refreshHypotesis() {
      const cont = document.getElementById("h-list");
      if (!cont) return;
      cont.classList.add("cards", "hypo-list");
      const hyps = await DB._getAll("hypotheses");
      if (!hyps.length) {
        cont.innerHTML = "<p class='hint'>A√∫n no hay hip√≥tesis registradas.</p>";
        return;
      }
      hyps.sort((a, b) => (b.createdAt || 0) - (a.createdAt || 0));
      cont.innerHTML = "";
      for (const h of hyps) {
        const card = document.createElement("div");
        card.className = "card hypo-card";

        const simbolo = h.simbolo || getSymbol(h.numero) || "";
        const estado = (h.estado || "pendiente").toLowerCase();
        const fecha = h.fecha || "(sin fecha)";
        const turno = h.turno || "";
        const razones = (h.razones || []).filter(Boolean).join(" ¬∑ ") || "Sin notas";

        const head = document.createElement("div");
        head.className = "card-head";

        const title = document.createElement("span");
        title.className = "hypo-title";
        title.textContent = `${formatNumber(h.numero)} ${simbolo}`.trim();
        head.appendChild(title);

        const badge = document.createElement("span");
        badge.className = `badge-state badge-${estado}`;
        badge.textContent = estado;
        head.appendChild(badge);

        card.appendChild(head);

        const body = document.createElement("div");
        body.className = "card-body hypo-body";

        const fechaSpan = document.createElement("span");
        fechaSpan.innerHTML = `<strong>Fecha:</strong> ${fecha}${turno ? ` ‚Ä¢ ${turno}` : ""}`;
        body.appendChild(fechaSpan);

        const notaSpan = document.createElement("span");
        notaSpan.innerHTML = `<strong>Notas:</strong> ${razones}`;
        body.appendChild(notaSpan);

        card.appendChild(body);

        const actions = document.createElement("div");
        actions.className = "hypo-actions";

        const editBtn = document.createElement("button");
        editBtn.type = "button";
        editBtn.className = "btn-secondary";
        editBtn.textContent = "Editar";
        editBtn.addEventListener("click", () => {
          editingHypothesisId = h.id;
          if (hypoFechaInput) hypoFechaInput.value = h.fecha || "";
          if (hypoTurnoSelect) hypoTurnoSelect.value = h.turno || "";
          if (hypoNumeroInput) hypoNumeroInput.value = String(h.numero).padStart(2, "0");
          if (hypoTextoInput) hypoTextoInput.value = (h.razones && h.razones[0]) || "";
          if (btnHipotesis) btnHipotesis.textContent = "Actualizar hip√≥tesis";
          showToast(`Editando hip√≥tesis ${formatNumber(h.numero)}`, { variant: "info", timeout: 2000 });
        });
        actions.appendChild(editBtn);

        const cancelBtn = document.createElement("button");
        cancelBtn.type = "button";
        cancelBtn.className = "btn-ghost";
        cancelBtn.textContent = "Cancelar";
        cancelBtn.addEventListener("click", () => {
          resetHypothesisForm();
          showToast("Edici√≥n cancelada.", { variant: "warning", timeout: 1800 });
        });
        actions.appendChild(cancelBtn);

        card.appendChild(actions);

        cont.appendChild(card);
      }
    }

    btnHipotesis?.addEventListener("click", async () => {
      const fecha = hypoFechaInput?.value;
      const turno = hypoTurnoSelect?.value;
      const numeroRaw = hypoNumeroInput?.value.trim() ?? "";
      const texto = hypoTextoInput?.value.trim() ?? "";
      if (!/^\d{1,2}$/.test(numeroRaw)) {
        showToast("Ingresa un n√∫mero v√°lido (00-99) para la hip√≥tesis.", { variant: "warning" });
        return;
      }
      const numero = parseInt(numeroRaw, 10);
      try {
        if (editingHypothesisId) {
          await actualizarHipotesis(
            editingHypothesisId,
            numero,
            getSymbol(numero),
            texto,
            { fecha, turno }
          );
          resetHypothesisForm();
          showToast("Hip√≥tesis actualizada.", { variant: "success" });
        } else {
          await crearHipotesis(numero, getSymbol(numero), texto, { fecha, turno });
          resetHypothesisForm();
          showToast("Hip√≥tesis guardada.", { variant: "success" });
        }
        await refreshHypotesis();
      } catch (err) {
        console.error("hipotesis error", err);
        showToast(`No se pudo guardar la hip√≥tesis: ${err.message}`, { variant: "danger" });
      }
    });

    const btnAnalizar = document.getElementById("btn-analizar");
    const resultEscenarios = document.getElementById("result-escenarios");
    const resultRecomendacion = document.getElementById("result-recomendacion");
    const resultPlan = document.getElementById("result-plan");

    btnAnalizar?.addEventListener("click", async () => {
      if (resultEscenarios) resultEscenarios.innerHTML = "<p class='hint'>Analizando‚Ä¶</p>";
      if (resultRecomendacion) resultRecomendacion.innerHTML = "";
      if (resultPlan) resultPlan.innerHTML = "";
      try {
        await rebuildKnowledge();
        const analisis = await analizarYProponer(GUIA);
        const patrones = await detectarPatrones();
        const memoria = await obtenerPerfilesNumeros();
        const modoEval = await evaluarModos();
        const perfilMap = new Map(
          (memoria.perfiles || []).map((p) => [p.numero, p])
        );
        let predicciones = generarPredicciones(memoria.perfiles || [], { top: 9 });
        predicciones = mezclarPrediccionesConModos(predicciones, modoEval);
        const insights = generarInsights(memoria.perfiles || []);

        const { fecha: fechaFiltro, pais: paisFiltro } = getFilters();
        if (predicciones.length) {
          if (fechaFiltro || paisFiltro) {
            await DB.logPredictions(predicciones, {
              fecha: fechaFiltro || null,
              pais: paisFiltro || null,
            });
          } else {
            showToast(
              "Predicciones registradas como simulaci√≥n. Selecciona fecha y pa√≠s para evaluar aciertos.",
              { variant: "warning", timeout: 5000 }
            );
          }
        }

        const resumenPred = await obtenerResumenPredicciones();

        renderEscenarios(
          analisis.escenarios || [],
          patrones,
          predicciones,
          perfilMap,
          memoria.totalDraws || 0,
          memoria.latestTimestamp || null,
          insights,
          modoEval
        );
        renderRecomendaciones(
          analisis.recomendacion || [],
          analisis.nota,
          predicciones,
          perfilMap,
          resumenPred
        );
        let drawsSeleccionados = [];
        if (fechaFiltro && paisFiltro) {
          const drawsDelDia = await DB.listDraws({ excludeTest: true });
          drawsSeleccionados = drawsDelDia.filter(
            (draw) => draw.fecha === fechaFiltro && draw.pais === paisFiltro
          );
        }

        renderPlanDia(
          predicciones,
          perfilMap,
          modoEval,
          patrones.timelineActiva || [],
          patrones.hallazgos || [],
          patrones.resumenVentana || "",
          drawsSeleccionados
        );
      } catch (err) {
        console.error("analizar error", err);
        if (resultEscenarios)
          resultEscenarios.innerHTML = `<p class='hint'>No se pudo completar el an√°lisis: ${err.message}</p>`;
      }
    });

    function mejorTurnoSegunPerfil(perfil) {
      const aprendizaje = perfil?.aprendizaje?.porHorario || {};
      let bestTurno = null;
      let bestRatio = -1;
      Object.entries(aprendizaje).forEach(([turno, stats]) => {
        if (!stats.total) return;
        const rate = stats.aciertos / stats.total;
        if (rate > bestRatio) {
          bestRatio = rate;
          bestTurno = turno;
        }
      });
      if (bestTurno) {
        return { turno: bestTurno, ratio: bestRatio, fuente: "aprendizaje" };
      }

      const historico = perfil?.porHorario || {};
      let bestCount = -1;
      Object.entries(historico).forEach(([turno, total]) => {
        if (total > bestCount) {
          bestCount = total;
          bestTurno = turno;
        }
      });
      if (bestTurno) {
        return { turno: bestTurno, ratio: bestCount, fuente: "historial" };
      }

      if (perfil?.lastSeen?.horario) {
        return { turno: perfil.lastSeen.horario, ratio: 0, fuente: "√∫ltimo" };
      }
      return { turno: TURNOS[0], ratio: 0, fuente: "predeterminado" };
    }

    function resumenModos(modos = []) {
      if (!modos.length) return "";
      const etiqueta = modos
        .slice(0, 2)
        .map((m) => {
          const conf = Math.round((m.confianza || 0) * 100);
          const nombre = m.modeNombre || "Modo";
          const op = m.operacion ? ` ¬∑ ${m.operacion}` : "";
          return `${nombre}${op}${conf ? ` (${conf}%)` : ""}`;
        })
        .join(" | ");
      return etiqueta;
    }

    function notasPatronNumero(hallazgos, numero) {
      const notes = [];
      hallazgos
        .filter((h) => h.id?.startsWith("repeat-") && h.numero === numero)
        .slice(0, 2)
        .forEach((h) => {
          const datos = h.datos || {};
          const muestras = datos.muestras?.length ? ` ¬∑ ${datos.muestras.join(" ¬∑ ")}` : "";
          notes.push(`${datos.tipo || "Repetici√≥n"}${muestras}`);
        });

      const gapHallazgo = hallazgos.find((h) => h.id?.startsWith("gap-") && h.numero === numero);
      if (gapHallazgo?.datos?.gap) {
        const gapDias = gapHallazgo.datos.gap;
        const evidencia = gapHallazgo.evidencia || [];
        const ultimaCoincidencia = evidencia.length ? evidencia[evidencia.length - 1] : null;
        const ultimaFecha = parseISODate(ultimaCoincidencia?.fecha);
        const nextDate =
          parseISODate(gapHallazgo.siguienteFechaEsperada) ||
          (ultimaFecha ? new Date(ultimaFecha.getTime() + gapDias * DAY_MS) : null);
        if (nextDate) {
          const today = new Date();
          today.setHours(0, 0, 0, 0);
          const diffDays = Math.round((nextDate - today) / DAY_MS);
          const status =
            diffDays > 0
              ? `en ${diffDays} d√≠as`
              : diffDays === 0
              ? "hoy"
              : `hace ${Math.abs(diffDays)} d√≠as`;
          notes.push(`Intervalo ${gapDias}d ‚Üí pr√≥ximo ${formatISODate(nextDate)} (${status})`);
        } else {
          notes.push(`Intervalo ${gapDias}d observado`);
        }
      }
      return notes;
    }

    function renderPlanDia(
      predicciones,
      perfilMap,
      modoEval,
      timelineActiva = [],
      hallazgos = [],
      resumenVentana = "",
      drawsDia = []
    ) {
      if (!resultPlan) return;
      resultPlan.innerHTML = "";

      if (!predicciones.length) {
        resultPlan.innerHTML = "<p class='hint'>A√∫n no hay un plan diario ‚Äî registra sorteos reales para 2025.</p>";
        return;
      }

      const { fecha: filtrosFecha, pais: filtrosPais } = getFilters();
      const fechaObjetivo = filtrosFecha || "(sin fecha)";
      const paisObjetivo = filtrosPais || "";
      const drawsJugados = Array.isArray(drawsDia) ? drawsDia : [];
      const generadoEn = new Date();
      const generadoHora = generadoEn.toLocaleTimeString("es-ES", {
        hour: "2-digit",
        minute: "2-digit",
      });
      const today = new Date();
      today.setHours(0, 0, 0, 0);

      const lastByNumero = new Map();
      timelineActiva.forEach((draw) => {
        lastByNumero.set(draw.numero, draw);
      });

      const detallePorNumero = modoEval?.detallePorNumero || {};

      const planBuckets = new Map();
      TURNOS.forEach((turno) => planBuckets.set(turno, []));

      let planSections = 0;

      predicciones.forEach((item) => {
        const perfil = perfilMap.get(item.numero);
        const turnoInfo = mejorTurnoSegunPerfil(perfil);
        const bucket = planBuckets.get(turnoInfo.turno) || planBuckets.get(TURNOS[0]);
        const yaJugadoMismoTurno = drawsJugados.some(
          (draw) => draw.numero === item.numero && draw.horario === turnoInfo.turno
        );
        if (yaJugadoMismoTurno) return;
        const lastSeen = perfil?.lastSeen || null;
        const modoResumen = resumenModos(item.modos);
        const patronNotas = notasPatronNumero(hallazgos, item.numero);
        bucket.push({
          item,
          perfil,
          turnoInfo,
          lastSeen,
          modoResumen,
          patronNotas,
        });
      });

      const grid = document.createElement("div");
      grid.className = "plan-grid";

      TURNOS.forEach((turno) => {
        const candidatos = (planBuckets.get(turno) || [])
          .filter(Boolean)
          .sort((a, b) => b.item.score - a.item.score)
          .slice(0, 3);
        if (!candidatos.length) return;

        const card = document.createElement("div");
        card.className = "analysis-card plan";

        const head = document.createElement("div");
        head.className = "card-head";
        head.textContent = `Candidatos ${turno}`;
        card.appendChild(head);

        const meta = document.createElement("div");
        meta.className = "plan-meta";
        meta.textContent = `Fecha ${fechaObjetivo}${paisObjetivo ? ` ¬∑ ${paisObjetivo}` : ""} ¬∑ Generado ${generadoHora}`;
        card.appendChild(meta);

        const list = document.createElement("div");
        list.className = "plan-list";

        candidatos.forEach(({ item, perfil, turnoInfo, lastSeen, modoResumen, patronNotas }) => {
          const row = document.createElement("div");
          row.className = "plan-item";

          const numberEl = document.createElement("div");
          numberEl.className = "plan-number";
          const symbol = getSymbol(item.numero);
          numberEl.textContent = symbol
            ? `${formatNumber(item.numero)} ${symbol}`
            : formatNumber(item.numero);
          row.appendChild(numberEl);

          const scoreEl = document.createElement("div");
          scoreEl.className = "plan-score";
          scoreEl.textContent = `${Math.round(item.score * 100)}% score`;
          row.appendChild(scoreEl);

          const details = document.createElement("ul");
          details.className = "plan-detail";

          if (lastSeen) {
            const li = document.createElement("li");
            li.textContent = `√öltima vez: ${lastSeen.fecha} ${lastSeen.horario || ""}`;
            details.appendChild(li);
          }

          if (turnoInfo?.fuente === "aprendizaje" && Number.isFinite(turnoInfo.ratio)) {
            const li = document.createElement("li");
            li.textContent = `Historial turno ${turno}: ${(turnoInfo.ratio * 100).toFixed(0)}% acierto`;
            details.appendChild(li);
          }

          if (modoResumen) {
            const li = document.createElement("li");
            li.textContent = `Modos: ${modoResumen}`;
            details.appendChild(li);
          }

          patronNotas.forEach((nota) => {
            const li = document.createElement("li");
            li.textContent = nota;
            details.appendChild(li);
          });

          if (!details.children.length) {
            const li = document.createElement("li");
            li.textContent = "Sin contexto adicional";
            details.appendChild(li);
          }

          row.appendChild(details);
          list.appendChild(row);
        });

        card.appendChild(list);
        if (resumenVentana) {
          const foot = document.createElement("div");
          foot.className = "plan-footnote";
          foot.textContent = resumenVentana;
          card.appendChild(foot);
        }

        grid.appendChild(card);
        planSections += 1;
      });

      const LONG_GAP_THRESHOLD = 120;
      const RECENT_RETURN_WINDOW = 10;
      const sequiasRota = [];
      const sequiasActivas = [];
      perfilMap.forEach((perfil) => {
        const gaps = perfil?.gaps || {};
        if (!perfil?.lastSeen || gaps.ultimo === null || gaps.ultimo === undefined) return;
        const lastSeen = perfil.lastSeen;
        const daysSince = typeof gaps.daysSince === "number" ? Math.round(gaps.daysSince) : null;
        const gapPrevio = Math.round(gaps.ultimo);
        const promedio = typeof gaps.promedio === "number" ? gaps.promedio : null;
        if (gapPrevio >= LONG_GAP_THRESHOLD) {
          const registroBase = {
            numero: perfil.numero,
            perfilRef: perfil,
            lastSeen,
            gapPrevio,
            promedio,
            daysSince,
          };
          if (daysSince !== null && daysSince <= RECENT_RETURN_WINDOW) {
            sequiasRota.push(registroBase);
          } else if (daysSince !== null && daysSince >= LONG_GAP_THRESHOLD) {
            sequiasActivas.push(registroBase);
          }
        } else if (
          daysSince !== null &&
          daysSince >= LONG_GAP_THRESHOLD &&
          gaps.max !== null &&
          Math.round(gaps.max) >= LONG_GAP_THRESHOLD
        ) {
          sequiasActivas.push({
            numero: perfil.numero,
            perfilRef: perfil,
            lastSeen,
            gapPrevio: Math.round(gaps.max),
            promedio,
            daysSince,
          });
        }
      });

      let droughtCard = null;
      if (sequiasRota.length || sequiasActivas.length) {
        droughtCard = document.createElement("div");
        droughtCard.className = "analysis-card drought";

        const head = document.createElement("div");
        head.className = "card-head";
        head.textContent = "Alertas de sequ√≠a";
        droughtCard.appendChild(head);

        const meta = document.createElement("div");
        meta.className = "plan-meta";
        meta.textContent = `Se consideran sequ√≠as de ${LONG_GAP_THRESHOLD}+ d√≠as.`;
        droughtCard.appendChild(meta);

        const list = document.createElement("div");
        list.className = "plan-list";

        const buildRow = (entry, label) => {
          const row = document.createElement("div");
          row.className = "plan-item";

          const numberEl = document.createElement("div");
          numberEl.className = "plan-number";
          const symbol = getSymbol(entry.numero);
          numberEl.textContent = symbol
            ? `${formatNumber(entry.numero)} ${symbol}`
            : formatNumber(entry.numero);
          row.appendChild(numberEl);

          const badge = document.createElement("div");
          badge.className = "plan-score";
          badge.textContent = label;
          row.appendChild(badge);

          const details = document.createElement("ul");
          details.className = "plan-detail";

          const lastSeenText = entry.lastSeen
            ? `√öltima vez: ${entry.lastSeen.fecha} ${entry.lastSeen.horario || ""}`
            : null;
          if (lastSeenText) {
            const li = document.createElement("li");
            li.textContent = lastSeenText;
            details.appendChild(li);
          }

          const gapLi = document.createElement("li");
          gapLi.textContent = `Gap previo: ${entry.gapPrevio} d√≠as`;
          details.appendChild(gapLi);

          if (entry.promedio) {
            const avgLi = document.createElement("li");
            avgLi.textContent = `Gap promedio hist√≥rico: ${entry.promedio.toFixed(1)} d√≠as`;
            details.appendChild(avgLi);
          }

          if (typeof entry.daysSince === "number") {
            const sinceLi = document.createElement("li");
            sinceLi.textContent =
              entry.daysSince === 0
                ? "Reapareci√≥ hoy"
                : entry.daysSince === 1
                ? "Reapareci√≥ ayer"
                : `D√≠as desde √∫ltimo sorteo: ${entry.daysSince}`;
            details.appendChild(sinceLi);
          }

          const perfilRef = entry.perfilRef;
          const historialRegistros = Array.isArray(perfilRef?.gaps?.historial)
            ? perfilRef.gaps.historial.filter(
                (item) => Number.isFinite(item?.gap) && item.gap >= LONG_GAP_THRESHOLD
              )
            : [];
          if (historialRegistros.length) {
            const minHist = Math.min(...historialRegistros.map((h) => h.gap));
            const maxHist = Math.max(...historialRegistros.map((h) => h.gap));
            const avgHist =
              historialRegistros.reduce((acc, h) => acc + h.gap, 0) / historialRegistros.length;
            const rangeLi = document.createElement("li");
            rangeLi.textContent = `Historial largo: ${minHist}-${maxHist} d√≠as (${historialRegistros.length} eventos)`;
            details.appendChild(rangeLi);

            const lastSeenDate = parseISODate(entry.lastSeen?.fecha);
            if (lastSeenDate && Number.isFinite(avgHist) && avgHist > 0) {
              const avgGapRounded = Math.round(avgHist);
              const estimado = new Date(lastSeenDate.getTime() + avgGapRounded * DAY_MS);
              if (!Number.isNaN(estimado.getTime())) {
                const diff = Math.round((estimado - today) / DAY_MS);
                const statusHist =
                  diff > 0
                    ? `faltan ${diff} d√≠as`
                    : diff === 0
                    ? "hoy"
                    : `vencido hace ${Math.abs(diff)} d√≠as`;
                const avgLi = document.createElement("li");
                avgLi.textContent = `Proyecci√≥n hist√≥rica: ${formatISODate(estimado)} (~${avgGapRounded}d, ${statusHist})`;
                details.appendChild(avgLi);
              }
            }

            const ultimoComparable = historialRegistros[historialRegistros.length - 1];
            if (ultimoComparable?.gap && ultimoComparable?.hasta?.fecha) {
              const li = document.createElement("li");
              const desde = ultimoComparable.desde?.fecha ? `${ultimoComparable.desde.fecha} ‚Üí ` : "";
              li.textContent = `√öltima sequ√≠a similar: ${ultimoComparable.gap}d (${desde}${ultimoComparable.hasta.fecha})`;
              details.appendChild(li);
            }
          }

          row.appendChild(details);
          return row;
        };

        sequiasRota
          .sort((a, b) => b.gapPrevio - a.gapPrevio)
          .forEach((entry) => list.appendChild(buildRow(entry, "Seca rota")));
        sequiasActivas
          .sort((a, b) => b.daysSince - a.daysSince)
          .forEach((entry) => list.appendChild(buildRow(entry, "Sequ√≠a en curso")));

        droughtCard.appendChild(list);
        grid.appendChild(droughtCard);
      }

      let hasGapCard = false;
      const gapSeguimiento = hallazgos
        .filter((h) => h.id?.startsWith("gap-"))
        .map((h) => {
          const gapDias = Number(h.datos?.gap);
          if (!Number.isFinite(gapDias) || gapDias <= 0) return null;
          const evidencia = Array.isArray(h.evidencia) ? h.evidencia : [];
          const ultimaCoincidencia = evidencia.length ? evidencia[evidencia.length - 1] : null;
          const lastDate = parseISODate(ultimaCoincidencia?.fecha);
          const nextDate =
            parseISODate(h.siguienteFechaEsperada) ||
            (lastDate ? new Date(lastDate.getTime() + gapDias * DAY_MS) : null);
          const diffDays =
            nextDate && Number.isFinite(nextDate.getTime())
              ? Math.round((nextDate - today) / DAY_MS)
              : null;
          const status =
            diffDays === null
              ? "sin estimaci√≥n"
              : diffDays > 0
              ? `faltan ${diffDays} d√≠as`
              : diffDays === 0
              ? "esperado hoy"
              : `vencido hace ${Math.abs(diffDays)} d√≠as`;
          return {
            numero: h.numero,
            gap: gapDias,
            coincidencias: Number(h.datos?.coincidencias || 0),
            intervalos: Number(h.datos?.intervalos || 0),
            lastSeen: ultimaCoincidencia
              ? {
                  fecha: ultimaCoincidencia.fecha,
                  horario: ultimaCoincidencia.horario,
                }
              : null,
            nextDate,
            diffDays,
            status,
            horarioSugerido: h.datos?.siguienteHorario || ultimaCoincidencia?.horario || null,
          };
        })
        .filter(Boolean)
        .sort((a, b) => {
          const aDiff = a.diffDays === null ? Number.POSITIVE_INFINITY : a.diffDays;
          const bDiff = b.diffDays === null ? Number.POSITIVE_INFINITY : b.diffDays;
          return aDiff - bDiff;
        });

      if (gapSeguimiento.length) {
        hasGapCard = true;
        const gapCard = document.createElement("div");
        gapCard.className = "analysis-card interval";

        const head = document.createElement("div");
        head.className = "card-head";
        head.textContent = "Seguimiento de intervalos";
        gapCard.appendChild(head);

        const meta = document.createElement("div");
        meta.className = "plan-meta";
        meta.textContent = "N√∫meros con patr√≥n de d√≠as constantes.";
        gapCard.appendChild(meta);

        const list = document.createElement("div");
        list.className = "plan-list";

        gapSeguimiento.forEach((entry) => {
          const row = document.createElement("div");
          row.className = "plan-item";

          const numberEl = document.createElement("div");
          numberEl.className = "plan-number";
          const symbol = getSymbol(entry.numero);
          numberEl.textContent = symbol
            ? `${formatNumber(entry.numero)} ${symbol}`
            : formatNumber(entry.numero);
          row.appendChild(numberEl);

          const badge = document.createElement("div");
          badge.className = "plan-score";
          badge.textContent = `${entry.gap} d√≠as`;
          row.appendChild(badge);

          const details = document.createElement("ul");
          details.className = "plan-detail";

          if (entry.lastSeen) {
            const li = document.createElement("li");
            li.textContent = `√öltima coincidencia: ${entry.lastSeen.fecha} ${entry.lastSeen.horario || ""}`;
            details.appendChild(li);
          }

          if (entry.nextDate) {
            const li = document.createElement("li");
            const fechaFmt = formatISODate(entry.nextDate);
            const horario = entry.horarioSugerido ? ` ${entry.horarioSugerido}` : "";
            li.textContent = `Pr√≥xima estimada: ${fechaFmt || "N/D"}${horario ? ` ${horario}` : ""} (${entry.status})`;
            details.appendChild(li);
          } else {
            const li = document.createElement("li");
            li.textContent = `Pr√≥xima estimada: sin datos (${entry.status})`;
            details.appendChild(li);
          }

          const ratioLi = document.createElement("li");
          const total = entry.intervalos || 0;
          ratioLi.textContent = `Coincidencias: ${entry.coincidencias}/${total} intervalos`;
          details.appendChild(ratioLi);

          row.appendChild(details);
          list.appendChild(row);
        });

        gapCard.appendChild(list);
        grid.appendChild(gapCard);
      }

      if (planSections === 0 && !droughtCard && !hasGapCard) {
        resultPlan.innerHTML = "<p class='hint'>No hay suficientes datos recientes para un plan diario.</p>";
        return;
      }

      resultPlan.appendChild(grid);

      const note = document.createElement("p");
      note.className = "plan-note";
      note.textContent = "Plan generado con sorteos 2025 y modos validados.";
      resultPlan.appendChild(note);
    }

    function mezclarPrediccionesConModos(predicciones, modoEval) {
      if (!modoEval) return predicciones;
      const scoreMap = new Map();
      Object.entries(modoEval.scorePorNumero || {}).forEach(([key, value]) => {
        const numero = parseInt(key, 10);
        if (!Number.isFinite(numero)) return;
        if (Number.isFinite(value)) scoreMap.set(numero, value);
      });
      const detallePorNumero = modoEval.detallePorNumero || {};

      const merged = predicciones.map((p) => {
        const boost = scoreMap.get(p.numero) || 0;
        const key = String(p.numero).padStart(2, "0");
        const modos = detallePorNumero[key] || [];
        const newScore = Math.min(1, p.score + boost * 0.35);
        return { ...p, score: newScore, modoBoost: boost, modos };
      });

      const existentes = new Set(merged.map((p) => p.numero));
      (modoEval.sugerencias || []).forEach((sug) => {
        const numero = parseInt(sug.numero, 10);
        if (!Number.isFinite(numero)) return;
        if (!existentes.has(numero)) {
          const score = Math.min(1, (sug.confianza || 0) * 0.6);
          merged.push({
            numero,
            score,
            frecuencia: 0,
            recencia: 0,
            hipotesis: 0,
            contexto: 0,
            modoBoost: sug.confianza || 0,
            modos: [sug],
          });
          existentes.add(numero);
        } else {
          const target = merged.find((p) => p.numero === numero);
          if (target) target.modos = [...(target.modos || []), sug];
        }
      });

      merged.sort((a, b) => b.score - a.score);
      return merged.slice(0, 9);
    }

    function renderEscenarios(
      escenarios,
      patrones,
      predicciones = [],
      perfilMap = new Map(),
      totalDraws = 0,
      latestTimestamp = null,
      insights = [],
      modoEval = null
    ) {
      if (!resultEscenarios) return;
      resultEscenarios.innerHTML = "";

      const grid = document.createElement("div");
      grid.className = "analysis-grid";
      resultEscenarios.appendChild(grid);

      if (latestTimestamp) {
        const daysDiff = Math.floor((Date.now() - latestTimestamp) / (1000 * 60 * 60 * 24));
        if (daysDiff > 30) {
          const lastWarnTs = parseInt(localStorage.getItem("recencyWarnTs"), 10) || 0;
          if (lastWarnTs !== latestTimestamp) {
            const lastDate = new Date(latestTimestamp).toISOString().slice(0, 10);
            showToast(
              `√öltimo sorteo registrado: ${lastDate} (‚âà${daysDiff} d√≠as). Agrega resultados recientes para reemplazar las predicciones simuladas.`,
              { variant: "warning", timeout: 9000 }
            );
            localStorage.setItem("recencyWarnTs", String(latestTimestamp));
          }
        }
      }

      if (patrones?.mensaje) {
        const card = document.createElement("div");
        card.className = "analysis-card summary";
        const head = document.createElement("div");
        head.className = "card-head";
        head.textContent = "Tendencias recientes";
        card.appendChild(head);

        const note = document.createElement("div");
        note.className = "analysis-note";
        note.textContent = patrones.mensaje;
        card.appendChild(note);

        if (patrones.resumenVentana) {
          const windowNote = document.createElement("div");
          windowNote.className = "analysis-footnote";
          windowNote.textContent = patrones.resumenVentana;
          card.appendChild(windowNote);
        }
        grid.appendChild(card);
      }

      if (modoEval?.sugerencias?.length) {
        const card = document.createElement("div");
        card.className = "analysis-card insight accent-medium";
        const head = document.createElement("div");
        head.className = "card-head";
        head.textContent = "Modos aprendidos";
        card.appendChild(head);

        const list = document.createElement("ul");
        list.className = "analysis-insights";
        modoEval.sugerencias.slice(0, 6).forEach((sug) => {
          const li = document.createElement("li");
          const conf = Math.round((sug.confianza || 0) * 100);
          const base = String(sug.baseNumero ?? sug.original ?? "").padStart(2, "0");
          const target = String(sug.numero).padStart(2, "0");
          const modeName = sug.modeNombre || "Modo";
          const opLabel = OPERACION_LABELS[sug.operacion];
          const opTag = opLabel ? ` ¬∑ ${opLabel}` : "";
          const nota = sug.nota ? ` ‚Äî ${sug.nota}` : "";
          li.innerHTML = `<strong>${modeName}</strong>${opTag}: ${base} ‚Üí ${target} (${conf}% conf)${nota}`;
          list.appendChild(li);
        });
        card.appendChild(list);
        grid.appendChild(card);
      }

      if (patrones?.hallazgos?.length) {
        patrones.hallazgos.forEach((hallazgo) => {
          const card = document.createElement("div");
          card.className = "analysis-card pattern";
          const conf = Math.round((hallazgo.confianza || 0) * 100);
          const level = hallazgo.confianza >= 0.75 ? "accent-strong" : hallazgo.confianza >= 0.5 ? "accent-medium" : "accent-soft";
          card.classList.add(level);

          const header = document.createElement("div");
          header.className = "card-head";
          header.textContent = hallazgo.titulo;

          const badge = document.createElement("span");
          badge.className = `analysis-badge ${level}`;
          badge.textContent = conf ? `${conf}% confianza` : "Sin m√©trica";
          header.appendChild(badge);
          card.appendChild(header);

          const number = Number.isFinite(hallazgo.numero)
            ? hallazgo.numero
            : Number.isFinite(hallazgo.evidencia?.[0]?.numero)
            ? hallazgo.evidencia[0].numero
            : null;
          if (Number.isFinite(number)) {
            const numberBadge = document.createElement("div");
            numberBadge.className = "analysis-number-lg";
            const formattedNumber = formatNumber(number);
            const symbol = getSymbol(number);
            const symbolSpan = symbol
              ? `<span class="analysis-number-symbol">${symbol}</span>`
              : "";
            numberBadge.innerHTML = `<span class="analysis-number-main">${formattedNumber}</span>${symbolSpan}`;
            card.appendChild(numberBadge);
          }

          const resumen = document.createElement("div");
          resumen.className = "pattern-summary";

          const detailList = document.createElement("ul");
          detailList.className = "pattern-detail";

          const addLine = (entry, fallbackClass) => {
            if (!entry) return;
            const config = typeof entry === "string" ? { text: entry } : { ...entry };
            const rawContent =
              typeof config.html === "string" ? config.html : config.text ?? "";
            if (typeof rawContent === "string" && !rawContent.trim()) return;
            const li = document.createElement("li");
            const classNames = (config.className || fallbackClass || "")
              .split(/\s+/)
              .map((cls) => cls.trim())
              .filter(Boolean);
            classNames.forEach((cls) => li.classList.add(cls));
            if (typeof config.html === "string") {
              li.innerHTML = config.html;
            } else {
              li.textContent = rawContent;
            }
            const hasSubentry = li.classList.contains("pattern-subentry");
            const iconValue =
              config.icon !== undefined
                ? config.icon
                : hasSubentry
                ? "‚Ü≥"
                : "‚Ä¢";
            if (iconValue) li.dataset.icon = iconValue;
            detailList.appendChild(li);
          };

          const formatTimelineSample = (s) => formatSampleDisplay({ fecha: s?.fecha, horario: s?.horario }) || "";

          if (hallazgo.id?.startsWith("gap-")) {
            const datos = hallazgo.datos || {};
            addLine({
              html: `<span class="pattern-label">Apariciones en ventana</span><div class="pattern-line"><span class="pattern-value">${datos.apariciones ?? "?"}</span></div>`,
              icon: "üìà",
            });
            addLine({
              html: `<span class="pattern-label">Intervalo modal</span><div class="pattern-line"><span class="pattern-value">${datos.gap ?? "?"} d√≠as</span><span class="pattern-muted">Coincidencias ${datos.coincidencias ?? "?"} de ${datos.intervalos ?? "?"}</span></div>`,
              icon: "‚è±Ô∏è",
            });
            if (hallazgo.siguienteFechaEsperada) {
              const proximoDisplay = formatSampleDisplay({
                fecha: hallazgo.siguienteFechaEsperada,
                horario: datos.siguienteHorario,
              });
              addLine({
                html: `<span class="pattern-label">Pr√≥xima estimada</span><div class="pattern-line"><span class="pattern-value">${proximoDisplay || hallazgo.siguienteFechaEsperada}</span></div>`,
                icon: "üß≠",
              });
            }
            (hallazgo.evidencia || []).slice(-3).forEach((item) => {
              if (!item) return;
              const origen = item.origen || {};
              const baseTxt = formatTimelineSample(origen) || "?";
              const destTxt = formatTimelineSample(item) || "?";
              addLine({
                text: `${baseTxt} ‚Üí ${destTxt}`,
                className: "pattern-subentry",
                icon: "‚Ü¨",
              });
            });
          } else if (hallazgo.id?.startsWith("dayOfWeek")) {
            const datos = hallazgo.datos || {};
            const etiqueta = datos.etiquetaCompleta || hallazgo.etiqueta || "";
            const ratio = Number.isFinite(datos.ratio) ? Math.round(datos.ratio * 100) : null;
            addLine({
              html: `<span class="pattern-label">D√≠a dominante</span><div class="pattern-line"><span class="pattern-value">${etiqueta}</span></div>`,
              icon: "üìÖ",
            });
            addLine({
              html: `<span class="pattern-label">Apariciones</span><div class="pattern-line"><span class="pattern-value">${datos.count ?? "?"}/${datos.total ?? "?"}</span>${ratio !== null ? `<span class="pattern-muted">${ratio}%</span>` : ""}</div>`,
              icon: "üìä",
            });
            const samples = datos.samples || [];
            if (samples.length) {
              addLine({ html: `<span class="pattern-label">√öltimos registros</span>`, icon: "üóÇÔ∏è" });
              samples.forEach((s) =>
                addLine({
                  text: formatTimelineSample(s) || "?",
                  className: "pattern-subentry",
                })
              );
            }
            if (datos.historial?.count) {
              const hist = datos.historial;
              const histRatio = Number.isFinite(hist.ratio) ? Math.round(hist.ratio * 100) : null;
              addLine({
                html: `<span class="pattern-label">Historial</span><div class="pattern-line"><span class="pattern-value">${hist.count} coincidencias</span>${histRatio !== null ? `<span class="pattern-muted">${histRatio}% del hist√≥rico</span>` : ""}</div>`,
                icon: "üß¨",
              });
              (hist.muestras || []).forEach((texto) =>
                addLine({ text: texto, className: "pattern-subentry" })
              );
            }
          } else if (hallazgo.id?.startsWith("horario")) {
            const datos = hallazgo.datos || {};
            const etiqueta = hallazgo.etiqueta || "";
            const ratio = Number.isFinite(datos.ratio) ? Math.round(datos.ratio * 100) : null;
            addLine({
              html: `<span class="pattern-label">Turno preferido</span><div class="pattern-line"><span class="pattern-value">${etiqueta}</span></div>`,
              icon: "üïí",
            });
            addLine({
              html: `<span class="pattern-label">Coincidencias</span><div class="pattern-line"><span class="pattern-value">${datos.count ?? "?"}/${datos.total ?? "?"}</span>${ratio !== null ? `<span class="pattern-muted">${ratio}%</span>` : ""}</div>`,
              icon: "üìä",
            });
            const samples = datos.samples || [];
            if (samples.length) {
              addLine({ html: `<span class="pattern-label">√öltimos registros</span>`, icon: "üóÇÔ∏è" });
              samples.forEach((s) =>
                addLine({
                  text: formatTimelineSample(s) || "?",
                  className: "pattern-subentry",
                })
              );
            }
            if (datos.historial?.count) {
              const hist = datos.historial;
              const histRatio = Number.isFinite(hist.ratio) ? Math.round(hist.ratio * 100) : null;
              addLine({
                html: `<span class="pattern-label">Historial</span><div class="pattern-line"><span class="pattern-value">${hist.count} coincidencias</span>${histRatio !== null ? `<span class="pattern-muted">${histRatio}% del hist√≥rico</span>` : ""}</div>`,
                icon: "üßæ",
              });
              (hist.muestras || []).forEach((texto) =>
                addLine({ text: texto, className: "pattern-subentry" })
              );
            }
          } else if (hallazgo.id?.startsWith("repeat-")) {
            const datos = hallazgo.datos || {};
            const tipo = datos.tipo || "";
            const ratio = Number.isFinite(datos.ratio) ? Math.round(datos.ratio * 100) : null;
            addLine({
              html: `<span class="pattern-label">Repite ${tipo}</span><div class="pattern-line"><span class="pattern-value">${datos.repeticiones ?? "?"} de ${datos.total ?? "?"}</span>${ratio !== null ? `<span class="pattern-muted">${ratio}%</span>` : ""}</div>`,
              icon: "üîÅ",
            });
            (datos.muestras || []).forEach((linea) =>
              addLine({
                text: formatTimelineSample(linea) || "",
                className: "pattern-subentry",
              })
            );
            if (datos.historial?.count) {
              const hist = datos.historial;
              const histRatio = Number.isFinite(hist.ratio) ? Math.round(hist.ratio * 100) : null;
              addLine({
                html: `<span class="pattern-label">Historial</span><div class="pattern-line"><span class="pattern-value">${hist.count} repeticiones</span>${histRatio !== null ? `<span class="pattern-muted">${histRatio}% del hist√≥rico</span>` : ""}</div>`,
                icon: "üßæ",
              });
            }
          } else {
            addLine({ text: hallazgo.resumen, icon: "‚ú®" });
          }

          if (!detailList.children.length) {
            addLine({ text: hallazgo.resumen ?? "Sin detalles adicionales.", icon: "‚ÑπÔ∏è" });
          }

          resumen.appendChild(detailList);
          card.appendChild(resumen);

          if (hallazgo.siguienteFechaEsperada) {
            const proximo = document.createElement("div");
            proximo.className = "analysis-chip";
            proximo.textContent = `Pr√≥xima: ${hallazgo.siguienteFechaEsperada}`;
            card.appendChild(proximo);
          }

          if (Array.isArray(hallazgo.evidencia) && hallazgo.evidencia.length) {
            const evidBox = document.createElement("div");
            evidBox.className = "analysis-evidence";
            hallazgo.evidencia.slice(-6).forEach((item) => {
              const line = document.createElement("span");
              const numeroFmt = formatNumber(item.numero);
              const origenText = item.origen ? ` ‚Üê ${item.origen.fecha} ${item.origen.horario}` : "";
              let text = `${item.fecha} ${item.horario} ¬∑ ${numeroFmt}${origenText}`;
              if (item.hipotesis?.length) {
                const hipos = item.hipotesis
                  .map((h) => (h.texto ? h.texto.trim() : `Hip√≥tesis #${h.id}`))
                  .filter(Boolean)
                  .slice(0, 2)
                  .join(" ¬∑ ");
                if (hipos) text += ` ¬∑ ${hipos}`;
                if (item.hipotesis.length > 2) text += " ‚Ä¶";
              }
              line.textContent = text;
              evidBox.appendChild(line);
            });
            card.appendChild(evidBox);
          }

          grid.appendChild(card);
        });
      }

      if (predicciones?.length) {
        const card = document.createElement("div");
        card.className = "analysis-card forecast";

        const header = document.createElement("div");
        header.className = "card-head";
        header.textContent = "Predicci√≥n aprendida";
        card.appendChild(header);

        if (totalDraws) {
          const meta = document.createElement("div");
          meta.className = "analysis-note";
          meta.textContent = `Aprendido de ${totalDraws} sorteos reales`;
          card.appendChild(meta);
        }

        const list = document.createElement("div");
        list.className = "analysis-forecast";

        predicciones.forEach((item) => {
          const perfil = perfilMap.get(item.numero);
          const row = document.createElement("div");
          row.className = "analysis-forecast-item";
          const headerRow = document.createElement("div");
          headerRow.className = "analysis-forecast-header";

          const numEl = document.createElement("div");
          numEl.className = "analysis-number";
          const formatted = formatNumber(item.numero);
          const symbol = getSymbol(item.numero);
          const symbolSpan = symbol
            ? `<span class="analysis-number-symbol analysis-number-symbol--sm">${symbol}</span>`
            : "";
          numEl.innerHTML = `<span class="analysis-number-main">${formatted}</span>${symbolSpan}`;

          const scoreEl = document.createElement("div");
          scoreEl.className = "analysis-score";
          scoreEl.innerHTML = `<strong>${Math.round(item.score * 100)}%</strong><span>score</span>`;

          headerRow.appendChild(numEl);
          headerRow.appendChild(scoreEl);

          const metrics = document.createElement("div");
          metrics.className = "analysis-forecast-metrics";
          metrics.innerHTML = `
            <span>Freq ${(item.frecuencia * 100).toFixed(1)}%</span>
            <span>Rec ${(item.recencia * 100).toFixed(1)}%</span>
            <span>Hip ${(item.hipotesis * 100).toFixed(1)}%</span>
            <span>Ctx ${(item.contexto * 100).toFixed(1)}%</span>
          `;

          row.appendChild(headerRow);
          row.appendChild(metrics);

          if (item.modos?.length) {
            const modes = document.createElement("div");
            modes.className = "analysis-forecast-context";
            const summary = item.modos
              .slice(0, 2)
              .map((m) => {
                const conf = Math.round((m.confianza || 0) * 100);
                const nombre = m.modeNombre || "Modo";
                const opLabel = OPERACION_LABELS[m.operacion];
                const opTag = opLabel ? ` ¬∑ ${opLabel}` : "";
                const confTag = conf ? ` ¬∑ ${conf}%` : "";
                return `${nombre}${opTag}${confTag}`;
              })
              .join(" | ");
            modes.textContent = summary;
            row.appendChild(modes);
          }

          if (perfil) {
            const desc = describirPerfil(perfil);
            if (desc) row.title = desc;

            const contextDetail = document.createElement("div");
            contextDetail.className = "analysis-forecast-context";

            const bestContext = (() => {
              const evaluators = [];
              const pickBest = (records, formatter) => {
                let best = null;
                Object.entries(records || {}).forEach(([key, stats]) => {
                  if (!stats.total) return;
                  const rate = stats.aciertos / stats.total;
                  if (!best || rate > best.rate) {
                    best = { rate, label: formatter(key, stats) };
                  }
                });
                if (best) evaluators.push(best);
              };

              pickBest(perfil.aprendizaje?.porPais, (key, stats) => `${key} ${Math.round((stats.aciertos / stats.total) * 100)}%`);
              pickBest(perfil.aprendizaje?.porHorario, (key, stats) => `${key} ${Math.round((stats.aciertos / stats.total) * 100)}%`);
              pickBest(perfil.aprendizaje?.porDiaSemana, (key, stats) => `${["Dom","Lun","Mar","Mi√©","Jue","Vie","S√°b"][key]} ${Math.round((stats.aciertos / stats.total) * 100)}%`);

              if (!evaluators.length) return null;
              evaluators.sort((a, b) => b.rate - a.rate);
              return evaluators[0];
            })();

            if (bestContext) {
              contextDetail.textContent = `Contexto destacado: ${bestContext.label}`;
              row.appendChild(contextDetail);
            }
          }

          list.appendChild(row);
        });

        card.appendChild(list);
        grid.appendChild(card);

        if (perfilMap.size) {
          const detail = document.createElement("div");
          detail.className = "analysis-card detail";
          const h = document.createElement("div");
          h.className = "card-head";
          h.textContent = "Perfiles destacados";
          detail.appendChild(h);

          const detailList = document.createElement("div");
          detailList.className = "analysis-detail-list";

          predicciones.slice(0, 3).forEach((item) => {
            const perfil = perfilMap.get(item.numero);
            if (!perfil) return;

            const block = document.createElement("div");
            block.className = "analysis-detail-item";

            const headerRow = document.createElement("div");
            headerRow.className = "analysis-detail-header";
            headerRow.innerHTML = `
              <span class="analysis-number">${formatNumber(item.numero)}</span>
              <span class="analysis-detail-score">${Math.round(item.score * 100)}%</span>
            `;

            const desc = document.createElement("div");
            desc.className = "analysis-detail-body";
            desc.textContent = describirPerfil(perfil) || "Sin historial suficiente.";

            const hypoSummary = document.createElement("div");
            hypoSummary.className = "analysis-detail-foot";
            const totalHyp = perfil.aprendizaje?.total || 0;
            if (totalHyp) {
              hypoSummary.textContent = `Hip√≥tesis: ${perfil.aprendizaje.aciertos}/${totalHyp} aciertos (${Math.round(
                (perfil.scoreHipotesis || 0) * 100
              )}%)`;
            } else if (perfil.hipotesis?.pendientes) {
              hypoSummary.textContent = `${perfil.hipotesis.pendientes} hip√≥tesis pendientes.`;
            } else {
              hypoSummary.textContent = "Sin hip√≥tesis registradas.";
            }

            block.appendChild(headerRow);
            block.appendChild(desc);
            block.appendChild(hypoSummary);
            detailList.appendChild(block);
          });

          detail.appendChild(detailList);
          grid.appendChild(detail);
        }
      }

      if (insights?.length) {
        const insightCard = document.createElement("div");
        insightCard.className = "analysis-card insight";
        insightCard.innerHTML = `<div class="card-head">Insights aprendidos</div>`;
        const list = document.createElement("ul");
        list.className = "analysis-insights";
        insights.slice(0, 6).forEach((item) => {
          const li = document.createElement("li");
          li.innerHTML = `<strong>${item.titulo}:</strong> ${item.descripcion}`;
          list.appendChild(li);
        });
        insightCard.appendChild(list);
        grid.appendChild(insightCard);
      }

      if (!escenarios.length) {
        const empty = document.createElement("p");
        empty.className = "hint";
        empty.textContent = "No hay escenarios disponibles. Registra sorteos para obtener proyecciones.";
        resultEscenarios.appendChild(empty);
        return;
      }

      escenarios.forEach((esc) => {
        const card = document.createElement("div");
        card.className = "analysis-card scenario";
        const conf = Math.round((esc.confianza || 0) * 100);

        const header = document.createElement("div");
        header.className = "card-head";
        header.textContent = `${esc.nombre || "Escenario"} ‚Äî conf ${conf}%`;
        card.appendChild(header);

        const lista = document.createElement("div");
        lista.className = "analysis-pill-wrap";
        for (const cand of esc.candidatos || []) {
          const pill = document.createElement("div");
          pill.className = "analysis-pill";
          pill.style.borderColor = getColorPolaridad(cand.numero);
          pill.textContent = `${formatNumber(cand.numero)} ${cand.simbolo || getSymbol(cand.numero) || ""}`.trim();
          const etiqueta = cand.etiqueta || (cand.razones?.length ? cand.razones[0] : "");
          if (etiqueta) {
            const chip = document.createElement("span");
            chip.className = "analysis-chip";
            chip.textContent = etiqueta;
            pill.appendChild(chip);
          }
          pill.title = (cand.razones || []).join(" ¬∑ ") || "";
          lista.appendChild(pill);
        }
        card.appendChild(lista);

        if (esc.explicacion) {
          const hint = document.createElement("div");
          hint.className = "analysis-note";
          hint.textContent = esc.explicacion;
          card.appendChild(hint);
        }

        grid.appendChild(card);
      });
    }

    function renderRecomendaciones(
      recomendacion,
      nota,
      predicciones = [],
      perfilMap = new Map(),
      resumenPred = null
    ) {
      if (!resultRecomendacion) return;
      resultRecomendacion.innerHTML = "";
      if (!recomendacion.length) {
        resultRecomendacion.innerHTML = "<p class='hint'>Sin recomendaciones por el momento.</p>";
      } else {
        const card = document.createElement("div");
        card.className = "analysis-card recommendation";

        const header = document.createElement("div");
        header.className = "card-head";
        header.textContent = "Recomendaci√≥n consolidada";
        card.appendChild(header);

        const lista = document.createElement("div");
        lista.className = "analysis-pill-wrap";
        for (const cand of recomendacion) {
          const pill = document.createElement("div");
          pill.className = "analysis-pill";
          pill.style.borderColor = getColorPolaridad(cand.numero);
          pill.textContent = `${formatNumber(cand.numero)} ${cand.simbolo || getSymbol(cand.numero) || ""}`.trim();
          pill.title = (cand.razones || []).join(" ¬∑ ") || "";
          lista.appendChild(pill);
        }
        card.appendChild(lista);

        if (nota) {
          const hint = document.createElement("div");
          hint.className = "analysis-note";
          hint.textContent = nota;
          card.appendChild(hint);
        }

        resultRecomendacion.appendChild(card);
      }

      if (resumenPred && resumenPred.total) {
        const perf = document.createElement("div");
        perf.className = "analysis-card performance";
        const overall = resumenPred.precision !== null
          ? `${Math.round(resumenPred.precision * 100)}% acierto (${resumenPred.aciertos}/${resumenPred.total})`
          : `${resumenPred.aciertos}/${resumenPred.total} aciertos`;
        perf.innerHTML = `
          <div class="card-head">Precisi√≥n hist√≥rica</div>
          <div class="analysis-note">${overall}</div>
        `;
        if (resumenPred.turnos?.length) {
          const table = document.createElement("div");
          table.className = "analysis-performance-turnos";
          resumenPred.turnos.forEach((turno) => {
            const row = document.createElement("div");
            row.className = "analysis-performance-row";
            const label = document.createElement("span");
            label.textContent = turno.turno;
            const value = document.createElement("span");
            const prec = turno.precision !== null ? `${Math.round(turno.precision * 100)}%` : "‚Äî";
            value.textContent = `${prec} (${turno.aciertos}/${turno.total})`;
            row.appendChild(label);
            row.appendChild(value);
            table.appendChild(row);
          });
          perf.appendChild(table);
        }
        resultRecomendacion.appendChild(perf);
      }
    }

    const toggleTech = document.getElementById("toggle-tech");
    const memOut = document.getElementById("mem-out");
    toggleTech?.addEventListener("click", async () => {
      if (!memOut) return;
      memOut.classList.toggle("hidden");
      if (!memOut.classList.contains("hidden")) {
        const draws = await DB.listDraws({ excludeTest: false });
        memOut.textContent = JSON.stringify(draws.slice(-50), null, 2);
      }
    });

    const btnTransform = document.getElementById("t-ver");
    btnTransform?.addEventListener("click", () => {
      const raw = document.getElementById("t-numero")?.value.trim() ?? "";
      const numero = parseInt(raw, 10);
      mostrarTransformaciones(numero);
    });

    const btnGeometria = document.getElementById("g-generar");
    btnGeometria?.addEventListener("click", () => {
      const fecha = document.getElementById("g-fecha")?.value;
      if (!fecha) {
        showToast("Selecciona una fecha para generar la cruceta/tri√°ngulo.", { variant: "warning" });
        return;
      }
      const cruceta = generarCruceta(fecha);
      renderCruceta(cruceta);
      const niveles = generarTrianguloInvertido(fecha);
      const contTri = document.getElementById("g-tri");
      if (contTri) dibujarTrianguloInvertido(contTri, niveles);
    });

    function renderCruceta(data) {
      const cont = document.getElementById("g-cruceta");
      if (!cont) return;
      cont.innerHTML = `
        <div class="c-row">
          <div class="ball small">${formatNumber(data.norte)}</div>
        </div>
        <div class="c-row">
          <div class="ball small">${formatNumber(data.oeste)}</div>
          <div class="ball small">${formatNumber(data.centro)}</div>
          <div class="ball small">${formatNumber(data.este)}</div>
        </div>
        <div class="c-row">
          <div class="ball small">${formatNumber(data.sur)}</div>
        </div>
      `;
    }

    const btnDup = document.getElementById("btn-list-dup");
    const btnMarkTestDup = document.getElementById("btn-marktest-dup");
    const btnDeleteDup = document.getElementById("btn-delete-dup");
    const dupOut = document.getElementById("dup-out");

    btnDup?.addEventListener("click", refreshDuplicados);

    btnMarkTestDup?.addEventListener("click", async () => {
      const ids = getSelectedDupIds();
      if (!ids.length) {
        showToast("Selecciona al menos un registro duplicado.", { variant: "warning" });
        return;
      }
      try {
        await marcarGrupoComoTest(ids);
        await refreshDuplicados();
        await refreshSlots();
        showToast("Marcados como prueba.", { variant: "success" });
        await rebuildKnowledge();
      } catch (err) {
        console.error("mark dup error", err);
        showToast(`No se pudo marcar como prueba: ${err.message}`, { variant: "danger" });
      }
    });

    btnDeleteDup?.addEventListener("click", async () => {
      const ids = getSelectedDupIds();
      if (!ids.length) {
        showToast("Selecciona registros para eliminar.", { variant: "warning" });
        return;
      }
      const confirmar = await mostrarModal(
        "Eliminar registros",
        "¬øEliminar los registros seleccionados?",
        { okText: "Eliminar", cancelText: "Cancelar", okVariant: "danger" }
      );
      if (!confirmar) return;
      try {
        await borrarIds(ids);
        await refreshDuplicados();
        await refreshSlots();
        showToast("Registros eliminados.", { variant: "success" });
        await rebuildKnowledge();
      } catch (err) {
        console.error("delete dup error", err);
        showToast(`No se pudieron eliminar los registros: ${err.message}`, { variant: "danger" });
      }
    });

    async function refreshDuplicados() {
      if (!dupOut) return;
      dupOut.innerHTML = "<p class='hint'>Buscando duplicados‚Ä¶</p>";
      try {
        const grupos = await revisarDuplicados();
        if (!grupos.length) {
          dupOut.innerHTML = "<p class='hint'>Sin duplicados detectados.</p>";
          return;
        }
        dupOut.innerHTML = "";
        grupos.forEach((group, idx) => {
          const box = document.createElement("div");
          box.className = "card";
          box.style.width = "100%";
          box.style.marginBottom = "10px";
          const head = document.createElement("div");
          head.className = "card-head";
          head.textContent = `Grupo #${idx + 1}`;
          const list = document.createElement("div");
          list.className = "card-body";
          list.style.flexDirection = "column";
          list.style.alignItems = "flex-start";
          group.forEach((reg) => {
            const label = document.createElement("label");
            label.className = "symbol-tag";
            label.innerHTML = `
              <input type="checkbox" value="${reg.id}" />
              <span>${formatNumber(reg.numero)}</span>
              <span>${reg.fecha} ${reg.horario} ${reg.pais}</span>
              <span class="hint">${reg.isTest ? "test" : "real"}</span>
            `;
            list.appendChild(label);
          });
          box.appendChild(head);
          box.appendChild(list);
          dupOut.appendChild(box);
        });
      } catch (err) {
        console.error("dup error", err);
        dupOut.innerHTML = `<p class='hint'>No se pudieron obtener duplicados: ${err.message}</p>`;
      }
    }

    function getSelectedDupIds() {
      if (!dupOut) return [];
      return Array.from(dupOut.querySelectorAll("input[type='checkbox']:checked"))
        .map((el) => parseInt(el.value, 10))
        .filter((n) => !Number.isNaN(n));
    }

    // ‚úÖ Navegaci√≥n lateral
    const sidebar = document.getElementById("sidebar");
    const toggleBtn = document.getElementById("btn-toggle-sidebar");

    const closeSidebarMobile = () => {
      if (!sidebar) return;
      sidebar.classList.remove("show-mobile");
      if (toggleBtn) {
        toggleBtn.classList.remove("sidebar-open");
        toggleBtn.setAttribute("aria-expanded", "false");
      }
    };

    // ‚úÖ Cambio de vistas
    const views = {
      day: "view-day",
      hypo: "view-hypo",
      analysis: "view-analysis",
      geometry: "view-geometry",
      memory: "view-memory",
      guide: "view-guide",
      config: "view-config",
      maint: "view-maint",
      modes: "view-modes",
    };
    document.querySelectorAll(".sidebar button").forEach((b) => {
      b.onclick = () => {
        document.querySelectorAll(".view").forEach((v) => v.classList.add("hidden"));
        const id = views[b.dataset.view];
        const el = document.getElementById(id);
        if (!el) return console.warn("Vista no encontrada:", id);
        el.classList.remove("hidden");
        if (id === "view-guide") mostrarGuia();
        if (id === "view-hypo") refreshHypotesis();
        if (id === "view-maint") refreshDuplicados();
        if (id === "view-modes") refreshModesPanel();
        closeSidebarMobile();
      };
    });

    // ‚úÖ Toggle de sidebar m√≥vil
    if (toggleBtn && sidebar) {
      toggleBtn.setAttribute("aria-controls", "sidebar");
      toggleBtn.setAttribute("aria-expanded", "false");

      const openSidebarMobile = () => {
        sidebar.classList.add("show-mobile");
        toggleBtn.classList.add("sidebar-open");
        toggleBtn.setAttribute("aria-expanded", "true");
      };

      toggleBtn.addEventListener("click", (event) => {
        event.stopPropagation();
        const shouldOpen = !sidebar.classList.contains("show-mobile");
        if (shouldOpen) {
          openSidebarMobile();
        } else {
          closeSidebarMobile();
        }
      });

      const handleOutside = (event) => {
        if (!sidebar.classList.contains("show-mobile")) return;
        if (sidebar.contains(event.target)) return;
        if (toggleBtn.contains(event.target)) return;
        closeSidebarMobile();
      };

      const outsideEvents = window.PointerEvent
        ? ["pointerdown"]
        : ["mousedown", "touchstart"];
      outsideEvents.forEach((evt) => {
        document.addEventListener(evt, handleOutside);
      });
      document.addEventListener("click", handleOutside);
      document.addEventListener("focusin", handleOutside);
      window.addEventListener("keydown", (event) => {
        if (event.key === "Escape") closeSidebarMobile();
      });
      sidebar.addEventListener("focusout", (event) => {
        if (!sidebar.contains(event.relatedTarget)) closeSidebarMobile();
      });
      window.addEventListener("resize", () => {
        if (window.innerWidth > 768) closeSidebarMobile();
      });
    }

    await refreshHypotesis();
    await refreshSlots();
    await rebuildKnowledge();
    await refreshModesPanel();

    // === SISTEMA DE MODALES UNIFICADO ===
    function mostrarModal(titulo, mensaje, opciones = {}) {
      return new Promise((resolve) => {
        const modal = document.getElementById("sys-modal");
        const tEl = document.getElementById("modal-title");
        const mEl = document.getElementById("modal-msg");
        const okBtn = document.getElementById("modal-ok");
        const cancelBtn = document.getElementById("modal-cancel");

        if (!modal) return resolve(false);

        // Personalizar texto
        tEl.textContent = titulo || "Confirmar acci√≥n";
        mEl.textContent = mensaje || "¬øDeseas continuar?";
        okBtn.textContent = opciones.okText || "Aceptar";
        cancelBtn.textContent = opciones.cancelText || "Cancelar";
        okBtn.className = "";
        cancelBtn.className = "";
        if (opciones.okVariant === "danger") okBtn.classList.add("btn-danger");
        else if (opciones.okVariant === "secondary") okBtn.classList.add("btn-secondary");
        cancelBtn.classList.add("btn-ghost");

        // Mostrar modal
        modal.classList.remove("hidden");

        // Manejo de cierre
        const cerrar = (res) => {
          modal.classList.add("hidden");
          okBtn.onclick = cancelBtn.onclick = null;
          resolve(res);
        };

        okBtn.onclick = () => cerrar(true);
        cancelBtn.onclick = () => cerrar(false);
      });
    }

    // === Notificaci√≥n breve (sin botones, tipo toast simple) ===
    function mostrarAviso(mensaje, opciones = {}) {
      showToast(mensaje, opciones);
    }


    // === NUEVA FUNCI√ìN COMPLETA: Mostrar/Ocultar y eliminar sorteos individualmente ===
    // === Mostrar/Ocultar y eliminar sorteos individualmente (versi√≥n robusta) ===
    const btnListAll = document.getElementById("btn-list-all");
    const allOut = document.getElementById("all-out");

    async function renderAllTable() {
      if (!allOut) return;
      allOut.innerHTML = "<p class='hint'>Cargando todos los sorteos‚Ä¶</p>";

      const draws = await DB.listDraws({ excludeTest: false });
      if (!draws.length) {
        allOut.innerHTML = "<p class='hint'>No hay sorteos registrados a√∫n.</p>";
        return;
      }

      const table = document.createElement("table");
      table.className = "table-history";
      table.innerHTML = `
    <thead>
      <tr>
        <th>#</th><th>Fecha</th><th>Pa√≠s</th><th>Horario</th>
        <th>N√∫mero</th><th>S√≠mbolo</th><th>Tipo</th><th>Acciones</th>
      </tr>
    </thead>
    <tbody></tbody>
  `;
      const tbody = table.querySelector("tbody");

      draws.forEach((d, i) => {
        const tr = document.createElement("tr");
        tr.innerHTML = `
      <td>${i + 1}</td>
      <td>${d.fecha}</td>
      <td>${d.pais}</td>
      <td>${d.horario}</td>
      <td class="num">${String(d.numero).padStart(2, "0")}</td>
      <td class="sym">${GUIA[String(d.numero).padStart(2, "0")]?.simbolo || "‚Äî"}</td>
      <td class="${d.isTest ? "test" : ""}">${d.isTest ? "prueba" : "real"}</td>
      <td>
        <button type="button" class="btn-del" data-id="${d.id}">üóë</button>
      </td>
    `;
        tbody.appendChild(tr);
      });

      allOut.innerHTML = "";
      allOut.appendChild(table);
    }

    btnListAll?.addEventListener("click", async () => {
      if (!allOut) return;

      // Toggle: ocultar si est√° visible
      if (allOut.dataset.visible === "true") {
        allOut.innerHTML = "";
        allOut.dataset.visible = "false";
        btnListAll.textContent = "Ver todos";
        return;
      }

      // Mostrar
      await renderAllTable();
      allOut.dataset.visible = "true";
      btnListAll.textContent = "Ocultar tabla";
    });

    // üîí Delegaci√≥n de eventos sobre el contenedor (funciona aunque se regenere la tabla)
    allOut?.addEventListener("click", async (ev) => {
      const delBtn = ev.target.closest?.(".btn-del");
      if (!delBtn) return;

      const id = Number(delBtn.dataset.id);
      if (!Number.isFinite(id)) return;

      // Guardar referencias ANTES del modal
      const fila = delBtn.closest("tr");

      const confirmar = await mostrarModal(
        "Eliminar sorteo",
        "¬øSeguro que deseas eliminar este sorteo permanentemente?",
        { okText: "Eliminar", cancelText: "Cancelar", okVariant: "danger" }
      );
      if (!confirmar) return;

      try {
        await DB.deleteDrawById(id);
        if (fila) fila.remove();
        // Si queda la tabla vac√≠a, no forzamos recarga; el usuario puede pulsar "Ocultar" y "Ver todos".
        mostrarAviso("Sorteo eliminado correctamente.", { variant: "success" });
      } catch (err) {
        console.error("delete draw error", err);
        mostrarAviso(`Error al eliminar: ${err.message}`, { variant: "danger" });
      }
    });



    // === Bot√≥n para reiniciar completamente la base ===
    const btnNuke = document.getElementById("btn-nuke");
    btnNuke?.addEventListener("click", async () => {
      const confirmar = await mostrarModal(
        "Reiniciar base de datos",
        "‚ö†Ô∏è ¬øSeguro que deseas borrar TODOS los datos del sistema?",
        { okText: "Borrar todo", cancelText: "Cancelar", okVariant: "danger" }
      );
      if (!confirmar) return;
      try {
        await DB.nuke();
        showToast("Base de datos vaciada correctamente. Reinicia la p√°gina para comenzar desde cero.", {
          variant: "success",
          timeout: 6000,
        });
        await rebuildKnowledge();
      } catch (err) {
        console.error("nuke error", err);
        showToast(`Error al intentar limpiar la base: ${err.message}`, { variant: "danger" });
      }
    });

  </script>

  <script type="module">
    import { DB } from "./storage.js";

    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
       MODAL DE AVISO CON ANIMACI√ìN
    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    function modalAvisoAprendizaje(titulo, mensaje) {
      document.querySelectorAll(".custom-modal-aviso, .modal-overlay-aviso").forEach(e => e.remove());
      const overlay = document.createElement("div");
      overlay.className = "modal-overlay-aviso";
      const modal = document.createElement("div");
      modal.className = "custom-modal-aviso";
      modal.innerHTML = `
    <h3>${titulo}</h3>
    <p>${mensaje}</p>
    <button id="okAviso" class="btn-ok-aviso">Aceptar</button>
  `;
      overlay.appendChild(modal);
      document.body.appendChild(overlay);
      requestAnimationFrame(() => {
        overlay.style.opacity = "1";
        modal.style.transform = "translateY(0)";
      });
      modal.querySelector("#okAviso").onclick = () => {
        overlay.classList.add("fade-out");
        setTimeout(() => overlay.remove(), 250);
      };
    }

    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
       VALIDACI√ìN ANTES DE APRENDIZAJE
    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    async function verificarAntesDeAprender(datosDia) {
      if (!datosDia || !Array.isArray(datosDia) || !datosDia.length) return true;
      const fechaHoy = datosDia[0]?.fecha;
      const existentes = await DB.listDraws({ excludeTest: true });
      const yaExisten = existentes.some(d => d.fecha === fechaHoy);
      if (yaExisten) {
        modalAvisoAprendizaje(
          "Datos ya registrados",
          `Los resultados del d√≠a ${fechaHoy} ya fueron ingresados anteriormente.`
        );
        return false;
      }
      return true;
    }

    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
       ESTILOS DEL MODAL
    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    if (!document.getElementById("estilo-aviso-aprendizaje")) {
      const estiloAviso = document.createElement("style");
      estiloAviso.id = "estilo-aviso-aprendizaje";
      estiloAviso.textContent = `
  .modal-overlay-aviso {
    position: fixed; inset: 0;
    background: rgba(0,0,0,0.45);
    display: flex; align-items: center; justify-content: center;
    opacity: 0;
    transition: opacity .25s ease;
    z-index: 5000;
  }
  .custom-modal-aviso {
    background: #1b1b1b;
    color: #f3f3f3;
    border-radius: 12px;
    padding: 22px 28px;
    max-width: 380px;
    text-align: center;
    box-shadow: 0 0 15px rgba(0,0,0,0.5);
    transform: translateY(-15px);
    transition: transform .25s ease;
  }
  .custom-modal-aviso h3 {
    color: #f5d36b;
    margin-bottom: 10px;
  }
  .btn-ok-aviso {
    background: #f5d36b;
    color: #1b1b1b;
    border: none;
    padding: 8px 18px;
    border-radius: 6px;
    font-weight: 600;
    cursor: pointer;
    transition: background .2s;
  }
  .btn-ok-aviso:hover { background: #ffe27a; }
  .fade-out { opacity: 0 !important; transition: opacity .25s ease; }
  `;
      document.head.appendChild(estiloAviso);
    }

    /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
       CONEXI√ìN CON EL BOT√ìN PRINCIPAL
    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    btnAprender = document.getElementById("btn-aprender-dia");
    if (btnAprender) {
      btnAprender.addEventListener("click", async (e) => {
        if (window.datosDelDia) {
          const continuar = await verificarAntesDeAprender(window.datosDelDia);
          if (!continuar) e.preventDefault();
        }
      });
    }
  </script>

  <!-- === MODAL DEL SISTEMA === -->
  <div id="sys-modal" class="modal hidden">
    <div class="modal-content">
      <div class="modal-head">
        <h3 id="modal-title">Confirmar acci√≥n</h3>
      </div>
      <div class="modal-body">
        <p id="modal-msg"></p>
      </div>
      <div class="modal-foot">
        <button id="modal-cancel">Cancelar</button>
        <button id="modal-ok">Aceptar</button>
      </div>
    </div>
  </div>

</body>

</html>
