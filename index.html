<!DOCTYPE html>
<html lang="es" class="auth-locked">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>La Diaria ‚Äî v3.2 Responsive</title>
  <link rel="stylesheet" href="./style.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"
    integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
  <style>
    html.auth-locked,
    html.auth-locked body {
      display: none !important;
      visibility: hidden;
    }
  </style>
  <script type="module">
    import { requireAuthOrRedirect } from "./src/auth.js";
    const user = await requireAuthOrRedirect("./login.html");
    if (!user) {
      throw new Error("Redirigiendo a login por sesi√≥n inv√°lida.");
    }
    document.documentElement.classList.remove("auth-locked");
    window.__LD_AUTH_UNLOCKED__ = true;
  </script>

</head>

<body class="layout">
  <aside class="sidebar expanded" id="sidebar">
    <div class="brand">LD v3.2</div>
    <button data-view="login"><i>üîê Acceso</i></button>
    <button data-view="day"><span class="sidebar-icon fa-solid fa-gauge"></span><i>Panel del d√≠a</i></button>
    <button data-view="hypo"><span class="sidebar-icon fa-solid fa-puzzle-piece"></span><i>Hip√≥tesis</i></button>
    <button data-view="analysis"><span
        class="sidebar-icon fa-solid fa-diagram-project"></span><i>Escenarios</i></button>
    <button data-view="transform"><span class="sidebar-icon fa-solid fa-wand-magic-sparkles"></span><i>Transformaciones</i></button>
    <button data-view="strategies"><span class="sidebar-icon fa-solid fa-brain"></span><i>Estrategias</i></button>
    <button data-view="weekly"><span class="sidebar-icon fa-solid fa-calendar-week"></span><i>Secuencias</i></button>
    <button data-view="pega3"><span class="sidebar-icon fa-solid fa-dice"></span><i>Pega3</i></button>
    <button data-view="notebook"><span class="sidebar-icon fa-solid fa-bookmark"></span><i>Cuaderno</i></button>
    <button data-view="geometry"><span
        class="sidebar-icon fa-solid fa-draw-polygon"></span><i>Cruceta/Tri√°ngulo</i></button>
    <button data-view="memory"><span class="sidebar-icon fa-solid fa-brain"></span><i>Memoria</i></button>
    <button data-view="guide"><span class="sidebar-icon fa-solid fa-book"></span><i>Gu√≠a de los Sue√±os</i></button>
    <button data-view="config"><span class="sidebar-icon fa-solid fa-gear"></span><i>Configuraci√≥n</i></button>
    <button data-view="maint"><span
        class="sidebar-icon fa-solid fa-screwdriver-wrench"></span><i>Mantenimiento</i></button>
    <button data-view="modes"><span class="sidebar-icon fa-solid fa-gamepad"></span><i>Modos de juego</i></button>
    <button data-view="abono"><span class="sidebar-icon fa-solid fa-clover"></span><i>Abono del d√≠a</i></button>
    <button data-view="gatillo"><span class="sidebar-icon fa-solid fa-link"></span><i>Secuencia gatillo</i></button>
  </aside>

  <main class="content">
    <div class="sticky-header">

      <button id="btn-toggle-sidebar" class="menu-btn">‚ò∞</button>
      <div id="countdown-banner" class="countdown-banner">
        <div class="countdown-label" data-countdown-label>Tiempo para el pr√≥ximo sorteo</div>
        <div class="countdown-target" data-countdown-target>‚Äî</div>
        <div class="countdown-timer" data-countdown-timer>--:--:--</div>
      </div>
      <button id="btn-logout" class="btn-outline" type="button">Cerrar sesi√≥n</button>
    </div>

    <!-- PANEL DEL D√çA -->
    <section id="view-day" class="view">
      <h2>Panel del d√≠a</h2>
      <div class="row">
        <label class="day-date-field">
          <span class="day-date-head">
            <span class="label-title">Fecha</span>
            <span id="day-fecha-dow" class="day-fecha-dow">‚Äî</span>
          </span>
          <input type="date" id="day-fecha" />
        </label>
        <label>Pa√≠s
          <select id="day-pais">
            <option>HN</option>
            <option>NI</option>
            <option>SV</option>
          </select>
        </label>
      </div>

      <div class="triple">
        <div class="slot">
          <div class="slot-header">
            <div class="slot-title">11 AM</div>
            <label class="slot-flag">
              <input type="checkbox" id="test-11" /> Modo prueba
            </label>
          </div>
          <div class="ball-row">
            <div class="ball" id="b-11">--</div>
            <div class="sym" id="s-11"></div>
          </div>
          <div class="row slot-controls">
            <input id="n-11" placeholder="00-99" />
          </div>
          <button class="ghost" data-hypo="11AM">Agregar hip√≥tesis para 11 AM</button>
        </div>

        <div class="slot">
          <div class="slot-header">
            <div class="slot-title">3 PM</div>
            <label class="slot-flag">
              <input type="checkbox" id="test-3" /> Modo prueba
            </label>
          </div>
          <div class="ball-row">
            <div class="ball" id="b-3">--</div>
            <div class="sym" id="s-3"></div>
          </div>
          <div class="row slot-controls">
            <input id="n-3" placeholder="00-99" />
          </div>
          <button class="ghost" data-hypo="3PM">Agregar hip√≥tesis para 3 PM</button>
        </div>

        <div class="slot">
          <div class="slot-header">
            <div class="slot-title">9 PM</div>
            <label class="slot-flag">
              <input type="checkbox" id="test-9" /> Modo prueba
            </label>
          </div>
          <div class="ball-row">
            <div class="ball" id="b-9">--</div>
            <div class="sym" id="s-9"></div>
          </div>
          <div class="row slot-controls">
            <input id="n-9" placeholder="00-99" />
          </div>
          <button class="ghost" data-hypo="9PM">Agregar hip√≥tesis para 9 PM</button>
        </div>
      </div>

      <div class="day-actions">
        <button id="save-day" class="btn-primary">Guardar y registrar d√≠a</button>
      </div>
      <p class="hint day-hint">
        Confirma/Refuta hip√≥tesis pendientes seg√∫n los resultados v√°lidos de la fecha seleccionada.
      </p>
      <div class="day-dashboard">
        <article class="day-card day-card--wide" id="history-panel">
          <div class="day-card__head">
            <div>
              <h3>Historial de sorteos</h3>
              <p>Consulta resultados por fecha, horario y pa√≠s. Los sorteos del d√≠a se destacan autom√°ticamente.</p>
            </div>
            <div class="day-card__actions">
              <button id="history-refresh" class="btn-outline">Actualizar</button>
              <button id="history-clear" class="btn-ghost">Limpiar filtros</button>
            </div>
          </div>
          <div class="day-card__controls day-card__controls--scroll">
            <label>
              Fecha
              <input type="date" id="history-date" />
            </label>
            <label>
              Horario
              <select id="history-hour">
                <option value="">Todos</option>
                <option value="11AM">11 AM</option>
                <option value="3PM">3 PM</option>
                <option value="9PM">9 PM</option>
              </select>
            </label>
            <label>
              Pa√≠s
              <select id="history-country">
                <option value="">Todos</option>
                <option value="HN">HN</option>
                <option value="NI">NI</option>
                <option value="SV">SV</option>
              </select>
            </label>
            <label>
              Mostrar
              <select id="history-limit">
                <option value="9">√öltimos 9</option>
                <option value="15">√öltimos 15</option>
                <option value="30">√öltimos 30</option>
              </select>
            </label>
            <button id="history-search" class="btn-primary">Buscar</button>
          </div>
          <div class="day-card__body">
            <div id="history-summary" class="panel-meta">Selecciona una fecha para revisar sus sorteos.</div>
            <div id="history-table" class="table-wrap table-wrap--history"></div>
            <div id="history-coverage" class="history-coverage">
              <p class="hint">Ingresa sorteos hist√≥ricos para ver la √∫ltima fecha registrada por a√±o.</p>
            </div>
          </div>
        </article>

        <article class="day-card" id="tracking-panel">
          <div class="day-card__head">
            <div>
              <h3>Seguimiento</h3>
              <p>Fija los tres sorteos de una fecha espec√≠fica y mantenlos visibles.</p>
            </div>
            <div class="day-card__actions">
              <button id="tracking-pin" class="btn-outline" disabled>Seguir este d√≠a</button>
            </div>
          </div>
          <div class="day-card__controls">
            <label>
              Fecha
              <input type="date" id="tracking-date" />
            </label>
            <label>
              Pa√≠s
              <select id="tracking-country">
                <option value="HN">HN</option>
                <option value="NI">NI</option>
                <option value="SV">SV</option>
              </select>
            </label>
            <button id="tracking-view" class="btn-primary">Ver sorteos</button>
          </div>
          <div id="tracking-grid" class="tracking-grid">
            <p class="hint">Selecciona fecha y pa√≠s para comenzar el seguimiento.</p>
          </div>
        </article>

        <article class="day-card" id="patterns-panel">
          <div class="day-card__head">
            <div>
              <h3>Patrones</h3>
              <p>Resumen de repeticiones y comportamientos que se mantienen con los a√±os.</p>
            </div>
            <div class="day-card__actions">
              <button id="patterns-refresh" class="btn-outline">Actualizar patrones</button>
            </div>
          </div>
          <div id="patterns-summary" class="pattern-summary panel-meta">
            <p class="hint">Cargando patrones‚Ä¶</p>
          </div>
          <div id="patterns-hallazgos" class="pattern-hallazgos"></div>
          <div id="patterns-history" class="pattern-history"></div>
        </article>

        <article class="day-card day-card--wide" id="ranking-panel">
          <div class="day-card__head">
            <div>
              <h3>Ranking de n√∫meros</h3>
              <p>Explora qu√© n√∫meros se repiten por a√±o y cu√°les casi no han salido.</p>
            </div>
          </div>
          <div class="day-card__controls day-card__controls--scroll ranking-controls">
            <label>
              A√±o
              <select id="ranking-year"></select>
            </label>
            <label>
              Buscar n√∫mero
              <input id="ranking-search" placeholder="00-99" maxlength="2" />
            </label>
            <button id="ranking-search-btn" class="btn-primary">Buscar</button>
            <button id="ranking-clear-btn" class="btn-ghost">Limpiar filtros</button>
          </div>
          <div class="ranking-tabs" role="tablist">
            <button type="button" data-ranking-tab="hot" class="active">Calientes</button>
            <button type="button" data-ranking-tab="frequent">Frecuentes</button>
            <button type="button" data-ranking-tab="cold">Menos frecuentes</button>
            <button type="button" data-ranking-tab="rare">Los que menos salen</button>
          </div>
          <div id="ranking-summary" class="panel-meta">Selecciona un a√±o para ver su ranking.</div>
          <div id="ranking-table" class="table-wrap table-wrap--ranking"></div>
          <div id="ranking-insight" class="panel-meta ranking-insight muted"></div>
        </article>
      </div>
    </section>

    <!-- PEGA3 -->
    <section id="view-pega3" class="view hidden">
      <h2>Pega3 ¬∑ m√≥dulo independiente</h2>
      <p class="hint">
        Este m√≥dulo opera con su propio motor estad√≠stico y base hist√≥rica para descubrir patrones reales del juego Pega3.
        Los datos y sesgos mostrados aqu√≠ no afectan el sistema de La Diaria.
      </p>
      <div class="pega3-grid">
        <article class="card pega3-card pega3-card--form">
          <div class="card-head">Registrar sorteo Pega3</div>
          <div class="card-body pega3-form">
            <div class="pega3-context">
              <label class="pega3-context__field">
                <span class="pega3-context__label">Fecha</span>
                <input type="date" id="pega3-fecha" />
              </label>
              <label class="pega3-context__field">
                <span class="pega3-context__label">Turno</span>
                <select id="pega3-turno">
                  <option value="11AM">11 AM</option>
                  <option value="3PM">3 PM</option>
                  <option value="9PM">9 PM</option>
                </select>
              </label>
              <label class="pega3-context__field">
                <span class="pega3-context__label">Pa√≠s</span>
                <select id="pega3-pais">
                  <option value="HN">Honduras</option>
                  <option value="NI">Nicaragua</option>
                  <option value="SV">El Salvador</option>
                </select>
              </label>
            </div>
            <div class="pega3-context-actions">
              <button type="button" id="pega3-context-sync" class="btn-ghost small">Detectar fecha y turno actuales</button>
            </div>
            <p class="hint small">Usa el bot√≥n para autocompletar o ajusta manualmente para cargar sorteos hist√≥ricos. Cada vez que guardes un sorteo, el turno avanzar√° autom√°ticamente (11AM ‚Üí 3PM ‚Üí 9PM).</p>
            <div id="pega3-form-status" class="pega3-form-status hint small" aria-live="polite"></div>
            <div class="pega3-slot-grid">
              <div class="slot pega3-slot">
                <div class="slot-header">
                  <div>
                    <div class="slot-title">Primer par</div>
                    <p class="pega3-slot-hint">Posici√≥n inicial</p>
                  </div>
                </div>
                <div class="slot-controls">
                  <input type="tel" inputmode="numeric" pattern="[0-9]*" maxlength="2" id="pega3-par-1" placeholder="00" class="pega3-slot-input" />
                </div>
              </div>
              <div class="slot pega3-slot">
                <div class="slot-header">
                  <div>
                    <div class="slot-title">Segundo par</div>
                    <p class="pega3-slot-hint">Posici√≥n central</p>
                  </div>
                </div>
                <div class="slot-controls">
                  <input type="tel" inputmode="numeric" pattern="[0-9]*" maxlength="2" id="pega3-par-2" placeholder="00" class="pega3-slot-input" />
                </div>
              </div>
              <div class="slot pega3-slot">
                <div class="slot-header">
                  <div>
                    <div class="slot-title">Tercer par</div>
                    <p class="pega3-slot-hint">Posici√≥n final</p>
                  </div>
                </div>
                <div class="slot-controls">
                  <input type="tel" inputmode="numeric" pattern="[0-9]*" maxlength="2" id="pega3-par-3" placeholder="00" class="pega3-slot-input" />
                </div>
              </div>
            </div>
            <div class="pega3-generator" aria-live="polite">
              <div class="pega3-generator__head">
                <div>
                  <h4>Tr√≠o aleatorio desde conversiones</h4>
                  <p class="hint small">Usa tus tres pares como base y deja que el sistema combine conversiones simples, ajustes y compuestas para proponerte un tr√≠o diferente.</p>
                </div>
                <button type="button" id="pega3-btn-generar-trio" class="btn-outline small">Obtener tr√≠o</button>
              </div>
              <div id="pega3-generator-output" class="pega3-generator__output">
                <p class="hint small">Ingresa los tres pares para desbloquear una propuesta.</p>
              </div>
            </div>
            <button id="pega3-btn-registrar" class="btn-primary">Guardar sorteo</button>
            <button id="pega3-btn-cargar" class="btn-outline">Actualizar historial</button>
            <p class="hint small">La tabla Pega3 se mantiene separada; puedes registrar hist√≥ricos sin afectar La Diaria.</p>
          </div>
        </article>
        </article>
        <article class="card pega3-card pega3-card--insights">
          <div class="card-head">Historial Pega3</div>
          <div id="pega3-historial" class="pega3-historial">
            <p class="hint">Registra sorteos para comenzar el an√°lisis.</p>
          </div>
          <div class="pega3-analisis">
            <div class="pega3-analisis__head">
              <h4>Motor anal√≠tico Pega3</h4>
              <button id="pega3-btn-analizar" class="btn-outline small">Analizar patrones</button>
            </div>
            <div class="pega3-analisis__grid">
              <section>
                <h5>Resumen</h5>
                <div id="pega3-resumen" class="pega3-panel">
                  <p class="hint">Cuando existan datos suficientes, aqu√≠ ver√°s frecuencias, sesgos y co-ocurrencias descubiertas.</p>
                </div>
              </section>
              <section>
                <h5>Sesgos detectados</h5>
                <div id="pega3-sesgos" class="pega3-panel"></div>
              </section>
              <section>
                <h5>Selecci√≥n recomendada</h5>
                <div id="pega3-seleccion" class="pega3-panel"></div>
              </section>
            </div>
          </div>
        </article>
      </div>
    </section>

    <!-- HIP√ìTESIS -->
    <section id="view-hypo" class="view hidden">
      <h2>Hip√≥tesis manuales</h2>
      <div class="row">
        <label>Fecha <input type="date" id="h-fecha" /></label>
        <label>Turno
          <select id="h-turno">
            <option>11AM</option>
            <option>3PM</option>
            <option>9PM</option>
          </select>
        </label>
        <label>N√∫mero <input id="h-numero" placeholder="00-99" /></label>
      </div>
      <div class="row">
        <label style="flex:1">
          Texto / Raz√≥n
          <textarea id="h-texto" rows="3" placeholder="Describe tu hip√≥tesis..."></textarea>
        </label>
      </div>
      <!-- üîπ NUEVO BLOQUE: sorteos del d√≠a seleccionado -->
      <div id="h-draws-day" class="card-body"
        style="margin:10px 0; border:1px solid #444; border-radius:10px; padding:10px;">
        <p class="hint">Selecciona una fecha para ver los sorteos de ese d√≠a.</p>
      </div>
      <!-- üîπ FIN NUEVO BLOQUE -->
      <button id="h-guardar">Guardar hip√≥tesis</button>

      <div class="card reminder-card">
        <div class="card-head">Recordatorios de hip√≥tesis</div>
        <div class="reminder-form">
          <input id="hr-numero" placeholder="00-99" maxlength="2" />
          <input id="hr-nota" placeholder="Nota opcional" />
          <button id="hr-guardar" class="btn-outline">Guardar recordatorio</button>
        </div>
        <div id="hr-list" class="reminder-list"></div>
      </div>

      <h3>Historial</h3>
      <div id="h-list" class="cards hypo-list"></div>
    </section>



    <!-- ESCENARIOS -->
    <section id="view-analysis" class="view hidden">
      <h2>Escenarios y recomendaci√≥n</h2>
      <div class="analysis-controls">
        <button id="btn-analizar">Analizar</button>
        <label class="analysis-control">
          <span>D√≠a de sesgo</span>
          <select id="analysis-dow">
            <option value="">Seg√∫n fecha objetivo</option>
            <option value="0">Domingo</option>
            <option value="1">Lunes</option>
            <option value="2">Martes</option>
            <option value="3">Mi√©rcoles</option>
            <option value="4">Jueves</option>
            <option value="5">Viernes</option>
            <option value="6">S√°bado</option>
          </select>
        </label>
      </div>
      <p class="hint">
        La <b>confianza (conf)</b> es una ponderaci√≥n heur√≠stica (0‚Äì100%).
      </p>
      <div class="cards" id="result-recomendacion"></div>
      <div class="cards" id="result-plan"></div>
      <div class="cards" id="result-day-bias"></div>
      <div class="cards" id="result-escenarios"></div>
    </section>

    <!-- TRANSFORMACIONES -->
    <section id="view-transform" class="view hidden">
      <h2>Transformaciones visuales</h2>
      <p class="hint">
        Explora el n√∫mero base, sus inversiones y conversiones simples/compuestas con los s√≠mbolos de la gu√≠a.
        √ötil para detectar radios alrededor de un n√∫mero favorito.
      </p>
      <div id="transform-panel" class="card">
        <div class="card-head">üîÑ Transformaciones Visuales</div>
        <div class="transform-controls">
          <label>
            N√∫mero base
            <input id="t-numero" placeholder="Ej. 25" maxlength="2" inputmode="numeric" />
          </label>
          <button id="t-ver" class="btn-primary">Ver transformaciones</button>
        </div>
        <div id="t-output"></div>
      </div>
    </section>

    <!-- GEOMETR√çA -->
    <section id="view-geometry" class="view hidden">
      <h2>Cruceta / Tri√°ngulo (visual)</h2>
      <div class="row geom-controls">
        <label>Fecha <input type="date" id="g-fecha" /></label>
        <label>Pa√≠s
          <select id="g-pais">
            <option value="HN">HN</option>
            <option value="NI">NI</option>
            <option value="SV">SV</option>
          </select>
        </label>
        <button id="g-generar">Generar</button>
      </div>
      <div class="geom-wrap">
        <div class="geom-card geom-card--wide">
          <h3>Cruceta</h3>
          <div id="g-cruceta" class="cruceta cruceta--principal"></div>
        </div>
        <div class="geom-card geom-card--wide">
          <h3>Tri√°ngulo invertido</h3>
          <div id="g-tri" class="tri"></div>
        </div>
      </div>
      <div class="geom-wrap geom-wrap--full">
        <div class="geom-card geom-card--full">
          <h3>Cruceta 11 AM + 3 PM</h3>
          <p class="geom-note">Combina los sorteos reales para proyectar candidatos del turno de las 9 PM.</p>
          <div id="g-turnos" class="cruceta cruceta--turnos"></div>
          <div id="g-turnos-cands" class="geom-candidates"></div>
        </div>
      </div>
    </section>

    <!-- ESTRATEGIAS -->
    <section id="view-strategies" class="view hidden">
      <h2>Estrategias aritm√©ticas</h2>
      <p class="hint">
        Detecta cu√°ndo La Diaria reutiliza sumas o restas entre turnos para lanzar el siguiente n√∫mero.
        Observa qu√© horarios participan y en qu√© fechas se aplic√≥ la misma l√≥gica.
      </p>
      <article class="card december-card" id="december-card">
        <div class="december-card__head">
          <div>
            <h3>Estrategia especial de diciembre</h3>
            <p class="hint">
              Seguimiento n√∫mero por n√∫mero del mes m√°s vol√°til. Identifica cu√°ndo reaparecen y prep√°rate antes de que la l√≠nea se active.
            </p>
          </div>
          <div class="december-card__actions">
            <button type="button" id="december-refresh" class="btn-outline">Actualizar</button>
          </div>
        </div>
        <div class="december-controls">
          <label>
            A√±o de referencia
            <select id="december-year"></select>
          </label>
          <label>
            Buscar n√∫mero
            <div class="december-search">
              <input id="december-search" placeholder="00-99" maxlength="2" />
              <button type="button" id="december-search-btn" class="btn-primary">Ir</button>
            </div>
          </label>
          <button type="button" id="december-clear" class="btn-ghost">Limpiar b√∫squeda</button>
        </div>
        <div id="december-summary" class="december-summary panel-meta"></div>
        <div class="december-panels">
          <div>
            <div class="december-panel-head">
              <h4>N√∫meros en vigilancia</h4>
              <p class="hint small">Incluye cada s√≠mbolo y estatus de ventana.</p>
            </div>
            <div id="december-watchlist" class="december-watchlist"></div>
            <div id="december-reminders" class="december-reminders"></div>
          </div>
          <div class="december-detail" id="december-detail">
            <p class="hint">Selecciona un n√∫mero para ver su l√≠nea de repeticiones y recomendaciones.</p>
          </div>
        </div>
      </article>
      <div class="strategy-toolbar">
        <button id="strategy-refresh" class="btn-outline">Actualizar estrategias</button>
      </div>
      <div class="strategy-filters">
        <div class="strategy-filter-group">
          <span>Turno objetivo</span>
          <div class="strategy-chip-row">
            <button type="button" class="strategy-chip active" data-strategy-turn="11AM">11 AM</button>
            <button type="button" class="strategy-chip active" data-strategy-turn="3PM">3 PM</button>
            <button type="button" class="strategy-chip active" data-strategy-turn="9PM">9 PM</button>
          </div>
        </div>
        <div class="strategy-filter-group">
          <span>Operador</span>
          <div class="strategy-chip-row">
            <button type="button" class="strategy-chip active" data-strategy-operator="+">Suma</button>
            <button type="button" class="strategy-chip active" data-strategy-operator="‚àí">Resta</button>
          </div>
        </div>
        <button type="button" id="strategy-reset" class="btn-ghost">Restablecer filtros</button>
      </div>
      <div id="strategies-list" class="strategies-grid">
        <p class="hint">Calcula patrones desde el panel ‚ÄúPatrones‚Äù o haz clic en actualizar.</p>
      </div>
    </section>

    <!-- SECUENCIAS SEMANALES -->
    <section id="view-weekly" class="view hidden">
      <h2>Secuencias semanales</h2>
      <p class="hint">
        Identifica los ciclos que La Diaria repite cada semana por d√≠a y turno. √ösalo para anticipar el n√∫mero base del
        pr√≥ximo lunes, martes‚Ä¶ sin volver a recorrer todo el historial.
      </p>
      <div class="weekly-controls">
        <label>
          Pa√≠s
          <select id="weekly-pais">
            <option value="ALL">Todos</option>
            <option value="HN">HN</option>
            <option value="NI">NI</option>
            <option value="SV">SV</option>
          </select>
        </label>
        <label>
          Turno
          <select id="weekly-turno">
            <option value="">Todos</option>
            <option value="11AM">11 AM</option>
            <option value="3PM">3 PM</option>
            <option value="9PM">9 PM</option>
          </select>
        </label>
        <label>
          Ventana (semanas)
          <input id="weekly-window" type="number" min="4" max="40" value="12" />
        </label>
        <label>
          Repeticiones m√≠nimas
          <input id="weekly-min-repeats" type="number" min="2" max="5" value="2" />
        </label>
        <button id="weekly-refresh" class="btn-outline">Recalcular</button>
      </div>
      <div id="weekly-summary" class="panel-meta">
        <p class="hint">Procesa la ventana seleccionada para detectar ciclos estables.</p>
      </div>
      <div id="weekly-grid" class="weekly-grid">
        <p class="hint">A√∫n no se han calculado las secuencias.</p>
      </div>
      <article class="weekly-monthly-panel weekly-lines-panel">
        <div class="weekly-monthly-head">
          <div>
            <h3>Rotaci√≥n de l√≠neas</h3>
            <p class="hint">Detecta si la loter√≠a alterna bloques de d√≠gitos (00-09, 10-19‚Ä¶) por semanas y anticipa el
              pr√≥ximo bloque probable.</p>
          </div>
          <button id="lines-refresh" class="btn-outline">Detectar rotaci√≥n</button>
        </div>
        <div id="lines-body" class="lines-body">
          <p class="hint">Calcula la rotaci√≥n de l√≠neas para ver cu√°ndo se repite un bloque espec√≠fico.</p>
        </div>
      </article>
      <article class="weekly-monthly-panel lines-missing-panel">
        <div class="weekly-monthly-head">
          <div>
            <h3>Faltantes por l√≠nea</h3>
            <p class="hint">Cuando una l√≠nea se activa, identifica qu√© n√∫meros del bloque a√∫n no han salido y acomp√°√±alos
              con su s√≠mbolo.</p>
          </div>
          <button id="lines-missing-refresh" class="btn-outline">Actualizar faltantes</button>
        </div>
        <div id="lines-missing-body" class="lines-missing-body">
          <p class="hint">Calcula la rotaci√≥n o toca actualizar para listar los pendientes por l√≠nea.</p>
        </div>
      </article>
      <article class="weekly-monthly-panel">
        <div class="weekly-monthly-head">
          <div>
            <h3>Comparador mensual</h3>
            <p class="hint">Contrasta el arranque y el cierre de cada mes para el d√≠a seleccionado y descubre patrones que
              se repiten entre meses consecutivos.</p>
          </div>
          <button id="monthly-refresh" class="btn-outline">Recalcular meses</button>
        </div>
        <div class="monthly-controls">
          <label>
            Pa√≠s
            <select id="monthly-pais">
              <option value="ALL">Todos</option>
              <option value="HN">HN</option>
              <option value="NI">NI</option>
              <option value="SV">SV</option>
            </select>
          </label>
          <label>
            D√≠a de la semana
            <select id="monthly-dow">
              <option value="1" selected>Lunes</option>
              <option value="0">Domingo</option>
              <option value="2">Martes</option>
              <option value="3">Mi√©rcoles</option>
              <option value="4">Jueves</option>
              <option value="5">Viernes</option>
              <option value="6">S√°bado</option>
            </select>
          </label>
          <label>
            Turno
            <select id="monthly-turno">
              <option value="">Todos</option>
              <option value="11AM">11 AM</option>
              <option value="3PM">3 PM</option>
              <option value="9PM">9 PM</option>
            </select>
          </label>
          <label>
            Meses a revisar
            <input id="monthly-months" type="number" min="3" max="24" value="8" />
          </label>
        </div>
        <div id="monthly-summary" class="panel-meta">
          <p class="hint">Selecciona un d√≠a para comparar c√≥mo arrancan y cierran los meses.</p>
        </div>
        <div id="monthly-table" class="monthly-table">
          <p class="hint">A√∫n no hay datos suficientes.</p>
        </div>
      </article>
      <article class="weekly-monthly-panel monthly-trends-panel">
        <div class="weekly-monthly-head">
          <div>
            <h3>Patrones por mes</h3>
            <p class="hint">Explora c√≥mo se comporta un mes a lo largo de los a√±os: repeticiones, l√≠neas dominantes,
              tendencia y alertas accionables.</p>
          </div>
          <button id="monthly-trend-refresh" class="btn-outline">Analizar mes</button>
        </div>
        <div class="monthly-trend-controls">
          <label>
            Mes
            <select id="monthly-trend-month">
              <option value="0">Enero</option>
              <option value="1">Febrero</option>
              <option value="2">Marzo</option>
              <option value="3">Abril</option>
              <option value="4">Mayo</option>
              <option value="5">Junio</option>
              <option value="6">Julio</option>
              <option value="7">Agosto</option>
              <option value="8">Septiembre</option>
              <option value="9">Octubre</option>
              <option value="10">Noviembre</option>
              <option value="11">Diciembre</option>
            </select>
          </label>
          <label>
            Pa√≠s
            <select id="monthly-trend-pais">
              <option value="ALL">Todos</option>
              <option value="HN">HN</option>
              <option value="NI">NI</option>
              <option value="SV">SV</option>
            </select>
          </label>
          <label>
            Turno
            <select id="monthly-trend-turno">
              <option value="">Todos</option>
              <option value="11AM">11 AM</option>
              <option value="3PM">3 PM</option>
              <option value="9PM">9 PM</option>
            </select>
          </label>
          <label>
            A√±os a comparar
            <input id="monthly-trend-years" type="number" min="2" max="10" value="5" />
          </label>
        </div>
        <div id="monthly-trend-summary" class="panel-meta">
          <p class="hint">Selecciona un mes y recalcula para obtener el resumen hist√≥rico.</p>
        </div>
        <div id="monthly-trend-alerts" class="monthly-trend-alerts">
          <p class="hint">A√∫n no hay alertas detectadas para este an√°lisis.</p>
        </div>
        <div id="monthly-trend-chart" class="monthly-trend-chart">
          <p class="hint">Calcula el mes para mostrar la tendencia de los n√∫meros ganadores.</p>
        </div>
        <div class="monthly-trend-grid">
          <div class="monthly-trend-card">
            <div class="monthly-trend-card__head">
              <h4>N√∫meros dominantes</h4>
            </div>
            <div id="monthly-trend-hotlist" class="monthly-trend-hotlist">
              <p class="hint">Procesa el mes para ver los n√∫meros con mayor reincidencia.</p>
            </div>
          </div>
          <div class="monthly-trend-card">
            <div class="monthly-trend-card__head">
              <h4>Actividad por a√±o</h4>
            </div>
            <div id="monthly-trend-years-grid" class="monthly-trend-years">
              <p class="hint">Calcula el mes para revisar el comportamiento anual.</p>
            </div>
          </div>
        </div>
      </article>
    </section>

    <!-- ABONO DEL D√çA -->
    <section id="view-abono" class="view hidden">
      <h2>Abono del d√≠a</h2>
      <p class="hint">Genera un abono √∫nico basado en los n√∫meros que m√°s se repiten en este d√≠a de la semana. Usa el
        historial real y una ruleta r√°pida para elegir el candidato.</p>
      <div class="abono-controls">
        <label>
          Fecha objetivo
          <input id="abono-fecha" type="date" />
        </label>
        <label>
          Pa√≠s
          <select id="abono-pais">
            <option value="HN">HN</option>
            <option value="NI">NI</option>
            <option value="SV">SV</option>
          </select>
        </label>
        <label>
          Ventana (semanas)
          <input id="abono-window" type="number" min="6" max="40" value="16" />
        </label>
        <button id="abono-generar" class="btn-primary">Generar abono</button>
      </div>
      <div id="abono-output" class="abono-output">
        <p class="hint">Configura los filtros y genera tu abono.</p>
      </div>
    </section>

    <!-- SECUENCIA GATILLO -->
    <section id="view-gatillo" class="view hidden">
      <h2>Secuencia gatillo</h2>
      <p class="hint">Descubre qu√© n√∫meros suelen salir inmediatamente despu√©s de un n√∫mero gatillo. Usa el historial
        reciente ordenado por fecha y turno.</p>
      <div class="gatillo-controls">
        <label>
          N√∫mero gatillo
          <input id="gatillo-num" type="number" min="0" max="99" placeholder="00-99" />
        </label>
        <label>
          Pa√≠s
          <select id="gatillo-pais">
            <option value="ALL">Todos</option>
            <option value="HN">HN</option>
            <option value="NI">NI</option>
            <option value="SV">SV</option>
          </select>
        </label>
        <label>
          Ventana (√∫ltimos sorteos)
          <input id="gatillo-window" type="number" min="30" max="400" value="180" />
        </label>
        <button id="gatillo-calcular" class="btn-primary">Calcular secuencia</button>
      </div>
      <div id="gatillo-output" class="gatillo-output">
        <p class="hint">Ingresa un n√∫mero gatillo y calcula para ver sus seguidores habituales.</p>
      </div>
    </section>

    <!-- CUADERNO -->
    <section id="view-notebook" class="view hidden">
      <h2>Cuaderno de seguimiento</h2>
      <p class="hint">
        Guarda un tr√≠o de sorteos para darle seguimiento durante la semana. Puedes importar los n√∫meros del panel del d√≠a
        o usar los resultados ya registrados.
      </p>
      <div class="notebook-form">
        <label>
          Fecha
          <input type="date" id="nb-fecha" />
        </label>
        <label>
          Pa√≠s
          <select id="nb-pais">
            <option value="HN">HN</option>
            <option value="NI">NI</option>
            <option value="SV">SV</option>
          </select>
        </label>
      </div>
      <div class="notebook-numbers">
        <label>
          11 AM
          <input id="nb-11" maxlength="2" placeholder="--" />
        </label>
        <label>
          3 PM
          <input id="nb-3" maxlength="2" placeholder="--" />
        </label>
        <label>
          9 PM
          <input id="nb-9" maxlength="2" placeholder="--" />
        </label>
      </div>
      <div class="notebook-actions">
        <button id="nb-fill-day" class="btn-outline">Usar panel del d√≠a</button>
        <button id="nb-fill-results" class="btn-outline">Traer resultados guardados</button>
        <button id="nb-save" class="btn-primary">Guardar trio</button>
      </div>
      <div id="nb-list" class="notebook-list">
        <p class="hint">Todav√≠a no tienes elementos en el cuaderno.</p>
      </div>
    </section>

    <!-- MEMORIA -->
    <section id="view-memory" class="view hidden">
      <h2>Memoria transversal</h2>
      <p class="hint">Explora el mapa hologr√°fico 00‚Äì99. Cada clic abre el expediente del n√∫mero con sus apariciones, conversiones y tiempos de espera.</p>
      <div class="memory-panel">
        <article class="memory-board">
          <div class="memory-board__head">
            <div>
              <h3>√ìrbita 00‚Äì99</h3>
              <p class="hint">Intensidad = actividad directa. Haz clic para abrir el detalle.</p>
            </div>
            <button id="memory-refresh" class="btn-outline">Actualizar</button>
          </div>
          <div id="memory-board-grid" class="memory-board-grid">
            <p class="hint">Cargando historial‚Ä¶</p>
          </div>
        </article>
        <article id="memory-detail" class="memory-detail">
          <p class="hint">Selecciona un n√∫mero para ver su bit√°cora, transformaciones y saltar al d√≠a exacto.</p>
        </article>
      </div>
      <article class="memory-gap-panel">
        <div class="memory-board__head">
          <div>
            <h3>Monitor de huecos</h3>
            <p class="hint">Calcula cada cu√°nto reaparece cada n√∫mero y resalta los que est√°n por entrar en ventana.</p>
          </div>
          <button id="memory-gap-refresh" class="btn-outline">Recalcular</button>
        </div>
        <div id="memory-gap-grid" class="memory-gap-grid">
          <p class="hint">Procesando huecos‚Ä¶</p>
        </div>
      </article>
      <div class="memory-tech">
        <button id="toggle-tech" class="btn-ghost">Mostrar/Ocultar modo t√©cnico</button>
        <pre id="mem-out" class="hidden"></pre>
      </div>
    </section>

    <!-- GU√çA -->
    <section id="view-guide" class="view hidden">
      <h2>Gu√≠a de los Sue√±os</h2>
      <p class="hint">
        Explora todos los n√∫meros (00‚Äì99), sus s√≠mbolos, familias y polaridades. <br />
        Los espacios vac√≠os est√°n reservados para las im√°genes futuras de cada s√≠mbolo.
      </p>
      <div id="guide-grid" class="guide-grid"></div>
      <div class="guide-families-card">
        <div class="guide-families-head">
          <h3>Familias destacadas</h3>
          <p class="hint">Separa los n√∫meros seg√∫n la familia simb√≥lica para analizarlos en bloque.</p>
          <div class="guide-family-search">
            <input id="guide-search" placeholder="Ej. 22 o 'naturaleza'" />
          </div>
        </div>
        <div id="guide-families" class="guide-family-groups"></div>
        <div class="guide-family-stats-card">
          <div class="guide-family-stats-head">
            <strong>Actividad por familia</strong>
            <span class="hint">Basado en todos los sorteos registrados (sin modo prueba).</span>
          </div>
          <div id="guide-family-stats" class="guide-family-stats-wrap"></div>
        </div>
      </div>
    </section>

    <!-- CONFIGURACI√ìN -->
    <section id="view-config" class="view hidden">
      <h2>Configuraci√≥n</h2>
      <div class="card">
        <div class="card-head">Migraci√≥n de datos</div>
        <div class="card-body">
          <p class="hint">
            Usa el importador existente para enviar los datos de Dexie a Supabase. Observa el progreso por tabla y los
            errores que puedan aparecer.
          </p>
          <div class="row">
            <button id="btn-migrar-dexie" class="btn-primary">Migrar Dexie ‚Üí Supabase</button>
          </div>
        </div>
      </div>
    </section>

    <!-- MANTENIMIENTO -->
    <section id="view-maint" class="view hidden">
      <h2>Mantenimiento</h2>
      <div class="card">
        <div class="card-head">Duplicados</div>
        <div class="row">
          <button id="btn-list-dup">Revisar duplicados</button>
          <button id="btn-marktest-dup">Marcar seleccionados como modo prueba</button>
          <button id="btn-delete-dup">Eliminar seleccionados</button>
        </div>
        <div id="dup-out" class="card-body"></div>
      </div>
      <div class="card" style="margin-top:15px;">
        <div class="card-head">Correcciones de fecha</div>
        <p class="hint">
          Ajusta sorteos que quedaron registrados con un d√≠a adelantado por el desfase UTC. Solo modifica los que est√©n
          como m√°ximo un d√≠a en el futuro respecto a su fecha de captura.
        </p>
        <div class="row">
          <button id="btn-fix-dates">Corregir sorteos adelantados</button>
        </div>
        <div id="fix-dates-out" class="card-body"></div>
      </div>
      <div class="card" style="margin-top:15px;">
        <div class="card-head">Todos los sorteos registrados</div>
        <div class="row">
          <button id="btn-list-all">Ver todos</button>
        </div>
        <div class="row" style="flex-wrap:wrap;">
          <label>
            <span class="label-title">Fecha exacta</span>
            <input type="date" id="all-filter-date" />
          </label>
          <label>
            <span class="label-title">Filtro r√°pido</span>
            <input id="all-filter-text" placeholder="Ej. 2024-02-14, HN, 3PM, 34" />
          </label>
          <button type="button" id="all-filter-clear" class="btn-ghost">Limpiar filtros</button>
        </div>
        <p class="hint small">
          Filtra por fecha o escribe parte del pa√≠s, horario, n√∫mero o s√≠mbolo para ubicar sorteos m√°s r√°pido.
        </p>
        <div id="all-out" class="card-body"></div>
      </div>
      <div class="card" style="margin-top:15px;">
        <div class="card-head">Reiniciar base de datos</div>
        <div class="row">
          <button id="btn-nuke" style="background:#e04c41;border-color:#e04c41;color:#fff;">
            ‚ö†Ô∏è Borrar todo (reiniciar)
          </button>
        </div>
        <p class="hint">Usa con precauci√≥n: eliminar√° todos los sorteos, hip√≥tesis y reglas.</p>
      </div>


    </section>

    <section id="view-modes" class="view hidden">
      <h2>Modos de juego</h2>
      <div class="mode-form card">
        <div class="card-head">Crear/Editar modo</div>
        <div class="card-body mode-form-body">
          <div class="row mode-form-row">
            <label class="grow">
              <span class="label-title">Nombre</span>
              <input id="mode-name" placeholder="Ej. Columna 5" />
            </label>
            <label class="grow">
              <span class="label-title">Tipo</span>
              <select id="mode-type">
                <option value="manual">Manual</option>
                <option value="conversion_simple">Conversi√≥n simple</option>
                <option value="conversion_compuesta">Conversi√≥n compuesta</option>
                <option value="inversion_numero">Inversi√≥n de n√∫mero</option>
                <option value="suma_digitos">Suma de d√≠gitos</option>
                <option value="linea_1">Jugando con l√≠nea 1</option>
                <option value="linea_2">Jugando con l√≠nea 2</option>
                <option value="ajuste">Jugando con ajuste</option>
                <option value="por_salto">Por salto</option>
                <option value="por_repeticion">Por repetici√≥n</option>
                <option value="por_distraccion">Por distracci√≥n</option>
                <option value="cambia_eje">Por cambia de eje</option>
                <option value="por_narrativa">Por narrativa</option>
                <option value="por_familia">Por familia</option>
                <option value="patron">Patr√≥n (otros)</option>
              </select>
            </label>
          </div>
          <div class="row mode-form-row">
            <label class="grow">
              <span class="label-title">Operaci√≥n</span>
              <select id="mode-operation">
                <option value="">‚Äî Solo descriptivo ‚Äî</option>
                <option value="mirror">Invertir d√≠gitos</option>
                <option value="sum-digits">Suma de d√≠gitos (resultado completo)</option>
                <option value="sum-digits-keep-first">Suma de d√≠gitos (mantener primer d√≠gito)</option>
                <option value="add-constant">Sumar constante</option>
                <option value="sub-constant">Restar constante</option>
                <option value="neighbor">N√∫mero vecino (¬±1)</option>
                <option value="digit-map">Mapa de d√≠gitos (pares equivalentes)</option>
              </select>
            </label>
            <label class="grow">
              <span class="label-title">Par√°metro</span>
              <input id="mode-parameter" placeholder="Ej. 1" />
            </label>
            <label class="grow">
              <span class="label-title">Avance (turnos)</span>
              <select id="mode-offset">
                <option value="1">Siguiente turno</option>
                <option value="2">Dos turnos despu√©s</option>
                <option value="0">Mismo turno</option>
              </select>
            </label>
          </div>
          <label class="grow mode-desc">
            <span class="label-title">Descripci√≥n</span>
            <textarea id="mode-desc" rows="3" placeholder="Define el modo en tus palabras"></textarea>
          </label>
          <button id="mode-save">Guardar modo</button>
        </div>
      </div>

      <div class="mode-list card">
        <div class="card-head">Modos registrados</div>
        <div id="mode-list" class="card-body mode-list-body"></div>
      </div>
    </section>
  </main>

  <div id="toast-container" class="toast-container"></div>
  <div id="boot-loader" class="boot-loader hidden" aria-live="polite">
    <div class="processing-box">
      <div class="processing-spinner"></div>
      <div class="processing-text">Cargando sistema‚Ä¶<br />Por favor espere</div>
    </div>
  </div>
  <div id="processing-modal" class="processing-modal hidden" aria-live="polite">
    <div class="processing-box">
      <div class="processing-spinner"></div>
      <div class="processing-text">Guardando datos‚Ä¶<br />Por favor espere</div>
    </div>
  </div>

  <script type="module">
    import { mostrarGuia } from "./src/guide-grid.js";
    import { DB } from "./src/storage.js";
    import { importarManual } from "./src/importer.js";
    import { crearHipotesis, actualizarHipotesis, registrarResultado } from "./src/narrative.js";
    import { analizarYProponer } from "./src/reasoning.js";
    import {
      generarCruceta,
      generarTrianguloInvertido,
      dibujarTrianguloInvertido,
      generarCrucetaTurnos,
    } from "./src/geometry.js";
    import { cargarGuia, GUIA, getColorPolaridad } from "./src/loader.js";
    import { detectarPatrones } from "./src/pattern-detector.js";
    import {
      revisarDuplicados,
      marcarGrupoComoTest,
      borrarIds,
      corregirFechasDesfasadas,
    } from "./src/maintenance.js";
    import { mostrarTransformaciones } from "./src/transform-visual.js";
    import { getSimpleConversions, getCompositeConversions } from "./src/conversion-map.js";
    import { construirPerfilNumero, resumirActividadNumeros, construirGapSummary } from "./src/memory.js";
    import {
      rebuildKnowledge,
      obtenerPerfilesNumeros,
      generarPredicciones,
      describirPerfil,
      generarInsights,
      obtenerResumenPredicciones,
    } from "./src/learning.js";
    import { analizarSesgos } from "./src/bias-analyzer.js";
    import { analizarSecuenciasSemanales, analizarComparacionMensual, analizarRotacionLineas } from "./src/weekly-patterns.js";
    import { analizarPatronesMensuales } from "./src/monthly-trends.js";
    import { evaluarMotorPega3 } from "./src/pega3-engine.js";
    import { loadUserPreferences, saveUserPreferences } from "./src/user-preferences.js";
    import { computeDecemberStrategy } from "./src/december-strategy.js";
    import {
      createMode,
      updateMode,
      deleteMode,
      listModesWithExamples,
      deleteModeExample,
      logModeUsage,
      listModeUsage,
    } from "./src/modes.js";
    import { evaluarModos } from "./src/mode-engine.js";
    import { formatDateISO, getTodayISODate, parseDrawDate } from "./src/date-utils.js";
    import { logInfo, logWarn } from "./src/logger.js";
    import { runDexieToSupabaseImport } from "./src/dexieToSupabaseImporter.js";
    import { supabase } from "./src/supabaseClient.js";
    import { logout as supabaseLogout, requireAuthOrRedirect } from "./src/auth.js";
    import { showBootLoader, hideBootLoader } from "./src/boot-loader.js";
    const bootOverlay = document.getElementById("boot-loader");
    const processingModal = document.getElementById("processing-modal");
    const waitForFirstPaint = () =>
      new Promise((resolve) => requestAnimationFrame(() => requestAnimationFrame(resolve)));
    const isBooting = () => !!bootOverlay && !bootOverlay.classList.contains("hidden");
    const showSavingModal = () => {
      if (isBooting()) return;
      processingModal?.classList.remove("hidden");
    };
    const hideSavingModal = () => processingModal?.classList.add("hidden");
    const runWithSavingModal = async (task) => {
      showSavingModal();
      try {
        return await task();
      } finally {
        hideSavingModal();
      }
    };
    hideSavingModal();
    window.addEventListener("pageshow", hideSavingModal);

    let guideLoadError = null;
    let userPreferences = {};
    let userPrefsSaveTimer = null;
    let decemberStrategyData = null;
    let decemberSelectedYear = null;
    let decemberSelectedNumero = null;
    let decemberReminderStore = {};

    async function initUserPreferences(user) {
      if (!user?.id) return;
      try {
        const prefs = await loadUserPreferences(user.id);
        if (prefs && typeof prefs === "object") {
          userPreferences = prefs;
        }
      } catch (err) {
        logWarn("No se pudieron inicializar preferencias de usuario", err);
      }
    }

    function queueUserPreferencesSave(patch = {}) {
      if (!currentUser?.id) return;
      userPreferences = { ...(userPreferences || {}), ...patch };
      if (userPrefsSaveTimer) clearTimeout(userPrefsSaveTimer);
      userPrefsSaveTimer = setTimeout(async () => {
        userPrefsSaveTimer = null;
        try {
          await saveUserPreferences(currentUser.id, userPreferences);
        } catch (err) {
          logWarn("No se pudieron guardar preferencias de usuario", err);
        }
      }, 350);
    }

    const currentUser = await requireAuthOrRedirect("./login.html");
    if (!currentUser) throw new Error("Auth requerida");
    supabase.auth.onAuthStateChange((event, session) => {
      if (event === "SIGNED_OUT" || !session?.user) {
        window.location.href = "./login.html";
      }
    });
    await initUserPreferences(currentUser);
    decemberReminderStore = loadDecemberReminderStore();
    showBootLoader();
    try {
      await cargarGuia();
    } catch (err) {
      guideLoadError = err instanceof Error ? err : new Error(String(err));
    }

    try {
      const autoFix = await DB.fixFutureDatedDraws({ maxAheadDays: 1 });
      if (autoFix?.length) {
        logInfo("Sorteos corregidos autom√°ticamente:", autoFix);
        showToast(`Se corrigieron ${autoFix.length} sorteos con fecha adelantada.`, { variant: "info" });
      }
    } catch (err) {
      logWarn("No se pudieron corregir fechas adelantadas autom√°ticamente", err);
    }

    const toastContainer = document.getElementById("toast-container");
    function withButtonBusy(button, label = null) {
      if (!button) return () => {};
      const prevText = button.textContent;
      const prevDisabled = button.disabled;
      button.disabled = true;
      if (label) button.textContent = label;
      return () => {
        if (label) button.textContent = prevText;
        button.disabled = prevDisabled;
      };
    }

    function showToast(message, { variant = "info", timeout = 4200 } = {}) {
      if (!toastContainer) {
        logWarn("Toast:", message);
        return;
      }
      const toast = document.createElement("div");
      toast.className = "toast";
      toast.dataset.variant = variant;
      const text = document.createElement("span");
      text.textContent = message;

      let hideTimer = null;
      const dismiss = () => {
        if (!toast || toast.classList.contains("hide")) return;
        toast.classList.add("hide");
        setTimeout(() => toast.remove(), 220);
      };

      const close = document.createElement("button");
      close.type = "button";
      close.innerHTML = "&times;";
      close.addEventListener("click", () => dismiss());

      toast.appendChild(text);
      toast.appendChild(close);
      toastContainer.appendChild(toast);

      hideTimer = setTimeout(dismiss, timeout);
      toast.addEventListener("mouseenter", () => clearTimeout(hideTimer));
      toast.addEventListener("mouseleave", () => {
        hideTimer = setTimeout(dismiss, 1800);
      });
    }

    if (guideLoadError) {
      reportGuideLoadIssue(guideLoadError);
    }

    function reportGuideLoadIssue(error) {
      const runningFromFile = window.location.protocol === "file:";
      const resolutionHint = runningFromFile
        ? "Ejecuta npm run dev o sirve la carpeta con cualquier servidor HTTP para permitir la lectura de archivos locales."
        : "Verifica que el archivo data/guia_suenos.json exista y sea accesible desde el servidor.";
      const toastMessage = `No se pudo cargar la Gu√≠a de los Sue√±os: ${error.message || error}. ${resolutionHint}`;
      const guideGrid = document.getElementById("guide-grid");
      if (guideGrid) {
        const hint = document.createElement("p");
        hint.className = "hint";
        hint.textContent = toastMessage;
        guideGrid.innerHTML = "";
        guideGrid.appendChild(hint);
      }
      showToast(toastMessage, { variant: "danger", timeout: 9000 });
    }

    const modeNameInput = document.getElementById("mode-name");
    const modeTypeSelect = document.getElementById("mode-type");
    const modeDescInput = document.getElementById("mode-desc");
    const modeOperationSelect = document.getElementById("mode-operation");
    const modeParamInput = document.getElementById("mode-parameter");
    const modeOffsetSelect = document.getElementById("mode-offset");
    const modeSaveBtn = document.getElementById("mode-save");
    let editingModeId = null;

    const notebookFechaInput = document.getElementById("nb-fecha");
    const notebookPaisSelect = document.getElementById("nb-pais");
    const notebookInputs = {
      "11AM": document.getElementById("nb-11"),
      "3PM": document.getElementById("nb-3"),
      "9PM": document.getElementById("nb-9"),
    };
    const notebookFillDayBtn = document.getElementById("nb-fill-day");
    const notebookFillResultsBtn = document.getElementById("nb-fill-results");
    const notebookSaveBtn = document.getElementById("nb-save");
    const notebookList = document.getElementById("nb-list");
    const dayFecha = document.getElementById("day-fecha");
    const dayFechaDow = document.getElementById("day-fecha-dow");
    const dayPais = document.getElementById("day-pais");
    const geometryDateInput = document.getElementById("g-fecha");
    const geometryPaisSelect = document.getElementById("g-pais");
    const memoryBoardGrid = document.getElementById("memory-board-grid");
    const memoryDetail = document.getElementById("memory-detail");
    const memoryRefreshBtn = document.getElementById("memory-refresh");
    const memoryGapGrid = document.getElementById("memory-gap-grid");
    const memoryGapRefreshBtn = document.getElementById("memory-gap-refresh");

    function updateDayFechaDow(value = dayFecha?.value) {
      if (!dayFechaDow) return;
      if (!value) {
        dayFechaDow.textContent = "‚Äî";
        return;
      }
      const parsed = parseISODate(value);
      if (!parsed) {
        dayFechaDow.textContent = "‚Äî";
        return;
      }
      const dow = DOW_FULL_LABEL[parsed.getDay()] || "";
      const monthName = MONTH_NAMES[parsed.getMonth()] || "";
      dayFechaDow.textContent = dow ? `${dow} ¬∑ ${monthName}` : monthName || "‚Äî";
    }

    function autoAdvanceDayFecha() {
      if (!dayFecha || !dayFecha.value) return;
      const nextValue = incrementISODate(dayFecha.value, 1);
      if (!nextValue || nextValue === dayFecha.value) return;
      dayFecha.value = nextValue;
      dayFecha.dispatchEvent(new Event("change", { bubbles: true }));
    }

    async function procesarAprendizajeDia({
      fecha,
      pais,
      silent = false,
      skipKnowledgeSync = false,
    } = {}) {
      const normalizedPais = (pais || "").trim().toUpperCase();
      if (!fecha || !normalizedPais) {
        if (!silent) {
          showToast("Selecciona fecha y pa√≠s para procesar el aprendizaje.", { variant: "warning" });
        }
        return { status: "invalid" };
      }
      const draws = (await DB.listDraws({ excludeTest: true })).filter(
        (d) => d.fecha === fecha && (d.pais || "").trim().toUpperCase() === normalizedPais
      );
      if (!draws.length) {
        if (!silent) {
          showToast("No hay sorteos reales registrados para esa fecha y pa√≠s.", { variant: "warning" });
        }
        return { status: "no-data" };
      }
      const alreadyLogged = (await DB.getHypothesisLogs()).some(
        (log) =>
          log.fechaResultado === fecha &&
          ((log.paisResultado || "").trim().toUpperCase() === normalizedPais)
      );
      if (alreadyLogged) {
        if (!silent) {
          showToast("Los resultados de ese d√≠a ya fueron procesados anteriormente.", {
            variant: "info",
            timeout: 3200,
          });
        }
        return { status: "already" };
      }
      await runWithSavingModal(async () => {
        for (const draw of draws) {
          const simbolo = getSymbol(draw.numero);
          await registrarResultado({
            numero: draw.numero,
            simbolo,
            fecha: draw.fecha,
            pais: draw.pais,
            horario: draw.horario,
          });
        }
        await DB.closePredictionBatch({ fecha, pais: normalizedPais });
      });
      if (!skipKnowledgeSync) {
        await rebuildKnowledge();
        await refreshHypotesis();
      }
      if (!silent) {
        showToast("Hip√≥tesis actualizadas con los resultados del d√≠a.", { variant: "success" });
      }
      return { status: "success" };
    }
    function resetModeForm() {
      editingModeId = null;
      if (modeNameInput) modeNameInput.value = "";
      if (modeTypeSelect) modeTypeSelect.value = "manual";
      if (modeDescInput) modeDescInput.value = "";
      if (modeOperationSelect) modeOperationSelect.value = "";
      if (modeParamInput) modeParamInput.value = "";
      if (modeOffsetSelect) modeOffsetSelect.value = "1";
      if (modeSaveBtn) modeSaveBtn.textContent = "Guardar modo";
    }

    function describeModoOperacion(mode = {}) {
      const op = mode.operacion || "";
      if (!op) return "";
      const params = mode.parametros ?? mode.parametro ?? {};
      const valor = typeof params === "object" && params !== null ? (params.valor ?? params.constante ?? params.raw) : params;
      const offset = Number.isFinite(mode.offset) ? mode.offset : null;

      const nombreOperacion = {
        mirror: "Invertir d√≠gitos",
        "sum-digits": "Suma de d√≠gitos",
        "sum-digits-keep-first": "Suma de d√≠gitos (mantener primer d√≠gito)",
        "add-constant": "Sumar constante",
        "sub-constant": "Restar constante",
        neighbor: "N√∫mero vecino",
      }[op] || op;

      let detalle = nombreOperacion;
      if (valor !== undefined && valor !== null && valor !== "") {
        detalle += ` ¬∑ param ${valor}`;
      }
      if (offset !== null) {
        const offsetTxt = offset === 0 ? "mismo turno" : offset === 1 ? "siguiente turno" : `${offset} turnos`;
        detalle += ` ¬∑ ${offsetTxt}`;
      }
      return detalle;
    }

    function buildModeParameters(operacion, rawValue) {
      if (!operacion) return null;
      if (operacion === "digit-map") {
        const valor = rawValue?.trim() || "0:1,2:5,3:8,4:7,6:9";
        return { mapa: valor };
      }
      if (!rawValue) return {};
      const numeric = Number(rawValue);
      if (!Number.isNaN(numeric) && rawValue.trim() !== "") {
        return { valor: numeric };
      }
      return { valor: rawValue };
    }

    async function refreshModesPanel() {
      const container = document.getElementById("mode-list");
      if (!container) return;
      const modes = await listModesWithExamples();
      container.innerHTML = "";
      if (!modes.length) {
        container.innerHTML = "<p class='hint'>A√∫n no hay modos registrados.</p>";
        if (!editingModeId) resetModeForm();
        return;
      }

      const dayFechaInput = document.getElementById("day-fecha");
      const dayPaisSelect = document.getElementById("day-pais");
      const paisOptions = Array.from(dayPaisSelect?.options || []).map((opt) => opt.value || opt.textContent || "");

      for (const mode of modes) {
        const item = document.createElement("div");
        item.className = "mode-item";

        const head = document.createElement("div");
        head.className = "mode-item-head";
        const titleWrap = document.createElement("div");
        const title = document.createElement("strong");
        title.textContent = mode.nombre;
        const chip = document.createElement("span");
        chip.className = "analysis-chip";
        chip.textContent = mode.tipo || "manual";
        titleWrap.appendChild(title);
        titleWrap.appendChild(chip);
        head.appendChild(titleWrap);

        const actions = document.createElement("div");
        actions.className = "mode-item-actions";

        const editBtn = document.createElement("button");
        editBtn.type = "button";
        editBtn.className = "btn-secondary";
        editBtn.textContent = "Editar";
        editBtn.addEventListener("click", () => {
          editingModeId = mode.id;
          if (modeNameInput) modeNameInput.value = mode.nombre || "";
          if (modeTypeSelect) modeTypeSelect.value = mode.tipo || "manual";
          if (modeDescInput) modeDescInput.value = mode.descripcion || "";
          if (modeOperationSelect) modeOperationSelect.value = mode.operacion || "";
          if (modeParamInput) {
            const params = mode.parametros ?? mode.parametro ?? {};
            let valor = "";
            if (mode.operacion === "digit-map") {
              if (typeof params === "object" && params !== null) valor = params.mapa ?? "";
              else valor = params ?? "";
            } else {
              valor = typeof params === "object" && params !== null ? (params.valor ?? params.constante ?? params.raw) : params;
            }
            modeParamInput.value = valor ?? "";
          }
          if (modeOffsetSelect) {
            const offsetVal = Number.isFinite(mode.offset) ? String(mode.offset) : "1";
            modeOffsetSelect.value = offsetVal;
          }
          if (modeSaveBtn) modeSaveBtn.textContent = "Actualizar modo";
          showToast(`Editando modo ${mode.nombre}`, { variant: "info", timeout: 2500 });
        });

        const deleteBtn = document.createElement("button");
        deleteBtn.type = "button";
        deleteBtn.className = "btn-danger";
        deleteBtn.textContent = "Eliminar";
        deleteBtn.addEventListener("click", async () => {
          const confirmar = await mostrarModal(
            "Eliminar modo",
            `¬øEliminar el modo "${mode.nombre}" y sus ejemplos?`,
            { okText: "Eliminar", cancelText: "Cancelar", okVariant: "danger" }
          );
          if (!confirmar) return;
          try {
            await deleteMode(mode.id);
            if (editingModeId === mode.id) resetModeForm();
            await refreshModesPanel();
            showToast("Modo eliminado.", { variant: "success" });
          } catch (err) {
            showToast(`No se pudo eliminar: ${err.message}`, { variant: "danger" });
          }
        });

        actions.appendChild(editBtn);
        actions.appendChild(deleteBtn);
        head.appendChild(actions);
        item.appendChild(head);

        const metaOperacion = describeModoOperacion(mode);
        if (metaOperacion) {
          const opMeta = document.createElement("div");
          opMeta.className = "mode-meta";
          opMeta.textContent = metaOperacion;
          item.appendChild(opMeta);
        }

        const desc = document.createElement("div");
        desc.className = "analysis-note";
        desc.textContent = mode.descripcion || "Sin descripci√≥n.";
        item.appendChild(desc);

        const exampleList = document.createElement("div");
        exampleList.className = "mode-example-list";
        if (mode.ejemplos?.length) {
          mode.ejemplos.forEach((ex) => {
            const row = document.createElement("div");
            row.className = "mode-example";
            const text = document.createElement("span");
            const nota = ex.nota ? ` ¬∑ ${ex.nota}` : "";
            text.textContent = `${ex.original} ‚Üí ${ex.resultado}${nota}`;
            text.style.flex = "1";
            const del = document.createElement("button");
            del.type = "button";
            del.className = "btn-ghost";
            del.textContent = "Eliminar";
            del.addEventListener("click", async () => {
              const ok = await mostrarModal(
                "Eliminar ejemplo",
                `¬øEliminar el ejemplo ${ex.original} ‚Üí ${ex.resultado}?`,
                { okText: "Eliminar", cancelText: "Cancelar", okVariant: "danger" }
              );
              if (!ok) return;
              await deleteModeExample(ex.id);
              showToast("Ejemplo eliminado.", { variant: "success" });
              await refreshModesPanel();
            });
            row.appendChild(text);
            row.appendChild(del);
            exampleList.appendChild(row);
          });
        } else {
          const empty = document.createElement("span");
          empty.className = "analysis-note";
          empty.textContent = "Sin ejemplos registrados.";
          exampleList.appendChild(empty);
        }
        item.appendChild(exampleList);

        const exampleForm = document.createElement("div");
        exampleForm.className = "mode-example";
        const exOriginal = document.createElement("input");
        exOriginal.placeholder = "Original";
        exOriginal.maxLength = 4;
        const exResultado = document.createElement("input");
        exResultado.placeholder = "Resultado";
        exResultado.maxLength = 4;
        const exNota = document.createElement("input");
        exNota.placeholder = "Nota";
        exNota.style.flex = "1";
        const exBtn = document.createElement("button");
        exBtn.type = "button";
        exBtn.className = "btn-secondary";
        exBtn.textContent = "Agregar";
        exBtn.addEventListener("click", async () => {
          const original = exOriginal.value.trim();
          const resultado = exResultado.value.trim();
          if (!original || !resultado) {
            showToast("Completa original y resultado.", { variant: "warning" });
            return;
          }
          try {
            await DB.addGameModeExample({
              modeId: mode.id,
              original,
              resultado,
              nota: exNota.value.trim() || "",
            });
            showToast("Ejemplo agregado.", { variant: "success" });
            await refreshModesPanel();
          } catch (err) {
            showToast(`No se pudo agregar el ejemplo: ${err.message}`,
              { variant: "danger" }
            );
          }
        });
        exampleForm.appendChild(exOriginal);
        exampleForm.appendChild(exResultado);
        exampleForm.appendChild(exNota);
        exampleForm.appendChild(exBtn);
        item.appendChild(exampleForm);

        const logForm = document.createElement("div");
        logForm.className = "mode-log-form";
        const logDate = document.createElement("input");
        logDate.type = "date";
        logDate.value = dayFechaInput?.value || "";
        const logPais = document.createElement("select");
        const defaultPaisOpt = document.createElement("option");
        defaultPaisOpt.value = "";
        defaultPaisOpt.textContent = "Pa√≠s";
        logPais.appendChild(defaultPaisOpt);
        const options = paisOptions.length ? paisOptions : ["HN", "NI", "SV"];
        options.forEach((p) => {
          const opt = document.createElement("option");
          opt.value = p;
          opt.textContent = p;
          if (dayPaisSelect?.value === p) opt.selected = true;
          logPais.appendChild(opt);
        });
        const logTurno = document.createElement("select");
        ["", "11AM", "3PM", "9PM"].forEach((turno) => {
          const opt = document.createElement("option");
          opt.value = turno;
          opt.textContent = turno || "Turno";
          logTurno.appendChild(opt);
        });
        const logNotas = document.createElement("input");
        logNotas.type = "text";
        logNotas.placeholder = "Notas";
        const logBtn = document.createElement("button");
        logBtn.type = "button";
        logBtn.className = "btn-secondary";
        logBtn.textContent = "Registrar uso";
        logBtn.addEventListener("click", async () => {
          if (!logDate.value) {
            showToast("Ingresa una fecha para registrar el modo.", { variant: "warning" });
            return;
          }
          try {
            await logModeUsage({
              modeId: mode.id,
              fecha: logDate.value,
              pais: logPais.value || null,
              turno: logTurno.value || null,
              notas: logNotas.value.trim() || null,
            });
            logNotas.value = "";
            showToast("Uso registrado.", { variant: "success" });
            await refreshModesPanel();
          } catch (err) {
            showToast(`No se pudo registrar el uso: ${err.message}`,
              { variant: "danger" }
            );
          }
        });
        logForm.appendChild(logDate);
        logForm.appendChild(logPais);
        logForm.appendChild(logTurno);
        logForm.appendChild(logNotas);
        logForm.appendChild(logBtn);
        item.appendChild(logForm);

        const logs = await listModeUsage({ modeId: mode.id });
        const recentLogs = logs
          .slice()
          .sort((a, b) => (b.createdAt || 0) - (a.createdAt || 0))
          .slice(0, 5);
        const logList = document.createElement("div");
        logList.className = "mode-log-list";
        if (!recentLogs.length) {
          const empty = document.createElement("span");
          empty.className = "analysis-note";
          empty.textContent = "Sin usos registrados.";
          logList.appendChild(empty);
        } else {
          recentLogs.forEach((log) => {
            const row = document.createElement("div");
            row.className = "mode-log-item";
            const fechaTxt = log.fecha || "(sin fecha)";
            const paisTxt = log.pais || "-";
            const turnoTxt = log.turno || "-";
            row.innerHTML = `<strong>${fechaTxt}</strong><span>${paisTxt}</span><span>${turnoTxt}</span>${log.notas ? `<span>${log.notas}</span>` : ""}`;
            logList.appendChild(row);
          });
        }
        item.appendChild(logList);

        container.appendChild(item);
      }

      if (modeSaveBtn) {
        modeSaveBtn.textContent = editingModeId ? "Actualizar modo" : "Guardar modo";
      }
    }

    resetModeForm();

    modeSaveBtn?.addEventListener("click", async () => {
      const nombre = modeNameInput?.value.trim();
      if (!nombre) {
        showToast("Ingresa un nombre para el modo.", { variant: "warning" });
        return;
      }
      const operacion = modeOperationSelect?.value || "";
      const parametroRaw = modeParamInput?.value.trim() || "";
      const offsetVal = modeOffsetSelect?.value ?? "";
      const offsetNumber = offsetVal === "" ? null : Number(offsetVal);
      const parametros = buildModeParameters(operacion, parametroRaw);

      const payload = {
        nombre,
        tipo: modeTypeSelect?.value || "manual",
        descripcion: modeDescInput?.value.trim() || "",
        operacion,
        parametros: operacion ? parametros ?? {} : null,
        offset: Number.isFinite(offsetNumber) ? offsetNumber : null,
      };
      try {
        if (editingModeId) {
          await updateMode(editingModeId, payload);
          showToast("Modo actualizado.", { variant: "success" });
        } else {
          await createMode(payload);
          showToast("Modo creado.", { variant: "success" });
        }
        resetModeForm();
        await refreshModesPanel();
      } catch (err) {
        showToast(`No se pudo guardar el modo: ${err.message}`, { variant: "danger" });
      }
    });

    const todayISO = getTodayISODate();
    ["day-fecha", "h-fecha", "g-fecha"].forEach((id) => {
      const el = document.getElementById(id);
      if (el && !el.value) el.value = todayISO;
    });
    if (notebookFechaInput && !notebookFechaInput.value) notebookFechaInput.value = todayISO;
    if (notebookPaisSelect && dayPais?.value) notebookPaisSelect.value = dayPais.value;
    if (geometryPaisSelect && dayPais?.value) geometryPaisSelect.value = dayPais.value;
    if (geometryPaisSelect && !geometryPaisSelect.value) geometryPaisSelect.value = "HN";

    const SLOT_CONFIG = [
      {
        key: "11AM",
        inputId: "n-11",
        checkboxId: "test-11",
        ballId: "b-11",
        symId: "s-11",
      },
      {
        key: "3PM",
        inputId: "n-3",
        checkboxId: "test-3",
        ballId: "b-3",
        symId: "s-3",
      },
      {
        key: "9PM",
        inputId: "n-9",
        checkboxId: "test-9",
        ballId: "b-9",
        symId: "s-9",
      },
    ];
    const HORARIO_KEYS = SLOT_CONFIG.map((config) => config.key);
    const TURNOS = [...HORARIO_KEYS];

    const DAY_MS = 24 * 60 * 60 * 1000;
    const formatNumber = (n) => String(n).padStart(2, "0");
    const normalizeNumeroKey = (value) => {
      const parsed = parseInt(value, 10);
      if (!Number.isNaN(parsed)) {
        const bounded = ((parsed % 100) + 100) % 100; // asegura 0-99
        return formatNumber(bounded);
      }
      const raw = String(value ?? "")
        .trim()
        .replace(/[^0-9]/g, "");
      if (!raw) return "";
      return formatNumber(parseInt(raw.slice(-2), 10));
    };
    let memoryCachedDraws = null;
    let memorySelectedNumero = null;
    let memorySummary = [];
    let memoryGapData = [];
    let memoryGapTimer = null;
    async function getMemoryDraws({ force = false } = {}) {
      if (!memoryCachedDraws || force) {
        memoryCachedDraws = await DB.listDraws({ excludeTest: false });
      }
      return memoryCachedDraws.slice();
    }
    function invalidateMemoryCache() {
      memoryCachedDraws = null;
    }
    const parseISODate = (value) => {
      if (!value) return null;
      const date = new Date(`${value}T00:00:00`);
      return Number.isNaN(date.getTime()) ? null : date;
    };

    function incrementISODate(value, days = 1) {
      if (!value || !Number.isFinite(days)) return value;
      const base = parseISODate(value);
      if (!base) return value;
      const next = new Date(base.getTime() + Math.trunc(days) * DAY_MS);
      if (Number.isNaN(next.getTime())) return value;
      return formatDateISO(next);
    }
    const MONTH_NAMES = [
      "enero",
      "febrero",
      "marzo",
      "abril",
      "mayo",
      "junio",
      "julio",
      "agosto",
      "septiembre",
      "octubre",
      "noviembre",
      "diciembre",
    ];
    const MONTH_ABBR = MONTH_NAMES.map((name) => name.slice(0, 3));
    const DOW_FULL_LABEL = [
      "Domingo",
      "Lunes",
      "Martes",
      "Mi√©rcoles",
      "Jueves",
      "Viernes",
      "S√°bado",
    ];
    const BASELINE_DOW_RATIO = 1 / 7;
    const DEFAULT_RANKING_TURN = TURNOS[TURNOS.length - 1] || TURNOS[0];
    let biasPanelState = {
      dow: null,
      page: 0,
      selected: [],
      rankingTurn: DEFAULT_RANKING_TURN,
      expiresAt: 0,
    };
    const HORARIO_ORDER = { "11AM": 0, "3PM": 1, "9PM": 2 };
    const TRACKING_STORAGE_KEY = "ld-v3-tracking-day";
    const DRAW_CACHE_TTL = 15 * 1000;
    const BIAS_NOTES_STORAGE_KEY = "ld-v3-bias-notes";
    const BIAS_LAST_DOW_KEY = "ld-v3-bias-last-dow";
    const BIAS_TURN_SCHEDULE = {
      "11AM": { hour: 11, minute: 0 },
      "3PM": { hour: 15, minute: 0 },
      "9PM": { hour: 21, minute: 0 },
    };
    const DECEMBER_REMINDER_KEY = "ld-v3-december-reminders";
    let biasLocalStorageWarned = false;
    let biasSessionStorageWarned = false;

    function getBiasStorageProviders() {
      if (typeof window === "undefined") return [];
      const stores = [];
      try {
        if (window.localStorage) stores.push(window.localStorage);
      } catch (err) {
        if (!biasLocalStorageWarned) {
          logWarn("Sesgos: localStorage no disponible", err);
          biasLocalStorageWarned = true;
        }
      }
      try {
        if (window.sessionStorage) stores.push(window.sessionStorage);
      } catch (err) {
        if (!biasSessionStorageWarned) {
          logWarn("Sesgos: sessionStorage no disponible", err);
          biasSessionStorageWarned = true;
        }
      }
      return stores;
    }

    function persistBiasDowPreference(value) {
      if (typeof window === "undefined") return;
      queueUserPreferencesSave({ biasLastDow: value ?? null });
      const stores = getBiasStorageProviders();
      stores.forEach((storage) => {
        if (!storage) return;
        try {
          if (value === null || value === undefined || value === "") {
            storage.removeItem(BIAS_LAST_DOW_KEY);
          } else {
            storage.setItem(BIAS_LAST_DOW_KEY, String(value));
          }
        } catch (err) {
          logWarn("Sesgos: no se pudo guardar el d√≠a preferido", err);
        }
      });
    }

    function readBiasDowPreference() {
      if (userPreferences && Object.prototype.hasOwnProperty.call(userPreferences, "biasLastDow")) {
        const pref = userPreferences.biasLastDow;
        return pref === null || pref === undefined || pref === "" ? null : pref;
      }
      if (typeof window === "undefined") return null;
      const stores = getBiasStorageProviders();
      for (const storage of stores) {
        if (!storage) continue;
        try {
          const value = storage.getItem(BIAS_LAST_DOW_KEY);
          if (value !== null && value !== undefined && value !== "") return value;
        } catch (err) {
          logWarn("Sesgos: no se pudo leer el d√≠a preferido", err);
        }
      }
      return null;
    }

    let trackingState = loadTrackingState();
    let drawsCache = null;
    let drawsCacheTs = 0;
    let biasDataInput = {
      perfilMap: null,
      predictions: [],
      draws: [],
      contexto: null,
      patrones: null,
    };
    let pega3DrawCache = [];
    let pega3ActiveDrawId = null;
    let pega3AnalysisCache = null;
    const formatFriendlyDate = (value) => {
      if (!value) return "";
      const date =
        value instanceof Date
          ? value
          : typeof value === "string"
            ? parseISODate(value)
            : null;
      if (!(date instanceof Date) || Number.isNaN(date.getTime())) {
        return typeof value === "string" ? value : "";
      }
      const day = date.getDate();
      const monthName = MONTH_NAMES[date.getMonth()] || "";
      const year = date.getFullYear();
      const dow = DOW_FULL_LABEL[date.getDay()] || "";
      return `${dow ? `${dow} ` : ""}${day} de ${monthName} ${year}`;
    };
    const formatShortDate = (iso) => {
      if (!iso) return "";
      const date = parseISODate(iso);
      if (!(date instanceof Date) || Number.isNaN(date.getTime())) return iso;
      const day = String(date.getDate()).padStart(2, "0");
      const month = MONTH_ABBR[date.getMonth()] || "";
      return `${day} ${month}`;
    };
    const formatWindowRange = (startIso, endIso) => {
      const start = formatShortDate(startIso);
      const end = formatShortDate(endIso);
      if (start && end) {
        if (start === end) return start;
        return `${start} ‚Äì ${end}`;
      }
      return start || end || "‚Äî";
    };
    function loadDecemberReminderStore() {
      if (userPreferences?.decemberReminders && typeof userPreferences.decemberReminders === "object") {
        return { ...userPreferences.decemberReminders };
      }
      if (typeof window === "undefined" || typeof window.localStorage === "undefined") return {};
      try {
        const raw = window.localStorage.getItem(DECEMBER_REMINDER_KEY);
        if (!raw) return {};
        const parsed = JSON.parse(raw);
        return parsed && typeof parsed === "object" ? parsed : {};
      } catch (err) {
        logWarn("No se pudieron cargar recordatorios de diciembre", err);
        return {};
      }
    }

    function saveDecemberReminderStore(store) {
      const isEmpty = !store || !Object.keys(store).length;
      if (typeof window !== "undefined" && typeof window.localStorage !== "undefined") {
        try {
          if (isEmpty) {
            window.localStorage.removeItem(DECEMBER_REMINDER_KEY);
          } else {
            window.localStorage.setItem(DECEMBER_REMINDER_KEY, JSON.stringify(store));
          }
        } catch (err) {
          logWarn("No se pudieron guardar recordatorios de diciembre", err);
        }
      }
      queueUserPreferencesSave({ decemberReminders: isEmpty ? {} : store });
    }

    const getSymbol = (numero) => {
      const key = normalizeNumeroKey(numero);
      const rawKey = (numero ?? "").toString().trim();
      const candidates = [key, rawKey, formatNumber(rawKey)];
      for (const cand of candidates) {
        if (!cand) continue;
        const entry = GUIA[cand];
        if (entry?.simbolo) return entry.simbolo;
      }
      return "";
    };
    const getInverseNumero = (numero) => {
      const normalized = normalizeNumeroKey(numero);
      if (!normalized) return null;
      const reversed = normalized.split("").reverse().join("");
      const value = parseInt(reversed, 10);
      if (Number.isNaN(value)) return null;
      return { numero: value, symbol: getSymbol(value) || "" };
    };

    function loadTrackingState() {
      if (userPreferences?.trackingState?.fecha) return userPreferences.trackingState;
      if (typeof window === "undefined" || typeof window.localStorage === "undefined") {
        return null;
      }
      try {
        const raw = window.localStorage.getItem(TRACKING_STORAGE_KEY);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!parsed?.fecha) return null;
        return parsed;
      } catch (err) {
        logWarn("load tracking state failed", err);
        return null;
      }
    }

    function saveTrackingState(state) {
      queueUserPreferencesSave({ trackingState: state || null });
      if (typeof window === "undefined" || typeof window.localStorage === "undefined") {
        return;
      }
      try {
        if (!state) {
          window.localStorage.removeItem(TRACKING_STORAGE_KEY);
        } else {
          window.localStorage.setItem(TRACKING_STORAGE_KEY, JSON.stringify(state));
        }
      } catch (err) {
        logWarn("save tracking state failed", err);
      }
    }

    function getRecencyWarnTs() {
      if (userPreferences && Object.prototype.hasOwnProperty.call(userPreferences, "recencyWarnTs")) {
        return userPreferences.recencyWarnTs || 0;
      }
      if (typeof window === "undefined" || typeof window.localStorage === "undefined") return 0;
      return parseInt(localStorage.getItem("recencyWarnTs"), 10) || 0;
    }

    function setRecencyWarnTs(value) {
      queueUserPreferencesSave({ recencyWarnTs: value || null });
      if (typeof window === "undefined" || typeof window.localStorage === "undefined") return;
      try {
        if (!value) {
          localStorage.removeItem("recencyWarnTs");
        } else {
          localStorage.setItem("recencyWarnTs", String(value));
        }
      } catch (err) {
        logWarn("No se pudo persistir recencyWarnTs", err);
      }
    }

    function computeBiasNoteExpiry(turno = DEFAULT_RANKING_TURN) {
      const schedule = BIAS_TURN_SCHEDULE[turno] || BIAS_TURN_SCHEDULE["9PM"] || { hour: 21, minute: 0 };
      const now = new Date();
      const target = new Date(now);
      target.setHours(schedule.hour, schedule.minute || 0, 0, 0);
      if (target <= now) target.setDate(target.getDate() + 1);
      target.setMinutes(target.getMinutes() + 5);
      return target.getTime();
    }

    function loadBiasNotesStore() {
      if (userPreferences?.biasNotesStore && typeof userPreferences.biasNotesStore === "object") {
        return { ...userPreferences.biasNotesStore };
      }
      const stores = getBiasStorageProviders();
      if (!stores.length) return {};
      let fallbackRaw = null;
      let fallbackData = null;
      let sourceIndex = -1;
      for (let i = 0; i < stores.length; i += 1) {
        const storage = stores[i];
        if (!storage) continue;
        try {
          const raw = storage.getItem(BIAS_NOTES_STORAGE_KEY);
          if (!raw) continue;
          const parsed = JSON.parse(raw);
          if (parsed && typeof parsed === "object") {
            fallbackRaw = raw;
            fallbackData = parsed;
            sourceIndex = i;
            break;
          }
        } catch (err) {
          logWarn("No se pudo cargar apuntes de sesgos", err);
        }
      }
      if (fallbackData && sourceIndex > 0) {
        for (let i = 0; i < sourceIndex; i += 1) {
          const storage = stores[i];
          if (!storage) continue;
          try {
            storage.setItem(BIAS_NOTES_STORAGE_KEY, fallbackRaw);
          } catch (err) {
            logWarn("No se pudo sincronizar apuntes guardados", err);
          }
        }
      }
      return fallbackData || {};
    }

    function saveBiasNotesStore(store) {
      const stores = getBiasStorageProviders();
      const hasStores = stores.length > 0;
      const isEmpty = !store || !Object.keys(store).length;
      let serialized = "";
      if (!isEmpty) {
        try {
          serialized = JSON.stringify(store);
        } catch (err) {
          logWarn("No se pudo serializar apuntes de sesgos", err);
          return;
        }
      }
      if (hasStores) {
        stores.forEach((storage) => {
          if (!storage) return;
          try {
            if (isEmpty) {
              storage.removeItem(BIAS_NOTES_STORAGE_KEY);
            } else {
              storage.setItem(BIAS_NOTES_STORAGE_KEY, serialized);
            }
          } catch (err) {
            logWarn("No se pudo guardar apuntes de sesgos", err);
          }
        });
      }
      queueUserPreferencesSave({ biasNotesStore: isEmpty ? {} : store });
    }

    function cleanupBiasNotesStore(store = {}) {
      const now = Date.now();
      let dirty = false;
      Object.keys(store).forEach((key) => {
        const entry = store[key];
        if (!entry || (entry.expiresAt && entry.expiresAt < now)) {
          delete store[key];
          dirty = true;
        }
      });
      return dirty;
    }

    function getBiasNotesForDow(dow) {
      if (!Number.isFinite(dow)) return null;
      const store = loadBiasNotesStore();
      const key = `dow-${dow}`;
      const entry = store[key];
      if (!entry) return null;
      if (entry.expiresAt && entry.expiresAt < Date.now()) {
        delete store[key];
        saveBiasNotesStore(store);
        return null;
      }
      return entry;
    }

    function persistBiasNotesForDow(dow, state = {}) {
      if (!Number.isFinite(dow)) return;
      const store = loadBiasNotesStore();
      const key = `dow-${dow}`;
      const selected = Array.isArray(state.selected) ? state.selected : [];
      const rankingTurn = state.rankingTurn || DEFAULT_RANKING_TURN;
      if (!selected.length) {
        if (store[key]) {
          delete store[key];
          cleanupBiasNotesStore(store);
          saveBiasNotesStore(store);
        }
        return;
      }
      persistBiasDowPreference(dow);
      const expiresAt = computeBiasNoteExpiry(rankingTurn);
      const storedSelected = selected.map((entry) => ({
        ...entry,
        turnBreakdown: Array.isArray(entry.turnBreakdown)
          ? entry.turnBreakdown.map((turn) => ({ ...turn }))
          : [],
      }));
      store[key] = {
        dow,
        selected: storedSelected,
        rankingTurn,
        expiresAt,
        savedAt: Date.now(),
      };
      cleanupBiasNotesStore(store);
      saveBiasNotesStore(store);
    }

    function syncBiasNotesPersistence(dow) {
      if (!Number.isFinite(dow)) return;
      const selected = Array.isArray(biasPanelState?.selected) ? biasPanelState.selected : [];
      const rankingTurn = biasPanelState?.rankingTurn || DEFAULT_RANKING_TURN;
      if (selected.length) {
        biasPanelState.expiresAt = computeBiasNoteExpiry(rankingTurn);
      } else {
        biasPanelState.expiresAt = 0;
      }
      persistBiasNotesForDow(dow, { selected, rankingTurn });
    }

    async function getCachedDraws({ force = false } = {}) {
      const now = Date.now();
      if (!drawsCache || force || now - drawsCacheTs > DRAW_CACHE_TTL) {
        drawsCache = await DB.listDraws({ excludeTest: true });
        drawsCacheTs = now;
      }
      return drawsCache.slice();
    }

    function invalidateDrawCache() {
      drawsCache = null;
    }

    const OPERACION_LABELS = {
      "": "",
      mirror: "Invertir",
      "sum-digits": "Suma d√≠gitos",
      "sum-digits-keep-first": "Suma d√≠gitos (mantiene)",
      "add-constant": "+Constante",
      "sub-constant": "-Constante",
      neighbor: "Ajuste ¬±1",
      "digit-map": "Mapa d√≠gitos",
    };

    function formatSampleDisplay(sample = {}) {
      const { fecha, horario } = sample;
      if (!fecha) return "";
      const formatted = formatFriendlyDate(fecha);
      return `${formatted}${horario ? ` ${horario}` : ""}`.trim();
    }

    const getFilters = () => ({
      fecha: document.getElementById("day-fecha")?.value,
      pais: document.getElementById("day-pais")?.value,
    });

    function pickDraw(draws, fecha, pais, horario) {
      if (!fecha || !pais) return null;
      const matching = draws
        .filter((d) => d.fecha === fecha && d.pais === pais && d.horario === horario)
        .sort((a, b) => (a.createdAt || 0) - (b.createdAt || 0));
      if (!matching.length) return null;
      return matching
        .slice()
        .reverse()
        .find((d) => !d.isTest) ?? matching[matching.length - 1];
    }

    function formatBallContent(numero, symbol) {
      const numHtml = `<span class="ball-number">${numero}</span>`;
      const symHtml = symbol ? `<span class="ball-symbol">${symbol}</span>` : "";
      return `${numHtml}${symHtml}`;
    }

    function applyDrawToSlot(config, draw) {
      const ball = document.getElementById(config.ballId);
      const sym = document.getElementById(config.symId);
      if (!ball || !sym) return;
      if (!draw) {
        ball.innerHTML = formatBallContent("--", "");
        ball.classList.remove("small");
        ball.removeAttribute("data-numero");
        ball.style.borderColor = "";
        ball.style.color = "";
        sym.textContent = "";
        sym.removeAttribute("title");
        return;
      }
      const numero = formatNumber(draw.numero);
      const color = getColorPolaridad(draw.numero);
      const symbol = getSymbol(draw.numero);
      ball.innerHTML = formatBallContent(numero, symbol);
      ball.dataset.numero = numero;
      ball.classList.toggle("small", !!draw.isTest);
      ball.style.borderColor = color;
      ball.style.color = color;
      sym.textContent = "";
      sym.title = draw.isTest ? "Modo prueba" : symbol || "";
    }

    async function refreshSlots() {
      const { fecha, pais } = getFilters();
      const draws = await DB.listDraws({ excludeTest: false });
      SLOT_CONFIG.forEach((config) => {
        const draw = pickDraw(draws, fecha, pais, config.key);
        applyDrawToSlot(config, draw);
      });
    }

    const saveDayBtn = document.getElementById("save-day");
    saveDayBtn?.addEventListener("click", async () => {
      const { fecha, pais } = getFilters();
      if (!fecha || !pais) {
        showToast("Selecciona fecha y pa√≠s antes de guardar.", { variant: "warning" });
        return;
      }

      const payloads = [];
      for (const config of SLOT_CONFIG) {
        const input = document.getElementById(config.inputId);
        const raw = input?.value.trim() ?? "";
        if (!raw) continue;
        if (!/^\d{1,2}$/.test(raw)) {
          showToast(`N√∫mero inv√°lido en ${config.key}. Usa formato 00-99.`, { variant: "warning" });
          input?.focus();
          return;
        }
        const numero = parseInt(raw, 10);
        if (numero < 0 || numero > 99) {
          showToast(`El n√∫mero en ${config.key} debe estar entre 00 y 99.`, { variant: "warning" });
          input?.focus();
          return;
        }
        const symbol = getSymbol(numero);
        if (!symbol) {
          showToast(`El n√∫mero ${formatNumber(numero)} no tiene s√≠mbolo registrado. Revisa la gu√≠a antes de guardarlo.`, {
            variant: "danger",
          });
          input?.focus();
          return;
        }

        const testCheck = document.getElementById(config.checkboxId);
        payloads.push({ config, numero, input, testCheck, isTest: !!testCheck?.checked });
      }

      if (!payloads.length) {
        showToast("Ingresa al menos un n√∫mero antes de guardar.", { variant: "warning" });
        return;
      }

      const endBusy = withButtonBusy(saveDayBtn, "Guardando‚Ä¶");
      try {
        await runWithSavingModal(async () => {
          for (const { config, numero, isTest } of payloads) {
            const opts = isTest ? { source: "test" } : {};
            await importarManual({ fecha, pais, horario: config.key, numero }, opts);
          }
        });

        payloads.forEach(({ input, testCheck }) => {
          if (input) input.value = "";
          if (testCheck) testCheck.checked = false;
        });

        await refreshSlots();
        autoFollowIfToday(fecha, pais);
        await handleDrawsMutated();
        const aprendizajeResult = await procesarAprendizajeDia({
          fecha,
          pais,
          silent: true,
          skipKnowledgeSync: true,
        });
        await rebuildKnowledge();
        await refreshHypotesis();

        const detail = payloads
          .map(({ config, numero }) => `${config.key} ${formatNumber(numero)}`)
          .join(" ¬∑ ");
        let toastMessage = `Se guardaron ${payloads.length} sorteo(s): ${detail}.`;
        if (aprendizajeResult.status === "success") {
          toastMessage += " Se registraron los resultados para aprendizaje.";
        } else if (aprendizajeResult.status === "already") {
          toastMessage += " El aprendizaje ya estaba registrado previamente.";
        }
        showToast(toastMessage, { variant: "success" });
        autoAdvanceDayFecha();
      } catch (err) {
        console.error("saveDay error", err);
        showToast(`No se pudieron guardar los sorteos: ${err.message}`, { variant: "danger" });
        throw err;
      } finally {
        endBusy();
      }
    });

    saveDayBtn?.addEventListener("click", () => {
      updateCountdownDisplay();
    });

    // === FUNCIONALIDAD: "Agregar hip√≥tesis para (hora)" ===
    document.querySelectorAll(".ghost[data-hypo]").forEach((btn) => {
      btn.addEventListener("click", async () => {
        const turno = btn.dataset.hypo;
        const { fecha, pais } = getFilters();
        if (!fecha || !pais) {
          mostrarAviso("Selecciona fecha y pa√≠s antes de agregar una hip√≥tesis.", { variant: "warning" });
          return;
        }

        // Crear peque√±o modal inline
        const modal = document.getElementById("sys-modal");
        const tEl = document.getElementById("modal-title");
        const mEl = document.getElementById("modal-msg");
        const okBtn = document.getElementById("modal-ok");
        const cancelBtn = document.getElementById("modal-cancel");

        tEl.textContent = `Hip√≥tesis para ${turno}`;
        mEl.innerHTML = `
      <label>Fecha: ${fecha}</label><br/>
      <label>Turno: ${turno}</label><br/>
      <label>N√∫mero: <input id="modal-num" type="number" min="0" max="99" style="width:60px"/></label><br/>
      <label>Raz√≥n: <textarea id="modal-text" rows="3" style="width:100%;margin-top:6px"></textarea></label>
    `;
        okBtn.textContent = "Guardar";
        cancelBtn.textContent = "Cancelar";
        modal.classList.remove("hidden");

        okBtn.onclick = async () => {
          const numeroRaw = document.getElementById("modal-num")?.value.trim() ?? "";
          const texto = document.getElementById("modal-text")?.value.trim() ?? "";
          if (!/^\d{1,2}$/.test(numeroRaw)) {
            mostrarAviso("Ingresa un n√∫mero v√°lido (00‚Äì99).", { variant: "warning" });
            return;
          }
          const numero = parseInt(numeroRaw, 10);
          const simbolo = getSymbol(numero);
          try {
            await crearHipotesis(numero, simbolo, texto, { fecha, turno });
            mostrarAviso(`Hip√≥tesis ${numero} ${simbolo} registrada para ${turno}.`, { variant: "success" });
          } catch (err) {
            console.error("hipo error", err);
            mostrarAviso(`Error al guardar la hip√≥tesis: ${err.message}`, { variant: "danger" });
          } finally {
            modal.classList.add("hidden");
          }
        };

        cancelBtn.onclick = () => {
          modal.classList.add("hidden");
        };
      });
    });
    dayFecha?.addEventListener("change", () => {
      updateDayFechaDow();
      refreshSlots();
      updateCountdownDisplay();
    });
    dayPais?.addEventListener("change", () => {
      refreshSlots();
      updateCountdownDisplay();
    });
    updateDayFechaDow();

    const countdownTargetEl = document.querySelector("[data-countdown-target]");
    const countdownTimerEl = document.querySelector("[data-countdown-timer]");
    const countdownLabelEl = document.querySelector("[data-countdown-label]");
    let countdownInterval = null;

    const TURNO_SCHEDULE = [
      { name: "11AM", hour: 11 },
      { name: "3PM", hour: 15 },
      { name: "9PM", hour: 21 },
    ];

    function getNextDraw() {
      const now = new Date();
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

      for (const draw of TURNO_SCHEDULE) {
        const drawTime = new Date(today);
        drawTime.setHours(draw.hour, 0, 0, 0);
        if (now < drawTime) {
          return { name: draw.name, time: drawTime };
        }
      }

      // If all draws for today are over, get the first draw of tomorrow
      const tomorrow = new Date(today);
      tomorrow.setDate(tomorrow.getDate() + 1);
      const nextDraw = TURNO_SCHEDULE[0];
      const nextDrawTime = new Date(tomorrow);
      nextDrawTime.setHours(nextDraw.hour, 0, 0, 0);
      return { name: nextDraw.name, time: nextDrawTime };
    }

    function updateCountdown() {
      const nextDraw = getNextDraw();

      if (countdownLabelEl) {
        countdownLabelEl.textContent = `Pr√≥ximo Sorteo: ${nextDraw.name}`;
      }

      if (countdownTargetEl) {
        const options = { hour: '2-digit', minute: '2-digit' };
        countdownTargetEl.textContent = nextDraw.time.toLocaleTimeString('es-ES', options);
      }

      if (countdownInterval) {
        clearInterval(countdownInterval);
      }

      countdownInterval = setInterval(() => {
        const now = new Date();
        const diff = nextDraw.time - now;

        if (diff <= 0) {
          clearInterval(countdownInterval);
          // Update to the next draw when the countdown finishes
          setTimeout(updateCountdown, 1000);
          return;
        }

        const hours = Math.floor(diff / (1000 * 60 * 60));
        const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((diff % (1000 * 60)) / 1000);

        if (countdownTimerEl) {
          countdownTimerEl.textContent =
            `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }
      }, 1000);
    }

    updateCountdown();

    function updateCountdownDisplay() {
      try {
        updateCountdown();
      } catch (err) {
        console.error("countdown update error", err);
      }
    }

    // === Paneles extendidos: historial, seguimiento, patrones y ranking ===
    const historyDateInput = document.getElementById("history-date");
    const historyHourSelect = document.getElementById("history-hour");
    const historyCountrySelect = document.getElementById("history-country");
    const historyLimitSelect = document.getElementById("history-limit");
    const historyTableWrap = document.getElementById("history-table");
    const historySummary = document.getElementById("history-summary");
    const historyCoveragePanel = document.getElementById("history-coverage");
    const historySearchBtn = document.getElementById("history-search");
    const historyClearBtn = document.getElementById("history-clear");
    const historyRefreshBtn = document.getElementById("history-refresh");

    const trackingDateInput = document.getElementById("tracking-date");
    const trackingPaisSelect = document.getElementById("tracking-country");
    const trackingGrid = document.getElementById("tracking-grid");
    const trackingViewBtn = document.getElementById("tracking-view");
    const trackingPinBtn = document.getElementById("tracking-pin");

    const patternsSummary = document.getElementById("patterns-summary");
    const patternsHallazgos = document.getElementById("patterns-hallazgos");
    const patternsHistory = document.getElementById("patterns-history");
    const decemberCard = document.getElementById("december-card");
    const decemberYearSelect = document.getElementById("december-year");
    const decemberSearchInput = document.getElementById("december-search");
    const decemberSearchBtn = document.getElementById("december-search-btn");
    const decemberClearBtn = document.getElementById("december-clear");
    const decemberRefreshBtn = document.getElementById("december-refresh");
    const decemberSummaryEl = document.getElementById("december-summary");
    const decemberWatchlistEl = document.getElementById("december-watchlist");
    const decemberDetailEl = document.getElementById("december-detail");
    const decemberRemindersEl = document.getElementById("december-reminders");
    const strategyRefreshBtn = document.getElementById("strategy-refresh");
    const strategiesList = document.getElementById("strategies-list");
    const strategiesSection = document.getElementById("view-strategies");
    const strategyTurnChips = document.querySelectorAll("[data-strategy-turn]");
    const strategyOperatorChips = document.querySelectorAll("[data-strategy-operator]");
    const strategyResetBtn = document.getElementById("strategy-reset");
    let allowStrategyAutoRender = true;
    const strategyFilters = {
      turns: new Set(HORARIO_KEYS),
      operators: new Set(["+", "‚àí"]),
    };

    strategyRefreshBtn?.addEventListener("click", () => {
      renderStrategiesPanel({ force: true });
    });

    function setStrategyChipState(chip, active) {
      chip.classList.toggle("active", active);
    }

    function renderStrategyFilters() {
      strategyTurnChips.forEach((chip) => {
        const turno = chip.dataset.strategyTurn;
        if (!turno) return;
        setStrategyChipState(chip, strategyFilters.turns.has(turno));
      });
      strategyOperatorChips.forEach((chip) => {
        const op = chip.dataset.strategyOperator;
        if (!op) return;
        setStrategyChipState(chip, strategyFilters.operators.has(op));
      });
    }

    strategyTurnChips.forEach((chip) => {
      chip.addEventListener("click", () => {
        const turno = chip.dataset.strategyTurn;
        if (!turno) return;
        if (strategyFilters.turns.has(turno)) {
          if (strategyFilters.turns.size === 1) return;
          strategyFilters.turns.delete(turno);
        } else {
          strategyFilters.turns.add(turno);
        }
        renderStrategyFilters();
        renderStrategiesPanel();
      });
    });

    strategyOperatorChips.forEach((chip) => {
      chip.addEventListener("click", () => {
        const op = chip.dataset.strategyOperator;
        if (!op) return;
        if (strategyFilters.operators.has(op)) {
          if (strategyFilters.operators.size === 1) return;
          strategyFilters.operators.delete(op);
        } else {
          strategyFilters.operators.add(op);
        }
        renderStrategyFilters();
        renderStrategiesPanel();
      });
    });

    strategyResetBtn?.addEventListener("click", () => {
      strategyFilters.turns = new Set(HORARIO_KEYS);
      strategyFilters.operators = new Set(["+", "‚àí"]);
      renderStrategyFilters();
      renderStrategiesPanel();
    });
    renderStrategyFilters();

    const describeDecemberTurns = (turnHints = []) => {
      if (!Array.isArray(turnHints) || !turnHints.length) return "";
      const [first] = turnHints;
      if (!first?.pair) return "";
      const label = first.pair.replace("->", " ‚Üí ");
      const parts = [];
      if (first.count) {
        parts.push(`${first.count} ${first.count === 1 ? "evento" : "eventos"}`);
      }
      if (first.weight) {
        parts.push(`${Math.round(first.weight * 100)}%`);
      }
      if (!parts.length) return label;
      return `${label} ¬∑ ${parts.join(" ¬∑ ")}`;
    };

    const describeWatcherStatus = (watcher) => {
      if (!watcher) {
        return {
          label: "Seguimiento",
          message: "Sin datos suficientes.",
        };
      }
      const windowRange = watcher.activeWindow ? formatWindowRange(watcher.activeWindow.windowStart, watcher.activeWindow.windowEnd) : null;
      const gapLabel = watcher.activeWindow?.gap ? `+${watcher.activeWindow.gap} d√≠as` : "";
      const hitInfo = watcher.activeWindow?.hit;
      switch (watcher.status) {
        case "due":
          return {
            label: "Ventana activa",
            message: `Esperando repetici√≥n entre ${windowRange || "la ventana estimada"} (${gapLabel}).`,
            detail: hitInfo ? `√öltimo impacto: ${formatFriendlyDate(hitInfo.fecha)} ${hitInfo.horario || ""}` : "",
          };
        case "tracking":
          return {
            label: "Escucha temprana",
            message: `La ventana abre el ${windowRange || "pr√≥ximamente"} (${gapLabel}).`,
            detail: "Prepara tus jugadas antes de que se activen los turnos frecuentes.",
          };
        case "hit":
        case "completed":
          return {
            label: watcher.status === "hit" ? "Confirmado" : "Ciclo cerrado",
            message: hitInfo
              ? `Reapareci√≥ el ${formatFriendlyDate(hitInfo.fecha)} en ${hitInfo.horario || "‚Äî"}.`
              : "Repetici√≥n confirmada este a√±o.",
            detail: "Revisa si suele encadenar otra aparici√≥n despu√©s de este punto.",
          };
        case "missed":
          return {
            label: "Ventana perdida",
            message: `No se present√≥ en la ventana ${windowRange || ""}.`,
            detail: "Observa si abre un nuevo ciclo antes de cerrar el mes.",
          };
        case "origin":
        default:
          return {
            label: "Nuevo en diciembre",
            message: "A√∫n sin repetici√≥n. Sigue la l√≠nea para detectar el primer regreso.",
            detail: "",
          };
      }
    };

    const WATCH_TURN_LABELS = {
      "11AM": "11 AM",
      "3PM": "3 PM",
      "9PM": "9 PM",
    };
    const MAX_WATCH_SCHEDULE_DAYS = 7;
    const formatWatchDayLabel = (date) => {
      if (!(date instanceof Date) || Number.isNaN(date.getTime())) return "";
      const dowLabel = DOW_FULL_LABEL[date.getDay()] || "";
      const shortDow = dowLabel ? `${dowLabel.slice(0, 3)}.` : "";
      const day = String(date.getDate()).padStart(2, "0");
      const month = MONTH_ABBR[date.getMonth()] || "";
      return `${shortDow ? `${shortDow} ` : ""}${day} ${month}`.trim();
    };
    const getWatcherHighlightTurns = (watcher) => {
      const highlights = new Set();
      const turnHints = watcher?.activeWindow?.turnHints || [];
      turnHints.forEach((hint) => {
        if (!hint?.pair) return;
        const [, toTurn] = hint.pair.split("->");
        const normalized = (toTurn || "").trim();
        if (normalized && HORARIO_KEYS.includes(normalized)) {
          highlights.add(normalized);
        }
      });
      const hitTurn = watcher?.activeWindow?.hit?.horario;
      if (hitTurn && HORARIO_KEYS.includes(hitTurn)) {
        highlights.add(hitTurn);
      }
      return highlights;
    };
    const buildWatcherSchedule = (watcher) => {
      if (!watcher?.activeWindow) {
        return "<div class='december-watch__schedule'><div class='december-watch__schedule-empty'>A√∫n sin ventana estimada para este n√∫mero.</div></div>";
      }
      const startIso = watcher.activeWindow.windowStart || watcher.activeWindow.expectedDate;
      const endIso = watcher.activeWindow.windowEnd || watcher.activeWindow.windowStart || watcher.activeWindow.expectedDate;
      const startDate = parseISODate(startIso);
      const endDate = parseISODate(endIso);
      if (!(startDate instanceof Date) || Number.isNaN(startDate.getTime()) || !(endDate instanceof Date) || Number.isNaN(endDate.getTime())) {
        return "<div class='december-watch__schedule'><div class='december-watch__schedule-empty'>No se pudo dibujar el calendario de esta ventana.</div></div>";
      }
      const days = [];
      let cursor = new Date(startDate);
      let guard = 0;
      while (cursor.getTime() <= endDate.getTime() && guard < MAX_WATCH_SCHEDULE_DAYS) {
        days.push({
          label: formatWatchDayLabel(cursor),
        });
        cursor = new Date(cursor.getTime() + DAY_MS);
        guard += 1;
      }
      if (!days.length) {
        days.push({ label: formatWatchDayLabel(startDate) });
      }
      const highlights = getWatcherHighlightTurns(watcher);
      const dayBlocks = days
        .map((day) => `
          <div class="december-watch__day">
            <div class="december-watch__day-label">${day.label}</div>
            <div class="december-watch__turns">
              ${HORARIO_KEYS.map((turno) => {
                const activeClass = highlights.has(turno) ? "is-highlighted" : "";
                return `<span class="december-watch__turn ${activeClass}">${WATCH_TURN_LABELS[turno] || turno}</span>`;
              }).join("")}
            </div>
          </div>
        `)
        .join("");
      const toleranceText =
        Number.isFinite(watcher.activeWindow?.gap) && Number.isFinite(watcher.activeWindow?.tolerance)
          ? `+${watcher.activeWindow.gap}d ¬∑ ¬±${watcher.activeWindow.tolerance}d`
          : "";
      const rangeLabel = formatWindowRange(startIso, endIso);
      return `
        <div class="december-watch__schedule">
          <div class="december-watch__schedule-head">
            <span>${rangeLabel && rangeLabel !== "‚Äî" ? `Ventana ${rangeLabel}` : "Ventana estimada"}</span>
            ${toleranceText ? `<span class="hint small">${toleranceText}</span>` : ""}
          </div>
          <div class="december-watch__calendar">${dayBlocks}</div>
        </div>
      `;
    };

    function syncDecemberYearOptions() {
      if (!decemberYearSelect) return;
      const years = decemberStrategyData?.years || [];
      decemberYearSelect.innerHTML = "";
      if (!years.length) {
        const option = document.createElement("option");
        option.value = "";
        option.textContent = "‚Äî";
        decemberYearSelect.appendChild(option);
        decemberYearSelect.disabled = true;
        decemberSelectedYear = null;
        return;
      }
      decemberYearSelect.disabled = false;
      years.forEach((year) => {
        const option = document.createElement("option");
        option.value = String(year);
        option.textContent = year;
        if (year === decemberSelectedYear) option.selected = true;
        decemberYearSelect.appendChild(option);
      });
      if (!decemberSelectedYear) {
        decemberSelectedYear = years[0];
        decemberYearSelect.value = years[0];
      }
    }

    function renderDecemberSummary() {
      if (!decemberSummaryEl) return;
      if (!decemberStrategyData?.summary) {
        decemberSummaryEl.innerHTML = "<span class='hint'>Registra sorteos de diciembre para iniciar el seguimiento.</span>";
        return;
      }
      const { totalNumbers = 0, totalRepeats = 0, draws = 0, yearsTracked = 0 } = decemberStrategyData.summary;
      decemberSummaryEl.innerHTML = `
        <strong>${totalNumbers}</strong> n√∫meros vigilados ¬∑
        <strong>${totalRepeats}</strong> repeticiones identificadas ¬∑
        ${yearsTracked} a√±o(s) analizados (${draws} sorteos de diciembre)
      `;
    }

    function renderDecemberWatchlist() {
      if (!decemberWatchlistEl) return;
      decemberWatchlistEl.innerHTML = "";
      if (!decemberStrategyData || !decemberSelectedYear) {
        decemberWatchlistEl.innerHTML = "<p class='december-empty'>Selecciona un a√±o con datos para ver la vigilancia.</p>";
        return;
      }
      const watchers =
        decemberStrategyData.watchersByYear?.get(decemberSelectedYear) || [];
      if (!watchers.length) {
        decemberWatchlistEl.innerHTML = "<p class='december-empty'>Este a√±o todav√≠a no registra repeticiones en diciembre.</p>";
        return;
      }
      const selectedExists = watchers.some((watcher) => watcher.numero === decemberSelectedNumero);
      if (!selectedExists) {
        decemberSelectedNumero = watchers[0]?.numero ?? null;
      }
      watchers.forEach((watcher) => {
        const item = document.createElement("button");
        item.type = "button";
        const statusClass = watcher.status ? `december-watch--${watcher.status}` : "";
        const activeClass = watcher.numero === decemberSelectedNumero ? "december-watch--active" : "";
        item.className = `december-watch ${statusClass} ${activeClass}`.trim();
        item.dataset.decemberNum = watcher.numero;
        const badgeClass = `december-badge december-badge--${watcher.status || "origin"}`;
        const statusInfo = describeWatcherStatus(watcher);
        const badgeLabel = statusInfo.label;
        const turnHint = describeDecemberTurns(watcher.activeWindow?.turnHints);
        const scheduleMarkup = buildWatcherSchedule(watcher);
        item.innerHTML = `
          <div class="december-watch__number">
            <span>${formatNumber(watcher.numero)}</span>
            <span class="december-watch__symbol">${watcher.symbol || ""}</span>
          </div>
          <div class="december-watch__status">
            <span class="${badgeClass}">${badgeLabel}</span>
            <span class="december-status-line">${statusInfo.message}</span>
            ${statusInfo.detail ? `<small>${statusInfo.detail}</small>` : ""}
            ${turnHint ? `<small>${turnHint}</small>` : ""}
          </div>
          ${scheduleMarkup}
        `;
        decemberWatchlistEl.appendChild(item);
      });
    }

    function renderDecemberReminders() {
      if (!decemberRemindersEl) return;
      const entries = Object.values(decemberReminderStore || {}).sort(
        (a, b) => (b.createdAt || 0) - (a.createdAt || 0)
      );
      if (!entries.length) {
        decemberRemindersEl.innerHTML =
          "<p class='december-empty'>Sin recordatorios activos. Puedes guardar un n√∫mero desde el panel de detalle.</p>";
        return;
      }
      const head = document.createElement("div");
      head.className = "december-panel-head";
      head.innerHTML = `
        <h4>Recordatorios activos</h4>
        <p class="hint small">Se guardan localmente y en tus preferencias.</p>
      `;
      const list = document.createElement("div");
      list.className = "december-reminders__list";
      entries.forEach((item) => {
        const row = document.createElement("div");
        row.className = "december-reminder";
        row.innerHTML = `
          <div>
            <strong>${formatNumber(item.numero)}</strong> <span>${item.symbol || ""}</span>
            <div class="hint small">${item.note || ""}</div>
          </div>
        `;
        const removeBtn = document.createElement("button");
        removeBtn.type = "button";
        removeBtn.textContent = "Quitar";
        removeBtn.addEventListener("click", () => {
          const key = formatNumber(item.numero);
          if (decemberReminderStore[key]) {
            delete decemberReminderStore[key];
            saveDecemberReminderStore(decemberReminderStore);
            renderDecemberReminders();
            renderDecemberWatchlist();
            if (decemberSelectedNumero === item.numero) renderDecemberDetail();
          }
        });
        row.appendChild(removeBtn);
        list.appendChild(row);
      });
      decemberRemindersEl.innerHTML = "";
      decemberRemindersEl.append(head, list);
    }

    function renderDecemberDetail() {
      if (!decemberDetailEl) return;
      decemberDetailEl.innerHTML = "";
      if (!decemberStrategyData || decemberSelectedNumero === null || decemberSelectedNumero === undefined) {
        decemberDetailEl.innerHTML = "<p class='hint'>Selecciona un n√∫mero para ver su seguimiento de diciembre.</p>";
        return;
      }
      const entry = decemberStrategyData.perNumber?.get(decemberSelectedNumero);
      if (!entry) {
        decemberDetailEl.innerHTML = `<p class='hint'>El n√∫mero ${formatNumber(decemberSelectedNumero)} no tiene historial de diciembre.</p>`;
        return;
      }
      const watcher =
        decemberStrategyData.watchersByYear?.get(decemberSelectedYear)?.find(
          (item) => item.numero === entry.numero
        ) || null;
      const head = document.createElement("div");
      head.className = "december-detail__head";
      head.innerHTML = `
        <div class="december-detail__number">
          <span>${formatNumber(entry.numero)}</span>
          <span>${entry.symbol || ""}</span>
        </div>
        <div class="hint">${entry.history?.length || 0} a√±o(s) con actividad en diciembre.</div>
      `;
      const chips = document.createElement("div");
      chips.className = "december-detail__chips";
      const yearsChip = document.createElement("div");
      yearsChip.className = "december-window-chip";
      yearsChip.innerHTML = `<strong>${entry.history?.length || 0}</strong> a√±os rastreados`;
      const repeatsChip = document.createElement("div");
      repeatsChip.className = "december-window-chip";
      repeatsChip.innerHTML = `<strong>${entry.totalRepeats || 0}</strong> repeticiones hist√≥ricas`;
      chips.append(yearsChip, repeatsChip);
      const windowsWrap = document.createElement("div");
      windowsWrap.className = "december-detail__chips";
      if (entry.windows?.length) {
        entry.windows.slice(0, 3).forEach((window) => {
          const chip = document.createElement("div");
          chip.className = "december-window-chip";
          const repeatsLabel =
            window.count === 1 ? "1 repetici√≥n registrada" : `${window.count || 0} repeticiones registradas`;
          const example = window.examples?.[0];
          const exampleText =
            example && example.from?.fecha && example.to?.fecha
              ? `${formatFriendlyDate(example.from.fecha)} ¬∑ ${example.from.horario || "‚Äî"} ‚Üí ${formatFriendlyDate(example.to.fecha)} ¬∑ ${
                  example.to.horario || "‚Äî"
                }`
              : "";
          const turnHint = window.turnHints?.length ? describeDecemberTurns(window.turnHints) : "";
          chip.innerHTML = `
            <strong>+${window.gap} d√≠as</strong>
            <div class="hint small">${repeatsLabel}</div>
            ${exampleText ? `<div class="hint">Ej: ${exampleText}</div>` : ""}
            ${
              turnHint
                ? `<div class="hint small">Horarios frecuentes: ${turnHint}</div>`
                : ""
            }
            <div class="hint small">Ventana estimada ¬±${window.tolerance || 0}d.</div>
          `;
          windowsWrap.appendChild(chip);
        });
      } else {
        const chip = document.createElement("div");
        chip.className = "december-window-chip";
        chip.textContent = "Sin ventanas suficientes. Espera m√°s repeticiones.";
        windowsWrap.appendChild(chip);
      }
      const actions = document.createElement("div");
      actions.className = "december-detail__actions";
      const reminderKey = formatNumber(entry.numero);
      const reminderActive = Boolean(decemberReminderStore?.[reminderKey]);
      const reminderBtn = document.createElement("button");
      reminderBtn.type = "button";
      reminderBtn.className = reminderActive ? "btn-outline" : "btn-primary";
      reminderBtn.textContent = reminderActive ? "Quitar recordatorio" : "Guardar recordatorio";
      reminderBtn.addEventListener("click", () => {
        toggleDecemberReminder(entry, watcher);
      });
      actions.appendChild(reminderBtn);
      const sequences = document.createElement("div");
      sequences.className = "december-sequences";
      if (Array.isArray(entry.history) && entry.history.length) {
        entry.history
          .slice()
          .sort((a, b) => b.year - a.year)
          .forEach((segment) => {
            const sequence = document.createElement("div");
            sequence.className = "december-sequence";
            const yearLabel = document.createElement("div");
            yearLabel.className = "december-sequence__year";
            yearLabel.textContent = `${segment.year} ¬∑ ${segment.hits.length} aparici√≥n(es)`;
            const timeline = document.createElement("div");
            timeline.className = "december-sequence__timeline";
            segment.hits.forEach((hit, index) => {
              const row = document.createElement("div");
              row.className = "december-timeline__row";
              const title = document.createElement("div");
              title.innerHTML = `<strong>${formatFriendlyDate(hit.fecha)}</strong> ¬∑ ${hit.horario || ""} ${entry.symbol || ""}`;
              const meta = document.createElement("div");
              meta.className = "december-timeline__meta";
              if (index === 0) {
                meta.textContent = "Primer impacto del mes (origen).";
              } else {
                const event = segment.events?.[index - 1];
                const gap = Number.isFinite(event?.gapFromPrev) ? event.gapFromPrev : null;
                meta.textContent = gap
                  ? `Reaparece ${gap === 1 ? "al d√≠a siguiente" : `tras ${gap} d√≠as`}.`
                  : "Reaparece tras varios d√≠as.";
              }
              row.append(title, meta);
              timeline.appendChild(row);
            });
            sequence.append(yearLabel, timeline);
            sequences.appendChild(sequence);
          });
      } else {
        const empty = document.createElement("p");
        empty.className = "december-empty";
        empty.textContent = "Este n√∫mero a√∫n no registra diciembre suficientes para dibujar una secuencia.";
        sequences.appendChild(empty);
      }
      decemberDetailEl.append(head, chips, windowsWrap, actions, sequences);
      if (watcher) {
        const statusInfo = describeWatcherStatus(watcher);
        const status = document.createElement("p");
        status.className = "hint";
        const windowText = watcher.activeWindow
          ? `Ventana ${formatWindowRange(watcher.activeWindow.windowStart, watcher.activeWindow.windowEnd)} (+${watcher.activeWindow.gap || "?"}d)`
          : "";
        status.innerHTML = `<strong>${statusInfo.label}</strong> ¬∑ ${statusInfo.message}${windowText ? ` ¬∑ ${windowText}` : ""}${
          statusInfo.detail ? ` <br />${statusInfo.detail}` : ""
        }`;
        decemberDetailEl.appendChild(status);
      }
    }

    function toggleDecemberReminder(entry, watcher) {
      if (!entry) return;
      const key = formatNumber(entry.numero);
      if (decemberReminderStore[key]) {
        delete decemberReminderStore[key];
      } else {
        const windowInfo = watcher?.activeWindow;
        decemberReminderStore[key] = {
          numero: entry.numero,
          symbol: entry.symbol || "",
          note: windowInfo
            ? `Ventana ${formatWindowRange(windowInfo.windowStart, windowInfo.windowEnd)} (+${windowInfo.gap}d)`
            : "Seguimiento manual",
          createdAt: Date.now(),
          year: decemberSelectedYear,
          windowStart: windowInfo?.windowStart || null,
          windowEnd: windowInfo?.windowEnd || null,
        };
      }
      saveDecemberReminderStore(decemberReminderStore);
      renderDecemberReminders();
      renderDecemberWatchlist();
      renderDecemberDetail();
    }

    function handleDecemberSearch() {
      const raw = (decemberSearchInput?.value || "").trim();
      if (!raw) {
        showToast("Ingresa un n√∫mero para buscar en diciembre.", { variant: "info" });
        return;
      }
      const numero = parseInt(raw, 10);
      if (!Number.isFinite(numero) || numero < 0 || numero > 99) {
        showToast("Ingresa un n√∫mero v√°lido entre 00 y 99.", { variant: "warning" });
        return;
      }
      if (!decemberStrategyData?.perNumber?.has(numero)) {
        showToast(`El n√∫mero ${formatNumber(numero)} a√∫n no aparece en diciembre.`, { variant: "info" });
        return;
      }
      const entry = decemberStrategyData.perNumber.get(numero);
      if (entry?.history?.length) {
        const latestYear = entry.history[entry.history.length - 1].year;
        if (latestYear && latestYear !== decemberSelectedYear) {
          decemberSelectedYear = latestYear;
          syncDecemberYearOptions();
        }
      }
      decemberSelectedNumero = numero;
      renderDecemberWatchlist();
      renderDecemberDetail();
    }

    async function refreshDecemberStrategyPanel({ force = false } = {}) {
      if (!decemberCard) return;
      try {
        const draws = await getCachedDraws({ force });
        if (!draws.length) {
          decemberStrategyData = null;
          decemberSelectedYear = null;
          decemberSelectedNumero = null;
          renderDecemberSummary();
          if (decemberWatchlistEl) {
            decemberWatchlistEl.innerHTML = "<p class='december-empty'>A√∫n no hay sorteos de diciembre cargados.</p>";
          }
          if (decemberDetailEl) {
            decemberDetailEl.innerHTML = "<p class='hint'>Cuando se registren sorteos en diciembre ver√°s aqu√≠ la estrategia.</p>";
          }
          renderDecemberReminders();
          return;
        }
        decemberStrategyData = computeDecemberStrategy(draws, {
          referenceDate: new Date(),
          getSymbol,
        });
        const years = decemberStrategyData?.years || [];
        if (!years.length) {
          decemberSelectedYear = null;
          decemberSelectedNumero = null;
        } else if (!decemberSelectedYear || !years.includes(decemberSelectedYear)) {
          decemberSelectedYear = years[0];
        }
        syncDecemberYearOptions();
        const activeWatchers =
          decemberStrategyData.watchersByYear?.get(decemberSelectedYear) || [];
        if (activeWatchers.length) {
          const hasSelected = activeWatchers.some((watcher) => watcher.numero === decemberSelectedNumero);
          if (!hasSelected) {
            decemberSelectedNumero = activeWatchers[0].numero;
          }
        } else {
          decemberSelectedNumero = null;
        }
        renderDecemberSummary();
        renderDecemberWatchlist();
        renderDecemberDetail();
        renderDecemberReminders();
      } catch (err) {
        console.error("december panel error", err);
        if (decemberSummaryEl) {
          decemberSummaryEl.innerHTML =
            "<span class='text-danger'>No se pudo calcular la estrategia de diciembre. Reintenta m√°s tarde.</span>";
        }
      }
    }

    decemberWatchlistEl?.addEventListener("click", (event) => {
      const item = event.target.closest("[data-december-num]");
      if (!item) return;
      const numero = Number(item.dataset.decemberNum);
      if (!Number.isFinite(numero)) return;
      decemberSelectedNumero = numero;
      renderDecemberWatchlist();
      renderDecemberDetail();
    });

    decemberYearSelect?.addEventListener("change", () => {
      const year = parseInt(decemberYearSelect.value, 10);
      if (!Number.isFinite(year)) return;
      decemberSelectedYear = year;
      renderDecemberWatchlist();
      renderDecemberDetail();
    });

    decemberRefreshBtn?.addEventListener("click", () => {
      refreshDecemberStrategyPanel({ force: true });
    });

    decemberSearchBtn?.addEventListener("click", handleDecemberSearch);
    decemberSearchInput?.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        event.preventDefault();
        handleDecemberSearch();
      }
    });
    decemberClearBtn?.addEventListener("click", () => {
      if (decemberSearchInput) decemberSearchInput.value = "";
      const watchers =
        decemberStrategyData?.watchersByYear?.get(decemberSelectedYear) || [];
      decemberSelectedNumero = watchers[0]?.numero ?? null;
      renderDecemberWatchlist();
      renderDecemberDetail();
    });

    function setNotebookInputs(values = {}) {
      HORARIO_KEYS.forEach((turno) => {
        const input = notebookInputs[turno];
        if (!input) return;
        input.value = values[turno] ?? "";
      });
    }

    notebookFillDayBtn?.addEventListener("click", () => {
      const values = {};
      SLOT_CONFIG.forEach((config) => {
        const input = document.getElementById(config.inputId);
        const val = input?.value.trim();
        values[config.key] = /^\d{1,2}$/.test(val || "") ? val.padStart(2, "0") : "";
      });
      setNotebookInputs(values);
      showToast("N√∫meros copiados del panel del d√≠a.", { variant: "info" });
    });

    notebookFillResultsBtn?.addEventListener("click", async () => {
      try {
        const fecha = notebookFechaInput?.value;
        const pais = notebookPaisSelect?.value || "HN";
        if (!fecha) {
          showToast("Selecciona una fecha para traer los resultados.", { variant: "warning" });
          return;
        }
        const draws = await DB.listDraws({ excludeTest: true });
        const map = {};
        HORARIO_KEYS.forEach((turno) => {
          const draw = pickDraw(draws, fecha, pais, turno);
          map[turno] = draw ? formatNumber(draw.numero) : "";
        });
        setNotebookInputs(map);
        showToast("Resultados guardados cargados en el cuaderno.", { variant: "success" });
      } catch (err) {
        console.error("nb fill results", err);
        showToast(`No se pudieron traer los resultados: ${err.message}`, { variant: "danger" });
      }
    });

    async function refreshNotebookList() {
      if (!notebookList) return;
      const entries = await DB.listNotebookEntries();
      if (!entries.length) {
        notebookList.innerHTML = "<p class='hint'>Todav√≠a no tienes elementos en el cuaderno.</p>";
        return;
      }
      notebookList.innerHTML = "";
      const sortedEntries = entries.slice().reverse();
      sortedEntries.forEach((entry) => {
        const card = document.createElement("article");
        card.className = "notebook-card";
        card.innerHTML = `
          <div class="notebook-card__head">
            <strong>${formatFriendlyDate(entry.fecha)} ¬∑ ${entry.pais || "HN"}</strong>
            <button type="button" class="btn-ghost" data-nb-delete="${entry.id}">Eliminar</button>
          </div>
        `;
        const numbers = document.createElement("div");
        numbers.className = "notebook-card__numbers";
        HORARIO_KEYS.forEach((turno) => {
          const span = document.createElement("span");
          const numberRaw = entry.numeros?.[turno];
          const hasNumber = numberRaw !== undefined && numberRaw !== null && numberRaw !== "";
          const numericValue = hasNumber ? parseInt(numberRaw, 10) : null;
          const formatted = hasNumber && Number.isFinite(numericValue)
            ? formatNumber(numericValue)
            : hasNumber
              ? String(numberRaw)
              : "--";
          const symbol = hasNumber && Number.isFinite(numericValue) ? getSymbol(numericValue) || "" : "";
          span.innerHTML = `
            <small>${turno}</small>
            <strong>${formatted}</strong>
            ${symbol ? `<span class="notebook-card__symbol">${symbol}</span>` : ""}
          `;
          numbers.appendChild(span);
        });
        card.appendChild(numbers);
        const actions = document.createElement("div");
        actions.className = "notebook-card__actions";
        const viewBtn = document.createElement("button");
        viewBtn.type = "button";
        viewBtn.className = "btn-outline";
        viewBtn.textContent = "Ver en panel";
        viewBtn.dataset.nbView = entry.id;
        viewBtn.dataset.fecha = entry.fecha;
        viewBtn.dataset.pais = entry.pais || "";
        actions.appendChild(viewBtn);
        const followBtn = document.createElement("button");
        followBtn.type = "button";
        followBtn.className = "btn-ghost";
        followBtn.textContent = "Seguir";
        followBtn.dataset.nbFollow = entry.id;
        followBtn.dataset.fecha = entry.fecha;
        followBtn.dataset.pais = entry.pais || "";
        actions.appendChild(followBtn);
        card.appendChild(actions);
        notebookList.appendChild(card);
      });
    }

    notebookSaveBtn?.addEventListener("click", async () => {
      const fecha = notebookFechaInput?.value;
      const pais = notebookPaisSelect?.value || "HN";
      if (!fecha) {
        showToast("Selecciona la fecha del tr√≠o que deseas guardar.", { variant: "warning" });
        return;
      }
      const numeros = {};
      let completos = true;
      HORARIO_KEYS.forEach((turno) => {
        const input = notebookInputs[turno];
        const val = input?.value.trim() || "";
        if (!/^\d{2}$/.test(val)) completos = false;
        numeros[turno] = val;
      });
      if (!completos) {
        showToast("Completa los tres sorteos (formato 00-99) antes de guardar.", { variant: "warning" });
        return;
      }
      try {
        await DB.addNotebookEntry({ fecha, pais, numeros });
        showToast("Tr√≠o agregado al cuaderno.", { variant: "success" });
        await refreshNotebookList();
      } catch (err) {
        console.error("nb save error", err);
        showToast(`No se pudo guardar el tr√≠o: ${err.message}`, { variant: "danger" });
      }
    });

    notebookList?.addEventListener("click", async (event) => {
      const delBtn = event.target.closest("[data-nb-delete]");
      if (delBtn) {
        const id = Number(delBtn.dataset.nbDelete);
        await DB.deleteNotebookEntry(id);
        await refreshNotebookList();
        showToast("Entrada retirada del cuaderno.", { variant: "info" });
        return;
      }
      const viewBtn = event.target.closest("[data-nb-view]");
      if (viewBtn) {
        await focusDayPanel(viewBtn.dataset.fecha || null, viewBtn.dataset.pais || null);
        return;
      }
      const followBtn = event.target.closest("[data-nb-follow]");
      if (followBtn) {
        await followStrategyDay(followBtn.dataset.fecha || null, followBtn.dataset.pais || null);
      }
    });

    function navigateToView(key) {
      const btn = document.querySelector(`.sidebar button[data-view="${key}"]`);
      if (btn) {
        btn.click();
      } else {
        document.querySelectorAll(".view").forEach((v) => v.classList.add("hidden"));
        const id = views[key];
        document.getElementById(id)?.classList.remove("hidden");
      }
    }

    async function focusDayPanel(fecha, pais) {
      if (!fecha) return;
      if (dayFecha) {
        dayFecha.value = fecha;
        updateDayFechaDow(fecha);
      }
      if (dayPais && pais) dayPais.value = pais;
      navigateToView("day");
      try {
        await refreshSlots();
        updateCountdownDisplay?.();
      } catch (err) {
        console.error("focus day error", err);
      }
    }

    async function followStrategyDay(fecha, pais) {
      if (!fecha) return;
      trackingState = { fecha, pais: pais || null };
      saveTrackingState(trackingState);
      await renderTrackingPanel({ forceReload: true });
      showToast(`Seguimiento activo para ${formatFriendlyDate(fecha)} ${pais ? `(${pais})` : ""}.`, {
        variant: "success",
      });
    }

    const patternsRefreshBtn = document.getElementById("patterns-refresh");

    const rankingYearSelect = document.getElementById("ranking-year");
    const rankingSearchInput = document.getElementById("ranking-search");
    const rankingSearchBtn = document.getElementById("ranking-search-btn");
    const rankingClearBtn = document.getElementById("ranking-clear-btn");
    const rankingSummaryEl = document.getElementById("ranking-summary");
    const rankingTableWrap = document.getElementById("ranking-table");
    const rankingInsightEl = document.getElementById("ranking-insight");
    const rankingTabButtons = document.querySelectorAll("[data-ranking-tab]");
    const weeklySection = document.getElementById("view-weekly");
    const weeklyPaisSelect = document.getElementById("weekly-pais");
    const weeklyTurnoSelect = document.getElementById("weekly-turno");
    const weeklyWindowInput = document.getElementById("weekly-window");
    const weeklyRepeatsInput = document.getElementById("weekly-min-repeats");
    const weeklySummaryEl = document.getElementById("weekly-summary");
    const weeklyGridEl = document.getElementById("weekly-grid");
    const weeklyRefreshBtn = document.getElementById("weekly-refresh");
    const linesRefreshBtn = document.getElementById("lines-refresh");
    const linesBodyEl = document.getElementById("lines-body");
    const linesMissingRefreshBtn = document.getElementById("lines-missing-refresh");
    const linesMissingBodyEl = document.getElementById("lines-missing-body");
    const abonoFechaInput = document.getElementById("abono-fecha");
    const abonoPaisSelect = document.getElementById("abono-pais");
    const abonoWindowInput = document.getElementById("abono-window");
    const abonoGenerarBtn = document.getElementById("abono-generar");
    const abonoOutput = document.getElementById("abono-output");
    const ABONO_DEFAULT_HINT = "Configura los filtros y genera tu abono.";
    const gatilloNumInput = document.getElementById("gatillo-num");
    const gatilloPaisSelect = document.getElementById("gatillo-pais");
    const gatilloWindowInput = document.getElementById("gatillo-window");
    const gatilloCalcularBtn = document.getElementById("gatillo-calcular");
    const gatilloOutput = document.getElementById("gatillo-output");
    const monthlyPaisSelect = document.getElementById("monthly-pais");
    const monthlyDowSelect = document.getElementById("monthly-dow");
    const monthlyTurnoSelect = document.getElementById("monthly-turno");
    const monthlyMonthsInput = document.getElementById("monthly-months");
    const monthlySummaryEl = document.getElementById("monthly-summary");
    const monthlyTableEl = document.getElementById("monthly-table");
    const monthlyRefreshBtn = document.getElementById("monthly-refresh");
    const monthlyTrendMonthSelect = document.getElementById("monthly-trend-month");
    const monthlyTrendPaisSelect = document.getElementById("monthly-trend-pais");
    const monthlyTrendTurnoSelect = document.getElementById("monthly-trend-turno");
    const monthlyTrendYearsInput = document.getElementById("monthly-trend-years");
    const monthlyTrendSummaryEl = document.getElementById("monthly-trend-summary");
    const monthlyTrendAlertsEl = document.getElementById("monthly-trend-alerts");
    const monthlyTrendChartEl = document.getElementById("monthly-trend-chart");
    const monthlyTrendHotlistEl = document.getElementById("monthly-trend-hotlist");
    const monthlyTrendYearsEl = document.getElementById("monthly-trend-years-grid");
    const monthlyTrendRefreshBtn = document.getElementById("monthly-trend-refresh");

    const defaultTrackingFecha = trackingState?.fecha || dayFecha?.value || todayISO;
    const defaultTrackingPais = trackingState?.pais || dayPais?.value || trackingPaisSelect?.value || "HN";
    if (historyDateInput && dayFecha?.value && !historyDateInput.value) historyDateInput.value = dayFecha.value;
    if (historyLimitSelect && !historyLimitSelect.value) historyLimitSelect.value = "9";
    if (trackingDateInput && defaultTrackingFecha) trackingDateInput.value = defaultTrackingFecha;
    if (trackingPaisSelect && defaultTrackingPais) trackingPaisSelect.value = defaultTrackingPais;
    if (abonoFechaInput && !abonoFechaInput.value) abonoFechaInput.value = todayISO;
    if (gatilloWindowInput && !gatilloWindowInput.value) gatilloWindowInput.value = "180";
    if (monthlyTrendMonthSelect) monthlyTrendMonthSelect.value = String(new Date().getMonth());

    let patternsCache = null;
    let patternsLoading = false;
    let rankingDataCache = null;
    let rankingActiveTab = "hot";
    let rankingSearchTarget = null;

    historySearchBtn?.addEventListener("click", () => {
      refreshHistoryPanel();
    });
    historyRefreshBtn?.addEventListener("click", () => {
      refreshHistoryPanel({ forceReload: true });
    });
    historyClearBtn?.addEventListener("click", () => {
      if (historyDateInput) historyDateInput.value = "";
      if (historyHourSelect) historyHourSelect.value = "";
      if (historyCountrySelect) historyCountrySelect.value = "";
      if (historyLimitSelect) historyLimitSelect.value = "9";
      refreshHistoryPanel({ defaultView: true });
    });
    historyDateInput?.addEventListener("change", () => refreshHistoryPanel());
    historyHourSelect?.addEventListener("change", () => refreshHistoryPanel());
    historyCountrySelect?.addEventListener("change", () => refreshHistoryPanel());
    historyLimitSelect?.addEventListener("change", () => refreshHistoryPanel());

    trackingViewBtn?.addEventListener("click", () => {
      renderTrackingPanel();
    });
    trackingDateInput?.addEventListener("change", () => renderTrackingPanel());
    trackingPaisSelect?.addEventListener("change", () => renderTrackingPanel());
    trackingPinBtn?.addEventListener("click", () => {
      if (!trackingDateInput || !trackingPaisSelect) return;
      const fecha = trackingDateInput.value;
      const pais = trackingPaisSelect.value;
      if (!fecha || !pais) return;
      const isActive =
        trackingState &&
        trackingState.fecha === fecha &&
        trackingState.pais === pais;
      trackingState = isActive ? null : { fecha, pais };
      saveTrackingState(trackingState);
      renderTrackingPanel();
      refreshHistoryPanel();
    });

    patternsRefreshBtn?.addEventListener("click", () => {
      refreshPatternsPanel({ force: true });
    });

    weeklyRefreshBtn?.addEventListener("click", () => {
      refreshWeeklyPanel({ force: true });
    });
    linesRefreshBtn?.addEventListener("click", () => {
      refreshLinesPanel({ force: true });
    });
    linesMissingRefreshBtn?.addEventListener("click", () => {
      refreshLinesPanel({ force: true });
    });
    abonoGenerarBtn?.addEventListener("click", () => {
      runAbonoGenerator({ force: true });
    });
    [abonoFechaInput, abonoPaisSelect, abonoWindowInput].forEach((input) => {
      input?.addEventListener("change", () => {
        resetAbonoOutput("Par√°metros actualizados. Presiona \"Generar abono\" para recalcular.");
      });
    });
    resetAbonoOutput();
    gatilloCalcularBtn?.addEventListener("click", () => {
      runGatillo({ force: true });
    });
    [gatilloNumInput, gatilloPaisSelect, gatilloWindowInput].forEach((input) => {
      input?.addEventListener("change", () => runGatillo());
    });
    [weeklyPaisSelect, weeklyTurnoSelect, weeklyWindowInput, weeklyRepeatsInput].forEach((input) => {
      input?.addEventListener("change", () => refreshWeeklyPanel());
    });
    weeklyGridEl?.addEventListener("click", async (event) => {
      const focusBtn = event.target.closest?.("[data-weekly-focus]");
      if (focusBtn) {
        await focusDayPanel(focusBtn.dataset.weeklyFocus || null, focusBtn.dataset.pais || null);
        return;
      }
      const copyBtn = event.target.closest?.("[data-weekly-copy]");
      if (copyBtn) {
        const payload = copyBtn.dataset.weeklyCopy || "";
        if (!payload) return;
        try {
          if (typeof navigator !== "undefined" && navigator.clipboard?.writeText) {
            await navigator.clipboard.writeText(payload);
          } else {
            const textarea = document.createElement("textarea");
            textarea.value = payload;
            textarea.setAttribute("readonly", "true");
            textarea.style.position = "absolute";
            textarea.style.left = "-9999px";
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand("copy");
            textarea.remove();
          }
          showToast("Secuencia copiada al portapapeles.", { variant: "success" });
        } catch (err) {
          console.error("copy weekly sequence", err);
          showToast("No se pudo copiar la secuencia.", { variant: "danger" });
        }
      }
    });

    monthlyRefreshBtn?.addEventListener("click", () => {
      refreshMonthlyPanel({ force: true });
    });
    [monthlyPaisSelect, monthlyDowSelect, monthlyTurnoSelect, monthlyMonthsInput].forEach((input) => {
      input?.addEventListener("change", () => refreshMonthlyPanel());
    });
    monthlyTableEl?.addEventListener("click", async (event) => {
      const focusBtn = event.target.closest?.("[data-monthly-focus]");
      if (!focusBtn) return;
      await focusDayPanel(focusBtn.dataset.monthlyFocus || null, focusBtn.dataset.pais || null);
    });
    monthlyTrendRefreshBtn?.addEventListener("click", () => {
      refreshMonthlyTrendsPanel({ force: true });
    });
    [monthlyTrendMonthSelect, monthlyTrendPaisSelect, monthlyTrendTurnoSelect, monthlyTrendYearsInput].forEach((input) => {
      input?.addEventListener("change", () => refreshMonthlyTrendsPanel());
    });
    monthlyTrendHotlistEl?.addEventListener("click", async (event) => {
      const focusBtn = event.target.closest?.("[data-trend-focus]");
      if (!focusBtn) return;
      await focusDayPanel(focusBtn.dataset.trendFocus || null, focusBtn.dataset.pais || null);
    });

    rankingYearSelect?.addEventListener("change", () => {
      renderRankingPanel();
    });
    rankingSearchBtn?.addEventListener("click", () => {
      handleRankingSearch();
    });
    rankingSearchInput?.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        event.preventDefault();
        handleRankingSearch();
      }
    });
    rankingClearBtn?.addEventListener("click", () => {
      if (rankingSearchInput) rankingSearchInput.value = "";
      rankingSearchTarget = null;
      renderRankingPanel();
      if (rankingInsightEl) rankingInsightEl.textContent = "Busca un n√∫mero para ver su historial.";
    });
    rankingTabButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        const tab = btn.dataset.rankingTab || "hot";
        rankingActiveTab = tab;
        rankingTabButtons.forEach((b) => b.classList.toggle("active", b === btn));
        renderRankingPanel();
      });
    });

    function compareDrawDesc(a, b) {
      if (a.fecha && b.fecha && a.fecha !== b.fecha) {
        return b.fecha.localeCompare(a.fecha);
      }
      const horarioDiff = (HORARIO_ORDER[b.horario] ?? 0) - (HORARIO_ORDER[a.horario] ?? 0);
      if (horarioDiff !== 0) return horarioDiff;
      return (b.createdAt || 0) - (a.createdAt || 0);
    }

    function latestRealDate(draws = []) {
      return draws
        .filter((d) => d?.fecha)
        .map((d) => d.fecha)
        .sort((a, b) => b.localeCompare(a))[0] || null;
    }

    const renderHistoryBadge = (label, extraClass, title = "") =>
      `<span class="history-pill ${extraClass}"${title ? ` title="${title}"` : ""}><span class="history-pill__dot"></span>${label}</span>`;

    function historyBadges(draw, latestDate) {
      const badges = [];
      if (draw.fecha === todayISO) {
        badges.push(renderHistoryBadge("Hoy", "history-pill--today", "Resultado registrado hoy"));
      } else if (latestDate && draw.fecha === latestDate) {
        badges.push(renderHistoryBadge("Reciente", "history-pill--recent", "D√≠a m√°s reciente con registros"));
      }
      return badges.join("");
    }

    function computeYearCoverage(draws = []) {
      const map = new Map();
      draws.forEach((draw) => {
        const fecha = (draw?.fecha || "").trim();
        if (!fecha) return;
        const year = parseInt(fecha.slice(0, 4), 10);
        if (!Number.isFinite(year)) return;
        const entry = map.get(year) || { year, min: null, max: null, count: 0 };
        entry.count += 1;
        if (!entry.min || fecha < entry.min) entry.min = fecha;
        if (!entry.max || fecha > entry.max) entry.max = fecha;
        map.set(year, entry);
      });
      return Array.from(map.values()).sort((a, b) => b.year - a.year);
    }

    function renderHistoryCoverage(draws = []) {
      if (!historyCoveragePanel) return;
      const currentYear = new Date().getFullYear();
      const coverage = computeYearCoverage(draws);
      const pastYears = coverage.filter((entry) => entry.year < currentYear);
      if (!pastYears.length) {
        historyCoveragePanel.innerHTML =
          "<p class='hint'>A√∫n no registras sorteos de a√±os anteriores ‚Äî importa o agrega uno para llevar control.</p>";
        return;
      }
      const rows = [];
      let cursorYear = currentYear - 1;
      pastYears.forEach((record) => {
        for (let year = cursorYear; year > record.year; year -= 1) {
          rows.push({ year, missing: true });
        }
        rows.push({ ...record, missing: false });
        cursorYear = record.year - 1;
      });
      const title = document.createElement("div");
      title.className = "history-coverage__title";
      title.textContent = "Cobertura hist√≥rica";
      const list = document.createElement("div");
      list.className = "history-coverage__list";
      rows.forEach((row) => {
        if (!row.year || row.year >= currentYear) return;
        const item = document.createElement("div");
        item.className = "history-coverage__row";
        if (row.missing) item.classList.add("history-coverage__row--missing");
        const yearEl = document.createElement("div");
        yearEl.className = "history-coverage__year";
        yearEl.textContent = row.year;
        const info = document.createElement("div");
        info.className = "history-coverage__info";
        if (row.missing) {
          info.innerHTML = `
            <div class="history-coverage__label">Pendiente</div>
            <div class="history-coverage__range">Sin sorteos registrados para ${row.year}.</div>
          `;
        } else {
          const countLabel = `${row.count} sorteo${row.count === 1 ? "" : "s"}`;
          const lastLabel = row.max ? formatFriendlyDate(row.max) : "";
          const firstLabel = row.min && row.min !== row.max ? formatFriendlyDate(row.min) : "";
          const rangeText = firstLabel ? `Primer registro: ${firstLabel}` : "";
          info.innerHTML = `
            <div class="history-coverage__label">√öltimo: ${lastLabel}</div>
            <div class="history-coverage__range">${countLabel}${rangeText ? ` ¬∑ ${rangeText}` : ""}</div>
          `;
        }
        item.append(yearEl, info);
        list.appendChild(item);
      });
      historyCoveragePanel.innerHTML = "";
      historyCoveragePanel.append(title, list);
    }

    async function refreshHistoryPanel({ forceReload = false, defaultView = false } = {}) {
      if (!historyTableWrap) return;
      if (defaultView && historySummary) {
        historySummary.textContent = "Mostrando los √∫ltimos sorteos registrados.";
      }
      const draws = await getCachedDraws({ force: forceReload });
      renderHistoryCoverage(draws);
      if (!draws.length) {
        historyTableWrap.innerHTML = "<p class='hint'>A√∫n no hay sorteos almacenados.</p>";
        if (historySummary) historySummary.textContent = "Sin registros.";
        return;
      }
      const limitValue = parseInt(historyLimitSelect?.value, 10);
      const limit = Number.isFinite(limitValue) ? limitValue : 9;
      let filtered = draws.slice().sort(compareDrawDesc);
      const fechaFiltro = defaultView ? "" : (historyDateInput?.value || "").trim();
      const horarioFiltro = defaultView ? "" : historyHourSelect?.value || "";
      const paisFiltro = defaultView ? "" : historyCountrySelect?.value || "";
      if (fechaFiltro) filtered = filtered.filter((d) => d.fecha === fechaFiltro);
      if (horarioFiltro) filtered = filtered.filter((d) => d.horario === horarioFiltro);
      if (paisFiltro) filtered = filtered.filter((d) => d.pais === paisFiltro);
      const rows = filtered.slice(0, Math.max(1, limit));
      const latestDate = latestRealDate(draws);
      if (!rows.length) {
        historyTableWrap.innerHTML = "<p class='hint'>Sin resultados para esos filtros.</p>";
        if (historySummary) {
          historySummary.textContent = "No se encontraron sorteos que coincidan.";
        }
        return;
      }
      const table = document.createElement("table");
      table.innerHTML = `
        <thead>
          <tr>
            <th>#</th>
            <th>Fecha</th>
            <th>Horario</th>
            <th>Pa√≠s</th>
            <th>N√∫mero</th>
            <th>S√≠mbolo</th>
            <th>Notas</th>
          </tr>
        </thead>
        <tbody></tbody>
      `;
      const tbody = table.querySelector("tbody");
      rows.forEach((draw, idx) => {
        const tr = document.createElement("tr");
        const isTracked =
          trackingState &&
          draw.fecha === trackingState.fecha &&
          (!trackingState.pais || trackingState.pais === draw.pais);
        const isToday = draw.fecha === todayISO;
        if (isTracked) tr.classList.add("history-row--tracked");
        if (isToday || (latestDate && draw.fecha === latestDate)) {
          tr.classList.add("history-row--today");
        }
        tr.innerHTML = `
          <td>${idx + 1}</td>
          <td>${formatFriendlyDate(draw.fecha)}</td>
          <td>${draw.horario || "‚Äî"}</td>
          <td>${draw.pais || "‚Äî"}</td>
          <td class="history-number">${formatNumber(draw.numero)}</td>
          <td>${getSymbol(draw.numero) || "‚Äî"}</td>
          <td>${historyBadges(draw, latestDate)}</td>
        `;
        tbody.appendChild(tr);
      });
      historyTableWrap.innerHTML = "";
      historyTableWrap.appendChild(table);
      if (historySummary) {
        const totalMatches = filtered.length;
        const scopeText =
          fechaFiltro || horarioFiltro || paisFiltro
            ? "con filtros aplicados"
            : "del hist√≥rico general";
        historySummary.textContent = `${rows.length} sorteos ${scopeText} (de ${totalMatches}).`;
      }
    }

    function updateTrackingPinAppearance({ isActive, disabled }) {
      if (!trackingPinBtn) return;
      trackingPinBtn.disabled = !!disabled;
      trackingPinBtn.textContent = isActive ? "Seguimiento activo" : "Seguir este d√≠a";
      trackingPinBtn.classList.toggle("btn-primary", isActive);
      trackingPinBtn.classList.toggle("btn-outline", !isActive);
    }

    async function renderTrackingPanel({ forceReload = false } = {}) {
      if (!trackingGrid) return;
      const fecha = trackingDateInput?.value || "";
      const pais = trackingPaisSelect?.value || "";
      if (!fecha || !pais) {
        trackingGrid.innerHTML = "<p class='hint'>Selecciona fecha y pa√≠s para comenzar el seguimiento.</p>";
        updateTrackingPinAppearance({ isActive: false, disabled: true });
        return;
      }
      const draws = await getCachedDraws({ force: forceReload });
      const cards = HORARIO_KEYS.map((turno) => {
        const match = draws
          .filter((d) => d.fecha === fecha && d.pais === pais && d.horario === turno)
          .sort(compareDrawDesc)[0];
        return { turno, draw: match || null };
      });
      trackingGrid.innerHTML = "";
      const frag = document.createDocumentFragment();
      cards.forEach(({ turno, draw }) => {
        const card = document.createElement("div");
        card.className = "tracking-card";
        if (!draw) {
          card.classList.add("tracking-card--empty");
          card.innerHTML = `<div class="tracking-card__hour">${turno}</div><p class="hint">Sin registro</p>`;
        } else {
          const simbolo = getSymbol(draw.numero);
          card.innerHTML = `
            <div class="tracking-card__hour">${turno}</div>
            <div class="tracking-number">${formatNumber(draw.numero)}</div>
            <div class="tracking-symbol">${simbolo || ""}</div>
            <div class="tracking-meta">${formatFriendlyDate(draw.fecha)} ‚Ä¢ ${draw.pais || ""}</div>
          `;
        }
        const isTracked =
          trackingState &&
          trackingState.fecha === fecha &&
          trackingState.pais === pais;
        if (isTracked) card.classList.add("tracking-card--tracked");
        if (fecha === todayISO && draw) card.classList.add("tracking-card--today");
        frag.appendChild(card);
      });
      trackingGrid.appendChild(frag);
      const isActive =
        trackingState &&
        trackingState.fecha === fecha &&
        trackingState.pais === pais;
      updateTrackingPinAppearance({ isActive, disabled: false });
    }

    function buildPatternSummaryChips(data) {
      const chips = [
        {
          label: "Familia dominante",
          value: data?.familiaDominante || "‚Äî",
        },
        {
          label: "Energ√≠a",
          value: data?.energia || "neutral",
        },
        {
          label: "Ventana",
          value: data?.resumenVentana || "Sin datos",
        },
        {
          label: "√öltimos",
          value: `${data?.recientes?.length || 0} sorteos`,
        },
      ];
      return `
        <div class="pattern-summary__grid">
          ${chips
            .map(
              (chip) => `
                <div class="pattern-chip">
                  <strong>${chip.label}</strong>
                  <span>${chip.value}</span>
                </div>
              `,
            )
            .join("")}
        </div>
      `;
    }

    function renderPatternSummaryCard(data) {
      if (!patternsSummary) return;
      if (!data?.recientes?.length) {
        patternsSummary.innerHTML = "<p class='hint'>A√∫n no hay suficientes sorteos reales para detectar patrones.</p>";
        return;
      }
      patternsSummary.innerHTML = `
        <p>${data.mensaje || "Sin resumen disponible."}</p>
        ${buildPatternSummaryChips(data)}
      `;
    }

    function renderPatternHallazgos(list = []) {
      if (!patternsHallazgos) return;
      if (!list.length) {
        patternsHallazgos.innerHTML = "<p class='hint'>Sin patrones destacados en la ventana reciente.</p>";
        return;
      }
      const top = list.slice(0, 4);
      patternsHallazgos.innerHTML = "";
      top.forEach((hallazgo) => {
        const card = document.createElement("div");
        card.className = "pattern-card";
        card.innerHTML = `
          <div class="pattern-card__title">${hallazgo.titulo || "Patr√≥n detectado"}</div>
          <div class="pattern-card__meta">${hallazgo.resumen || ""}</div>
          ${
            hallazgo.evidencia?.length
              ? `<ul>${hallazgo.evidencia
                  .slice(0, 4)
                  .map((ev) => {
                    const friendly = ev.fecha ? formatFriendlyDate(ev.fecha) : "";
                    const fallback = friendly || ev.fecha || "";
                    const label = ev.resumen || `${fallback}${ev.horario ? ` ${ev.horario}` : ""}`.trim();
                    return `<li>${label}</li>`;
                  })
                  .join("")}</ul>`
              : ""
          }
        `;
        patternsHallazgos.appendChild(card);
      });
    }

    strategiesList?.addEventListener("click", async (event) => {
      const viewBtn = event.target.closest("[data-strategy-view]");
      if (viewBtn) {
        await focusDayPanel(viewBtn.dataset.fecha || null, viewBtn.dataset.pais || null);
        return;
      }
      const trackBtn = event.target.closest("[data-strategy-track]");
      if (trackBtn) {
        await followStrategyDay(trackBtn.dataset.fecha || null, trackBtn.dataset.pais || null);
        return;
      }
      const hypoBtn = event.target.closest("[data-strategy-hypo]");
      if (hypoBtn) {
        navigateToView("hypo");
        if (hypoFechaInput && hypoBtn.dataset.fecha) hypoFechaInput.value = hypoBtn.dataset.fecha;
        if (hypoTurnoSelect && hypoBtn.dataset.turno) hypoTurnoSelect.value = hypoBtn.dataset.turno;
        if (hypoNumeroInput && hypoBtn.dataset.numero) hypoNumeroInput.value = hypoBtn.dataset.numero;
        if (hypoTextoInput) {
          const notaBase = hypoBtn.dataset.descripcion || "Estrategia aritm√©tica detectada.";
          hypoTextoInput.value = notaBase;
        }
        showToast("Hip√≥tesis preparada desde la estrategia seleccionada.", { variant: "info" });
      }
    });

    async function renderStrategiesPanel({ force = false, skipEnsure = false } = {}) {
      if (!strategiesList) return;
      if (force) patternsCache = null;
      if (!skipEnsure && !patternsCache) {
        const prevFlag = allowStrategyAutoRender;
        allowStrategyAutoRender = false;
        try {
          await refreshPatternsPanel({ force });
        } finally {
          allowStrategyAutoRender = prevFlag;
        }
      }
      if (!patternsCache) {
        strategiesList.innerHTML = "<p class='hint'>Calcula los patrones para ver estrategias aritm√©ticas.</p>";
        return;
      }
      const data = patternsCache.estrategiasAritmeticas ?? [];
      if (!data.length) {
        strategiesList.innerHTML = "<p class='hint'>Sin estrategias detectadas en los registros recientes.</p>";
        return;
      }
      const filtered = data.filter((entry) => {
        const turnoOk =
          !entry.target?.horario || strategyFilters.turns.has(entry.target.horario);
        const opOk = strategyFilters.operators.has(entry.operador);
        return turnoOk && opOk;
      });
      if (!filtered.length) {
        strategiesList.innerHTML =
          "<p class='hint'>Sin estrategias que coincidan con los filtros seleccionados.</p>";
        return;
      }
      strategiesList.innerHTML = "";
      const draws = await getCachedDraws({ force });
      const dayCache = new Map();
      const getDayDraws = (fecha, pais) => {
        const key = `${fecha}|${pais || ""}`;
        if (dayCache.has(key)) return dayCache.get(key);
        const map = {};
        HORARIO_KEYS.forEach((turno) => {
          map[turno] = pickDraw(draws, fecha, pais || null, turno);
        });
        dayCache.set(key, map);
        return map;
      };

      filtered
        .slice()
        .sort(
          (a, b) =>
            (new Date(b.target?.fecha || "1970-01-01") - new Date(a.target?.fecha || "1970-01-01")) ||
            (HORARIO_ORDER[b.target?.horario] ?? 0) - (HORARIO_ORDER[a.target?.horario] ?? 0)
        )
        .forEach((entry) => {
          const card = document.createElement("article");
          card.className = "strategy-card";
          const symbol = getSymbol(entry.target.numero);
          const leftSymbol = getSymbol(entry.left.numero);
          const rightSymbol = getSymbol(entry.right.numero);
          const historyLine =
            entry.historyCount > 0
              ? `<div class="strategy-meta">Aplicada anteriormente: ${entry.historyCount} vez(es)</div>`
              : "";
          const dayDraws =
            entry.target?.fecha ? getDayDraws(entry.target.fecha, entry.target.pais || null) : {};
          card.innerHTML = `
          <div class="strategy-head">
            <span class="strategy-target">${formatNumber(entry.target.numero)} ${symbol || ""}</span>
            <span class="strategy-badge">${entry.operador === "+" ? "Suma" : "Resta"}</span>
          </div>
          <div class="strategy-meta">${formatFriendlyDate(entry.target.fecha)} ¬∑ ${entry.target.horario || "‚Äî"}${entry.target.pais ? ` ¬∑ ${entry.target.pais}` : ""}</div>
          <div class="strategy-operation">
            <span>${formatNumber(entry.left.numero)} ${leftSymbol || ""}</span>
            <span class="strategy-operator">${entry.operador}</span>
            <span>${formatNumber(entry.right.numero)} ${rightSymbol || ""}</span>
            <span class="strategy-operator">=</span>
            <span>${formatNumber(entry.target.numero)}</span>
          </div>
          ${historyLine}
        `;
          const timeline = buildStrategyTimeline(entry, dayDraws);
          card.appendChild(timeline);
          const detail = document.createElement("ul");
          detail.className = "strategy-detail";
          detail.innerHTML = `
          <li>${formatFriendlyDate(entry.left.fecha)} ¬∑ ${entry.left.horario || "‚Äî"}${entry.left.pais ? ` ¬∑ ${entry.left.pais}` : ""}</li>
          <li>${formatFriendlyDate(entry.right.fecha)} ¬∑ ${entry.right.horario || "‚Äî"}${entry.right.pais ? ` ¬∑ ${entry.right.pais}` : ""}</li>
        `;
          card.appendChild(detail);
          const actions = document.createElement("div");
          actions.className = "strategy-actions";
          if (entry.target?.fecha) {
            const viewBtn = document.createElement("button");
            viewBtn.type = "button";
            viewBtn.className = "btn-outline";
            viewBtn.textContent = "Ver d√≠a completo";
            viewBtn.dataset.strategyView = "true";
            viewBtn.dataset.fecha = entry.target.fecha;
            viewBtn.dataset.pais = entry.target.pais || "";
            actions.appendChild(viewBtn);
          }
          if (entry.target?.fecha) {
            const trackBtn = document.createElement("button");
            trackBtn.type = "button";
            trackBtn.className = "btn-ghost";
            trackBtn.textContent = "Seguir d√≠a";
            trackBtn.dataset.strategyTrack = "true";
            trackBtn.dataset.fecha = entry.target.fecha;
            trackBtn.dataset.pais = entry.target.pais || "";
            actions.appendChild(trackBtn);
          }
          if (entry.target?.numero !== null) {
          const hypoBtn = document.createElement("button");
          hypoBtn.type = "button";
          hypoBtn.className = "btn-secondary";
          hypoBtn.textContent = "Guardar hip√≥tesis";
          hypoBtn.dataset.strategyHypo = "true";
            hypoBtn.dataset.numero = formatNumber(entry.target.numero);
            hypoBtn.dataset.fecha = entry.target.fecha || "";
            hypoBtn.dataset.turno = entry.target.horario || "";
            hypoBtn.dataset.descripcion = `${formatNumber(entry.left.numero)} ${entry.operador} ${formatNumber(
              entry.right.numero,
            )} = ${formatNumber(entry.target.numero)}`;
          actions.appendChild(hypoBtn);
        }
        if (actions.childElementCount) card.appendChild(actions);
        strategiesList.appendChild(card);
      });

      const stats = buildStrategyStats(filtered);
      const years = Object.keys(stats.years).sort();
      const rangeLabel =
        years.length > 1 ? `${years[0]} ‚Äì ${years[years.length - 1]}` : years[0] || "N/D";
      const statsCard = document.createElement("article");
      statsCard.className = "strategy-card strategy-card--stats";
      statsCard.innerHTML = `
        <div class="strategy-head">
          <span class="strategy-target">Resumen hist√≥rico</span>
          <span class="strategy-badge">${rangeLabel}</span>
        </div>
        <div class="strategy-stats">
          <p><strong>Total estrategias detectadas:</strong> ${stats.total}</p>
          <p><strong>Por operador:</strong> ${stats.operators["+"] || 0} sumas ¬∑ ${stats.operators["‚àí"] || 0} restas</p>
        </div>
      `;
      if (years.length) {
        const yearList = document.createElement("ul");
        yearList.className = "strategy-year-stats";
        years.forEach((year) => {
          const info = stats.years[year];
          const sumUse = info.suma || 0;
          const restUse = info.resta || 0;
          const li = document.createElement("li");
          li.textContent = `${year}: ${info.total} estrategias (${sumUse} sumas / ${restUse} restas)`;
          yearList.appendChild(li);
        });
        statsCard.appendChild(yearList);
      }
      strategiesList.appendChild(statsCard);
    }

    function buildStrategyStats(entries = []) {
      const stats = {
        total: entries.length,
        operators: { "+": 0, "‚àí": 0 },
        years: {},
      };
      entries.forEach((entry) => {
        if (stats.operators[entry.operador] !== undefined) {
          stats.operators[entry.operador] += 1;
        }
        const year = entry.target?.fecha ? entry.target.fecha.slice(0, 4) : "N/D";
        if (!stats.years[year]) {
          stats.years[year] = { total: 0, suma: 0, resta: 0 };
        }
        stats.years[year].total += 1;
        if (entry.operador === "+") stats.years[year].suma += 1;
        else stats.years[year].resta += 1;
      });
      return stats;
    }

    function buildStrategyTimeline(entry, dayDraws = {}) {
      const timeline = document.createElement("div");
      timeline.className = "strategy-timeline";
      HORARIO_KEYS.forEach((turno) => {
        const slot = document.createElement("div");
        slot.className = "strategy-slot";
        const targetMatch = entry.target?.horario === turno;
        if (targetMatch) slot.classList.add("strategy-slot--result");
        const isLeftSource =
          entry.left?.horario === turno &&
          entry.left?.fecha === entry.target?.fecha &&
          (entry.left?.pais || "") === (entry.target?.pais || "");
        const isRightSource =
          entry.right?.horario === turno &&
          entry.right?.fecha === entry.target?.fecha &&
          (entry.right?.pais || "") === (entry.target?.pais || "");
        if (isLeftSource || isRightSource) slot.classList.add("strategy-slot--source");
        let draw = dayDraws[turno] || null;
        let value = draw ? formatNumber(draw.numero) : "--";
        let symbol = draw ? getSymbol(draw.numero) : "";
        let external = false;
        if (!draw) {
          const fallback =
            entry.left?.horario === turno ? entry.left : entry.right?.horario === turno ? entry.right : null;
          if (fallback && fallback.numero !== null) {
            value = formatNumber(fallback.numero);
            symbol = getSymbol(fallback.numero);
            external =
              fallback.fecha !== entry.target?.fecha ||
              (fallback.pais || "") !== (entry.target?.pais || "");
            if (fallback === entry.left || fallback === entry.right) {
              slot.classList.add("strategy-slot--source");
            }
          }
        }
        if (external) slot.dataset.external = "true";
        const label = document.createElement("span");
        label.className = "strategy-slot__label";
        label.textContent = turno;
        const valueEl = document.createElement("span");
        valueEl.className = "strategy-slot__value";
        valueEl.textContent = value;
        const symbolEl = document.createElement("span");
        symbolEl.className = "strategy-slot__symbol";
        symbolEl.textContent = symbol || "";
        slot.appendChild(label);
        slot.appendChild(valueEl);
        slot.appendChild(symbolEl);
        timeline.appendChild(slot);
      });
      return timeline;
    }

    function renderPatternHistory(list = []) {
      if (!patternsHistory) return;
      if (!list.length) {
        patternsHistory.innerHTML = "<p class='hint'>A√∫n no hay repeticiones hist√≥ricas suficientes.</p>";
        return;
      }
      const top = list.slice(0, 4);
      const container = document.createElement("div");
      container.className = "pattern-history-list";
      top.forEach((item) => {
        const years = item.years?.map((y) => `${y.year}: ${y.count}`).slice(0, 3).join(" ¬∑ ") || "‚Äî";
        const ultima = item.ultimaFecha ? formatFriendlyDate(item.ultimaFecha) : "‚Äî";
        const block = document.createElement("div");
        block.className = "pattern-history-item";
        block.innerHTML = `
          <strong>${formatNumber(item.numero)} ${item.simbolo || ""}</strong>
          <div>${item.totalEventos} repeticiones (${Math.round((item.ratio || 0) * 100)}%)</div>
          <div class="muted">√öltima vez: ${ultima}</div>
          <div class="muted">A√±os: ${years}</div>
        `;
        container.appendChild(block);
      });
      patternsHistory.innerHTML = "";
      patternsHistory.appendChild(container);
    }

    async function refreshPatternsPanel({ force = false } = {}) {
      if (!patternsSummary) return;
      if (patternsLoading) return;
      if (force) patternsCache = null;
      if (!patternsCache) {
        patternsSummary.innerHTML = "<p class='hint'>Analizando patrones‚Ä¶</p>";
        patternsHallazgos.innerHTML = "";
        patternsHistory.innerHTML = "";
      }
      patternsLoading = true;
      try {
        if (!patternsCache) {
          patternsCache = await detectarPatrones({ cantidad: 12 });
        }
        renderPatternSummaryCard(patternsCache);
        renderPatternHallazgos(patternsCache.hallazgos || []);
        renderPatternHistory(patternsCache.repeticionesHistoricas || []);
        if (
          allowStrategyAutoRender &&
          strategiesSection &&
          !strategiesSection.classList.contains("hidden")
        ) {
          await renderStrategiesPanel({ skipEnsure: true });
        }
      } catch (err) {
        console.error("patterns error", err);
        patternsSummary.innerHTML = `<p class='hint'>No se pudo calcular: ${err.message}</p>`;
        patternsHallazgos.innerHTML = "";
        patternsHistory.innerHTML = "";
      } finally {
        patternsLoading = false;
      }
    }

    const WEEKLY_DEFAULT_WINDOW = 12;
    let weeklyLoading = false;
    let weeklyLastAnalysis = null;
    let linesLoading = false;
    let lastLinesAnalysis = null;
    let abonoSpinTimer = null;
    let monthlyLoading = false;
    let monthlyLastAnalysis = null;
    let monthlyTrendLoading = false;
    let monthlyTrendLastAnalysis = null;
    let gatilloCache = null;

    function resetAbonoOutput(message = ABONO_DEFAULT_HINT) {
      if (!abonoOutput) return;
      abonoOutput.innerHTML = `<p class='hint'>${message}</p>`;
    }

    function formatAbonoNumber(numero) {
      if (!Number.isFinite(numero)) return "--";
      const formatted = formatNumber(numero);
      const symbol = getSymbol(numero);
      return symbol ? `${formatted} ${symbol}` : formatted;
    }

    function formatPatternWithSymbols(pattern = []) {
      if (!Array.isArray(pattern) || !pattern.length) return "";
      return pattern
        .map((numero) => {
          const formatted = formatNumber(numero);
          const symbol = getSymbol(numero);
          return symbol ? `${formatted} ${symbol}` : formatted;
        })
        .join(" ‚Üí ");
    }

    function formatLineBand(band) {
      if (!Number.isFinite(band)) return "";
      const start = Math.max(0, Math.min(90, band));
      const end = Math.min(99, start + 9);
      return `${String(start).padStart(2, "0")}-${String(end).padStart(2, "0")}`;
    }

    function formatLinePattern(pattern = []) {
      if (!Array.isArray(pattern) || !pattern.length) return "";
      return pattern.map((band) => formatLineBand(band)).join(" ‚Üí ");
    }

    function renderLinesRotation(analysis = null) {
      if (!linesBodyEl) return;
      if (!analysis || !analysis.weeks?.length) {
        linesBodyEl.innerHTML = "<p class='hint'>Necesitas m√°s semanas registradas para calcular la rotaci√≥n.</p>";
        renderLinesMissing(null);
        return;
      }
      const { cycle, weeks, filtro, lineSummaries = [] } = analysis;
      const fragment = document.createDocumentFragment();
      const summary = document.createElement("div");
      summary.className = "lines-highlight";
      const coverage = cycle?.coverage ? `${Math.round((cycle.coverage || 0) * 100)}%` : null;
      if (cycle) {
        const pattern = formatLinePattern(cycle.pattern);
        const next = formatLineBand(cycle.nextNumero);
        summary.innerHTML = `Rotaci√≥n detectada: <strong>${pattern}</strong> (${cycle.matchedCycles} ciclos). Pr√≥ximo bloque probable: <strong>${next || "--"}</strong>${coverage ? ` ¬∑ Cobertura ${coverage}` : ""}.`;
      } else {
        const paisLabel = filtro?.pais || "todos los pa√≠ses";
        const turnoLabel = filtro?.turno || "todos los turnos";
        summary.textContent = `Sin rotaci√≥n clara en las √∫ltimas ${weeks.length} semanas (${paisLabel} ¬∑ ${turnoLabel}).`;
      }
      fragment.appendChild(summary);

      const grid = document.createElement("div");
      grid.className = "lines-grid";
      const recent = weeks.slice(-10).reverse();
      recent.forEach((week) => {
        const card = document.createElement("div");
        card.className = "lines-card";
        const title = document.createElement("strong");
        title.textContent = week.key || "Semana";
        card.appendChild(title);
        const period = document.createElement("small");
        period.textContent = week.start && week.end ? `${formatFriendlyDate(week.start)} ‚Ä¢ ${formatFriendlyDate(week.end)}` : "";
        card.appendChild(period);
        const top = document.createElement("div");
        const topLabel = week.topLine?.label || "‚Äî";
        const topShare = week.topLine?.share ? ` (${Math.round(week.topLine.share * 100)}%)` : "";
        const topCount = week.topLine?.count ? ` ¬∑ ${week.topLine.count}/${week.total}` : "";
        top.textContent = `Bloque dominante: ${topLabel}${topShare}${topCount}`;
        card.appendChild(top);
        if (week.topLines?.length) {
          const breakdown = document.createElement("small");
          breakdown.textContent = week.topLines
            .map((line) => `${line.label} (${line.count})`)
            .join(" ¬∑ ");
          card.appendChild(breakdown);
        }
        grid.appendChild(card);
      });
      fragment.appendChild(grid);

      const detailBlock = document.createElement("div");
      detailBlock.className = "lines-overview";
      const detailHead = document.createElement("div");
      detailHead.className = "lines-overview__head";
      detailHead.innerHTML = `<strong>Bloques detallados</strong><span>Visualiza qu√© n√∫meros de cada l√≠nea ya salieron y cu√°les siguen pendientes.</span>`;
      detailBlock.appendChild(detailHead);
      const overviewGrid = document.createElement("div");
      overviewGrid.className = "lines-overview-grid";
      const linesToShow = lineSummaries.filter((line) => (line?.totalEntries || 0) > 0);
      if (linesToShow.length) {
        linesToShow.forEach((line) => {
          const card = document.createElement("div");
          card.className = "lines-overview-card";
          const header = document.createElement("div");
          header.className = "lines-overview-card__head";
          const title = document.createElement("div");
          title.className = "lines-overview-card__title";
          const coverage = Math.round(((line?.seenUnique || 0) / 10) * 100);
          title.innerHTML = `<strong>${line?.label || "L√≠nea"}</strong><span>${line?.seenUnique || 0}/10 (${coverage}%)</span>`;
          const meta = document.createElement("div");
          meta.className = "lines-overview-card__meta";
          const last = line?.lastSeen;
          const lastSymbol = last?.numero !== undefined ? getSymbol(last.numero) || "‚Äî" : null;
          meta.textContent = last?.numero !== undefined
            ? `√öltimo: ${formatNumber(last.numero)} ${lastSymbol || ""}`.trim()
            : "Sin actividad";
          header.append(title, meta);
          card.appendChild(header);

          const numbersWrap = document.createElement("div");
          numbersWrap.className = "lines-overview-numbers";
          const missingSet = new Set(line?.missingNumbers || []);
          for (let offset = 0; offset < 10; offset += 1) {
            const numero = Math.min(99, (line?.band ?? 0) + offset);
            const pill = document.createElement("span");
            pill.className = "lines-overview-number";
            const isMissing = missingSet.has(numero);
            pill.dataset.state = isMissing ? "missing" : "played";
            const symbol = getSymbol(numero) || "‚Äî";
            pill.innerHTML = `<strong>${formatNumber(numero)}</strong><small>${symbol}</small>`;
            numbersWrap.appendChild(pill);
          }
          card.appendChild(numbersWrap);
          overviewGrid.appendChild(card);
        });
        detailBlock.appendChild(overviewGrid);
      } else {
        const empty = document.createElement("p");
        empty.className = "hint";
        empty.textContent = "Todav√≠a no hay l√≠neas con registros suficientes en esta ventana.";
        detailBlock.appendChild(empty);
      }
      fragment.appendChild(detailBlock);

      linesBodyEl.innerHTML = "";
      linesBodyEl.appendChild(fragment);
      renderLinesMissing(analysis);
    }

    function renderLinesMissing(analysis = null) {
      if (!linesMissingBodyEl) return;
      if (!analysis) {
        linesMissingBodyEl.innerHTML = "<p class='hint'>Calcula la rotaci√≥n para conocer los pendientes por l√≠nea.</p>";
        return;
      }
      const { lineSummaries = [], filtro, windowRange, weeks, monthlyLineStatus = [] } = analysis;
      if (!lineSummaries.length && !monthlyLineStatus.length) {
        linesMissingBodyEl.innerHTML = "<p class='hint'>A√∫n no hay registros suficientes este a√±o para calcular faltantes.</p>";
        return;
      }
      const stack = document.createElement("div");
      stack.className = "lines-missing-stack";

      const buildPill = (numero) => {
        const pill = document.createElement("span");
        pill.className = "lines-missing-pill";
        const symbol = getSymbol(numero) || "‚Äî";
        pill.innerHTML = `<strong>${formatNumber(numero)}</strong><small>${symbol}</small>`;
        return pill;
      };

      if (lineSummaries.length) {
        const summary = document.createElement("div");
        summary.className = "lines-missing-summary";
        const paisLabel = filtro?.pais || "todos los pa√≠ses";
        const turnoLabel = filtro?.turno || "todos los turnos";
        const weeksLabel = `${weeks?.length || 0} semana${weeks?.length === 1 ? "" : "s"}`;
        const rangeLabel = windowRange?.start && windowRange?.end
          ? `${formatFriendlyDate(windowRange.start)} ‚Üí ${formatFriendlyDate(windowRange.end)}`
          : null;
        summary.textContent = `${weeksLabel} ¬∑ ${paisLabel} ¬∑ ${turnoLabel}${rangeLabel ? ` (${rangeLabel})` : ""}`;

        const grid = document.createElement("div");
        grid.className = "lines-missing-grid";
        const activeLines = lineSummaries.filter((line) => (line?.totalEntries || 0) > 0);
        const linesToRender = activeLines.length ? activeLines : lineSummaries;

        linesToRender.forEach((line) => {
          const card = document.createElement("div");
          card.className = "lines-missing-card";
          if (!line?.missingNumbers?.length) card.classList.add("lines-missing-card--complete");

          const head = document.createElement("div");
          head.className = "lines-missing-card__head";
          const title = document.createElement("div");
          title.className = "lines-missing-card__title";
          const pendingLabel = line?.missingNumbers?.length
            ? `${line.missingNumbers.length} faltante${line.missingNumbers.length === 1 ? "" : "s"}`
            : "Sin pendientes";
          title.innerHTML = `<strong>${line?.label || "L√≠nea"}</strong><span>${pendingLabel}</span>`;
          const meta = document.createElement("small");
          const seenLabel = `${line?.seenUnique || 0}/10 vistos`;
          let lastLabel = "";
          if (line?.lastSeen?.numero !== undefined) {
            const symbol = getSymbol(line.lastSeen.numero) || "‚Äî";
            const lastNumber = `${formatNumber(line.lastSeen.numero)} ${symbol}`.trim();
            const when = line.lastSeen.fecha ? formatFriendlyDate(line.lastSeen.fecha) : "";
            const hora = line.lastSeen.horario ? ` ¬∑ ${line.lastSeen.horario}` : "";
            const pais = line.lastSeen.pais ? ` ¬∑ ${line.lastSeen.pais}` : "";
            lastLabel = ` ¬∑ √öltimo ${lastNumber}${when ? ` (${when}${hora}${pais})` : ""}`;
          }
          meta.textContent = `${seenLabel}${lastLabel}`;
          head.append(title, meta);
          card.appendChild(head);

          const chips = document.createElement("div");
          chips.className = "lines-missing-chips";
          if (line?.missingNumbers?.length) {
            line.missingNumbers.forEach((numero) => {
              chips.appendChild(buildPill(numero));
            });
          } else {
            const pill = document.createElement("span");
            pill.className = "lines-missing-pill lines-missing-pill--complete";
            pill.textContent = "Bloque completo";
            chips.appendChild(pill);
          }
          card.appendChild(chips);
          grid.appendChild(card);
        });

        stack.append(summary, grid);
      }

      const monthlyBlock = document.createElement("div");
      monthlyBlock.className = "lines-missing-history";
      const monthlyHead = document.createElement("div");
      monthlyHead.className = "lines-missing-history__head";
      monthlyHead.innerHTML = `<strong>Monitoreo anual</strong><span>Meses del a√±o en curso con l√≠neas incompletas.</span>`;
      monthlyBlock.appendChild(monthlyHead);

      const monthlyData = monthlyLineStatus.filter((month) => month?.lines?.length);
      if (monthlyData.length) {
        const monthGrid = document.createElement("div");
        monthGrid.className = "lines-month-grid";
        monthlyData.forEach((month) => {
          const monthCard = document.createElement("div");
          monthCard.className = "lines-month-card";
          const head = document.createElement("div");
          head.className = "lines-month-card__head";
          const linesLabel = `${month.lines.length} bloque${month.lines.length === 1 ? "" : "s"} incompleto${month.lines.length === 1 ? "" : "s"}`;
          head.innerHTML = `<strong>${month.label || month.key}</strong><span>${linesLabel}</span>`;
          const drawsTag = document.createElement("small");
          drawsTag.textContent = `${month.totalDraws || 0} sorteos registrados`;
          head.appendChild(drawsTag);
          monthCard.appendChild(head);

          month.lines.forEach((line) => {
            const lineRow = document.createElement("div");
            lineRow.className = "lines-month-line";
            const lineTitle = document.createElement("div");
            lineTitle.className = "lines-month-line__title";
            const pendingLabel = `${line.missingNumbers.length} faltante${line.missingNumbers.length === 1 ? "" : "s"}`;
            lineTitle.innerHTML = `<span>${line.label}</span><small>${pendingLabel}</small>`;
            const chips = document.createElement("div");
            chips.className = "lines-missing-chips";
            line.missingNumbers.forEach((numero) => {
              chips.appendChild(buildPill(numero));
            });
            lineRow.append(lineTitle, chips);
            monthCard.appendChild(lineRow);
          });

          monthGrid.appendChild(monthCard);
        });
        monthlyBlock.appendChild(monthGrid);
      } else {
        const ok = document.createElement("div");
        ok.className = "lines-month-card lines-month-card--complete";
        ok.innerHTML = "<p class='hint'>Todas las l√≠neas se han completado en cada mes del a√±o en curso.</p>";
        monthlyBlock.appendChild(ok);
      }

      stack.appendChild(monthlyBlock);

      linesMissingBodyEl.innerHTML = "";
      linesMissingBodyEl.appendChild(stack);
    }

    async function runAbonoGenerator({ force = false } = {}) {
      if (!abonoOutput) return;
      const fecha = abonoFechaInput?.value || getTodayISODate();
      const pais = abonoPaisSelect?.value || "HN";
      const weeksValue = parseInt(abonoWindowInput?.value, 10);
      const windowWeeks = Number.isFinite(weeksValue) && weeksValue > 0 ? weeksValue : 16;
      abonoOutput.innerHTML = "<p class='hint'>Armando candidatos‚Ä¶</p>";
      try {
        const draws = await getCachedDraws({ force });
        const result = computeAbono(draws, { fecha, pais, weeks: windowWeeks });
        renderAbono(result);
      } catch (err) {
        console.error("abono error", err);
        abonoOutput.innerHTML = `<p class='hint'>No se pudo generar el abono: ${err.message}</p>`;
      }
    }

    function computeAbono(draws = [], options = {}) {
      const { fecha, pais = null, weeks = 16 } = options || {};
      const targetDate = parseDrawDate(fecha) || new Date();
      const targetDow = targetDate.getDay();
      const cutoff = new Date(targetDate.getTime() - Math.max(1, weeks) * 7 * DAY_MS);
      const freq = new Map();
      let totalMatches = 0;
      const candidates = [];

      draws.forEach((raw) => {
        if (raw?.isTest) return;
        if (pais && raw.pais && raw.pais !== pais) return;
        const parsedDate = parseDrawDate(raw.fecha);
        if (!parsedDate) return;
        if (parsedDate < cutoff) return;
        if (parsedDate.getDay() !== targetDow) return;
        const numero = parseInt(raw.numero, 10);
        if (!Number.isFinite(numero)) return;
        totalMatches += 1;
        const key = numero;
        const entry = freq.get(key) || { numero: key, count: 0, last: 0 };
        entry.count += 1;
        const ts = parsedDate.getTime();
        if (ts > entry.last) entry.last = ts;
        freq.set(key, entry);
      });

      const scored = Array.from(freq.values()).map((entry) => {
        const recencyWeeks = entry.last ? (targetDate - entry.last) / DAY_MS / 7 : Infinity;
        const recencyBoost = recencyWeeks === Infinity ? 0 : Math.max(0, 1.2 - recencyWeeks * 0.1);
        const weight = entry.count + recencyBoost;
        return {
          numero: entry.numero,
          count: entry.count,
          last: entry.last || null,
          weight,
        };
      });

      scored.sort((a, b) => b.weight - a.weight || b.count - a.count || (b.last || 0) - (a.last || 0));
      const topList = scored.slice(0, 14);
      const weightSum = topList.reduce((sum, item) => sum + item.weight, 0);
      let pick = null;
      if (topList.length) {
        let r = Math.random() * (weightSum || 1);
        for (const item of topList) {
          r -= item.weight;
          if (r <= 0) {
            pick = item;
            break;
          }
        }
        if (!pick) pick = topList[topList.length - 1];
      }

      return {
        fechaObjetivo: formatDateISO(targetDate),
        dow: targetDow,
        pais,
        weeks,
        totalMatches,
        candidatos: topList,
        abono: pick,
      };
    }

    function renderAbono(result) {
      if (!abonoOutput) return;
      if (!result?.candidatos?.length) {
        resetAbonoOutput("No hay suficientes sorteos para este d√≠a/pa√≠s en la ventana seleccionada.");
        return;
      }
      const { candidatos, abono, fechaObjetivo, dow, weeks, totalMatches, pais } = result;
      const fragment = document.createDocumentFragment();

      const roulette = document.createElement("div");
      roulette.className = "abono-roulette";
      const display = document.createElement("div");
      display.className = "abono-roulette__display";
      display.textContent = abono ? formatAbonoNumber(abono.numero) : "--";
      display.dataset.abonoDisplay = "true";
      const label = document.createElement("div");
      label.className = "abono-roulette__label";
      label.textContent = `Ruleta entre ${candidatos.length} candidatos frecuentes`;
      roulette.appendChild(display);
      roulette.appendChild(label);
      fragment.appendChild(roulette);

      const meta = document.createElement("div");
      meta.className = "abono-meta";
      const dowLabel = DOW_FULL_LABEL[dow] || "d√≠a";
      meta.textContent = `D√≠a objetivo: ${dowLabel} (${fechaObjetivo}) ¬∑ Pa√≠s ${pais || "‚Äî"} ¬∑ Ventana ${weeks} semanas ¬∑ ${totalMatches} sorteos analizados.`;
      fragment.appendChild(meta);

      const chips = document.createElement("div");
      chips.className = "abono-candidates";
      candidatos.forEach((item, idx) => {
        const chip = document.createElement("div");
        chip.className = "abono-chip";
        chip.innerHTML = `<strong>${formatAbonoNumber(item.numero)}</strong> ${item.count} repeticiones`;
        if (idx === 0) chip.dataset.top = "true";
        chips.appendChild(chip);
      });
      fragment.appendChild(chips);

      abonoOutput.innerHTML = "";
      abonoOutput.appendChild(fragment);

      const displayEl = abonoOutput.querySelector("[data-abono-display]");
      if (displayEl && abono) {
        startAbonoRoulette(displayEl, candidatos, abono);
      }
    }

    function startAbonoRoulette(displayEl, candidates, winner) {
      if (!displayEl) return;
      const pool = Array.isArray(candidates) && candidates.length ? candidates : [winner];
      if (abonoSpinTimer) clearInterval(abonoSpinTimer);
      let iterations = 0;
      abonoSpinTimer = setInterval(() => {
        iterations += 1;
        const item = pool[iterations % pool.length] || winner;
        displayEl.textContent = item ? formatAbonoNumber(item.numero) : "--";
      }, 90);
      setTimeout(() => {
        clearInterval(abonoSpinTimer);
        abonoSpinTimer = null;
        displayEl.textContent = winner ? formatAbonoNumber(winner.numero) : "--";
      }, 1400);
    }

    function computeGatillo(draws = [], options = {}) {
      const { gatillo, pais = null, window = 180 } = options || {};
      const num = Number.parseInt(gatillo, 10);
      if (!Number.isFinite(num) || num < 0 || num > 99) {
        return { error: "N√∫mero gatillo inv√°lido." };
      }
      const filtered = (Array.isArray(draws) ? draws : []).filter((d) => !d?.isTest && (!pais || d.pais === pais));
      const parsed = filtered
        .map((d) => {
          const fechaDate = parseDrawDate(d.fecha);
          if (!fechaDate) return null;
          const turnoIdx = HORARIO_ORDER[d.horario] ?? 0;
          return {
            numero: Number.parseInt(d.numero, 10),
            fechaDate,
            horario: d.horario,
            turnoIdx,
            timestamp: fechaDate.getTime() + turnoIdx / 10,
            raw: d,
          };
        })
        .filter(Boolean)
        .sort((a, b) => a.timestamp - b.timestamp);

      const windowed = window > 0 ? parsed.slice(-window) : parsed;
      const counts = new Map();
      let occurrences = 0;

      for (let i = 0; i < windowed.length - 1; i += 1) {
        const current = windowed[i];
        const next = windowed[i + 1];
        if (!current || !next) continue;
        if (current.numero !== num) continue;
        occurrences += 1;
        const entry = counts.get(next.numero) || { numero: next.numero, count: 0, last: next.fechaDate };
        entry.count += 1;
        if (next.fechaDate > entry.last) entry.last = next.fechaDate;
        counts.set(next.numero, entry);
      }

      const result = Array.from(counts.values()).map((item) => ({
        numero: item.numero,
        count: item.count,
        last: item.last,
        ratio: occurrences ? item.count / occurrences : 0,
      }));
      result.sort((a, b) => b.ratio - a.ratio || b.count - a.count || (b.last || 0) - (a.last || 0));

      return {
        gatillo: num,
        pais,
        window: windowed.length,
        occurrences,
        siguientes: result,
      };
    }

    async function runGatillo({ force = false } = {}) {
      if (!gatilloOutput) return;
      const gatilloValue = gatilloNumInput?.value?.trim();
      const pais = gatilloPaisSelect?.value || "ALL";
      const windowVal = parseInt(gatilloWindowInput?.value, 10);
      const windowSize = Number.isFinite(windowVal) && windowVal > 0 ? windowVal : 180;
      gatilloOutput.innerHTML = "<p class='hint'>Buscando secuencias posteriores‚Ä¶</p>";
      try {
        const draws = await getCachedDraws({ force });
        const analysis = computeGatillo(draws, {
          gatillo: gatilloValue,
          pais: pais === "ALL" ? null : pais,
          window: windowSize,
        });
        gatilloCache = analysis;
        renderGatillo(analysis);
      } catch (err) {
        console.error("gatillo error", err);
        gatilloOutput.innerHTML = `<p class='hint'>No se pudo calcular: ${err.message}</p>`;
      }
    }

    function renderGatillo(analysis) {
      if (!gatilloOutput) return;
      if (!analysis || analysis.error) {
        gatilloOutput.innerHTML = `<p class='hint'>${analysis?.error || "No se pudo calcular."}</p>`;
        return;
      }
      const { gatillo, pais, window: win, occurrences, siguientes } = analysis;
      if (!occurrences) {
        gatilloOutput.innerHTML =
          "<p class='hint'>Este n√∫mero no aparece en la ventana seleccionada o no tiene n√∫meros siguientes registrados.</p>";
        return;
      }
      const fragment = document.createDocumentFragment();
      const summary = document.createElement("div");
      summary.className = "gatillo-summary";
      const paisLabel = pais || "todos";
      summary.innerHTML = `Gatillo <strong>${formatNumber(gatillo)}</strong> ¬∑ Pa√≠s ${paisLabel} ¬∑ Ventana ${win} sorteos ¬∑ Ocurrencias ${occurrences}.`;
      fragment.appendChild(summary);

      if (siguientes?.length) {
        const list = document.createElement("div");
        list.className = "gatillo-list";
        const top = siguientes.slice(0, 12);
        top.forEach((item, idx) => {
          const card = document.createElement("div");
          card.className = "gatillo-card";
          const head = document.createElement("div");
          head.innerHTML = `<strong>${formatNumber(item.numero)}</strong> ¬∑ ${
            item.count
          } veces (${Math.round((item.ratio || 0) * 100)}%)`;
          card.appendChild(head);
          const meta = document.createElement("small");
          meta.textContent = item.last ? `√öltima vez: ${formatFriendlyDate(item.last)}` : "";
          card.appendChild(meta);
          if (idx === 0) {
            const chip = document.createElement("small");
            chip.textContent = "M√°s recurrente";
            card.appendChild(chip);
          }
          list.appendChild(card);
        });
        fragment.appendChild(list);
      }

      gatilloOutput.innerHTML = "";
      gatilloOutput.appendChild(fragment);
    }

    function renderWeeklySummary(analysis = null) {
      if (!weeklySummaryEl) return;
      if (!analysis || !analysis.stats?.totalCombos) {
        weeklySummaryEl.innerHTML = "<p class='hint'>No hay suficientes registros para este filtro.</p>";
        return;
      }
      const { stats, filtro } = analysis;
      const paisLabel = filtro?.pais || "todos los pa√≠ses";
      const turnoLabel = filtro?.turno || "todos los turnos";
      const windowSize = filtro?.maxSamples || WEEKLY_DEFAULT_WINDOW;
      const minRepeats = filtro?.minRepeats || 2;
      const summary = document.createElement("div");
      summary.className = "panel-meta";
      summary.innerHTML = `Se revisaron <strong>${stats.totalCombos}</strong> combinaciones (${paisLabel} ¬∑ ${turnoLabel}) usando las √∫ltimas ${windowSize} semanas. <strong>${stats.combosConCiclo}</strong> mantienen ciclos repetidos (‚â• ${minRepeats}).`;
      weeklySummaryEl.innerHTML = "";
      weeklySummaryEl.appendChild(summary);
      if (stats.destacados?.length) {
        const highlight = document.createElement("div");
        highlight.className = "panel-meta muted";
        const snippets = stats.destacados
          .map((combo) => {
            const dowLabel = DOW_FULL_LABEL[combo.dow] || `D√≠a ${combo.dow}`;
            const pattern = formatPatternWithSymbols(combo.cycle?.pattern);
            const ratio = combo.cycle?.coverage ? `${Math.round(combo.cycle.coverage * 100)}%` : "";
            return `${dowLabel} ${combo.horario || ""}: ${pattern} ${ratio ? `(${ratio})` : ""}`.trim();
          })
          .join(" ¬∑ ");
        highlight.textContent = snippets;
        weeklySummaryEl.appendChild(highlight);
      }
    }

    function renderWeeklyGrid(analysis = null) {
      if (!weeklyGridEl) return;
      const combos = analysis?.combos || [];
      if (!combos.length) {
        weeklyGridEl.innerHTML = "<p class='hint'>Necesitas m√°s semanas registradas para este filtro.</p>";
        return;
      }
      const fragment = document.createDocumentFragment();
      combos.forEach((combo) => {
        const card = document.createElement("article");
        card.className = "weekly-card";
        if (combo.cycle) card.classList.add("weekly-card--active");

        const head = document.createElement("div");
        head.className = "weekly-card__head";
        const titleWrap = document.createElement("div");
        const title = document.createElement("div");
        title.className = "weekly-card__title";
        title.textContent = DOW_FULL_LABEL[combo.dow] || `D√≠a ${combo.dow}`;
        const turn = document.createElement("div");
        turn.className = "weekly-card__turn";
        turn.textContent = combo.horario || "‚Äî";
        titleWrap.appendChild(title);
        titleWrap.appendChild(turn);
        head.appendChild(titleWrap);
        if (combo.cycle) {
          const badge = document.createElement("span");
          badge.className = "weekly-card__badge";
          badge.textContent = `${combo.cycle.matchedCycles} ciclos`;
          head.appendChild(badge);
        }
        card.appendChild(head);

        const sequence = document.createElement("div");
        sequence.className = "weekly-card__sequence";
        if (combo.cycle) {
          const patternLine = formatPatternWithSymbols(combo.cycle.pattern);
          sequence.innerHTML = `Secuencia detectada:<div class="weekly-sequence">${patternLine}</div><small>Cubre ${Math.round((combo.cycle.coverage || 0) * 100)}% del historial.</small>`;
        } else {
          const recent = combo.serie.slice(-4).map((n) => formatNumber(n)).join(" ‚Üí ") || "‚Äî";
          sequence.innerHTML = `√öltimos turnos:<div class="weekly-sequence">${recent}</div><small>A√∫n no se confirma un ciclo.</small>`;
        }
        card.appendChild(sequence);

        const prediction = document.createElement("div");
        prediction.className = "weekly-card__prediction";
        const nextInfo = document.createElement("div");
        const nextDateLabel = combo.nextDate ? formatFriendlyDate(combo.nextDate) : "Pr√≥ximo turno";
        nextInfo.innerHTML = `Pr√≥ximo ${combo.horario || "turno"}<br><small>${nextDateLabel}</small>`;
        const nextNumber = document.createElement("strong");
        const nextValue = combo.cycle?.nextNumero;
        nextNumber.textContent = Number.isFinite(nextValue) ? formatNumber(nextValue) : "--";
        prediction.appendChild(nextInfo);
        prediction.appendChild(nextNumber);
        card.appendChild(prediction);

        const historyList = document.createElement("ul");
        historyList.className = "weekly-card__history";
        const samples = combo.muestra.slice().reverse().slice(0, 4);
        if (!samples.length) {
          const empty = document.createElement("li");
          empty.textContent = "Sin historial";
          historyList.appendChild(empty);
        } else {
          samples.forEach((sample) => {
            const li = document.createElement("li");
            const friendly = sample.fecha ? formatFriendlyDate(sample.fecha) : sample.fecha;
            const symbol = getSymbol(sample.numero);
            const paisTag = sample.pais ? ` ¬∑ ${sample.pais}` : "";
            li.textContent = `${friendly}${paisTag} ‚Üí ${formatNumber(sample.numero)}${symbol ? ` ${symbol}` : ""}`;
            historyList.appendChild(li);
          });
        }
        card.appendChild(historyList);

        const actions = document.createElement("div");
        actions.className = "weekly-card__actions";
        const focusBtn = document.createElement("button");
        focusBtn.type = "button";
        focusBtn.textContent = "Ver √∫ltimo";
        if (combo.lastFecha) {
          focusBtn.dataset.weeklyFocus = combo.lastFecha;
          if (combo.lastPais) focusBtn.dataset.pais = combo.lastPais;
        } else {
          focusBtn.disabled = true;
        }
        actions.appendChild(focusBtn);
        const copyBtn = document.createElement("button");
        copyBtn.type = "button";
        copyBtn.textContent = "Copiar secuencia";
        if (combo.cycle?.pattern?.length) {
          copyBtn.dataset.weeklyCopy = formatPatternWithSymbols(combo.cycle.pattern);
        } else {
          copyBtn.disabled = true;
        }
        actions.appendChild(copyBtn);
        card.appendChild(actions);

        fragment.appendChild(card);
      });
      weeklyGridEl.innerHTML = "";
      weeklyGridEl.appendChild(fragment);
    }

    async function refreshWeeklyPanel({ force = false } = {}) {
      if (!weeklyGridEl) return;
      if (!force && weeklySection?.classList.contains("hidden")) return;
      if (weeklyLoading) return;
      weeklyLoading = true;
      if (weeklySummaryEl) weeklySummaryEl.innerHTML = "<p class='hint'>Calculando secuencias‚Ä¶</p>";
      if (weeklyGridEl) weeklyGridEl.innerHTML = "<p class='hint'>Procesando ventana semanal‚Ä¶</p>";
      try {
        const paisValue = weeklyPaisSelect?.value || "ALL";
        const turnoValue = weeklyTurnoSelect?.value || "";
        const windowValue = parseInt(weeklyWindowInput?.value, 10);
        const repeatsValue = parseInt(weeklyRepeatsInput?.value, 10);
        const draws = await getCachedDraws({ force });
        const analysis = analizarSecuenciasSemanales(draws, {
          pais: paisValue === "ALL" ? null : paisValue,
          turno: turnoValue || null,
          maxSamples: Number.isFinite(windowValue) && windowValue > 3 ? windowValue : WEEKLY_DEFAULT_WINDOW,
          minRepeats: Number.isFinite(repeatsValue) ? Math.max(2, repeatsValue) : 2,
        });
        weeklyLastAnalysis = analysis;
        renderWeeklySummary(analysis);
        renderWeeklyGrid(analysis);
        await refreshLinesPanel({
          force: true,
          draws,
          weeksOverride: windowValue,
          repeatsOverride: repeatsValue,
        });
      } catch (err) {
        console.error("weekly panel error", err);
        if (weeklySummaryEl) weeklySummaryEl.innerHTML = `<p class='hint'>No se pudo calcular: ${err.message}</p>`;
        if (weeklyGridEl) weeklyGridEl.innerHTML = "";
      } finally {
        weeklyLoading = false;
      }
    }

    async function refreshLinesPanel({ force = false, draws = null, weeksOverride = null, repeatsOverride = null } = {}) {
      if (!linesBodyEl) return;
      if (!force && weeklySection?.classList.contains("hidden")) return;
      if (linesLoading) return;
      linesLoading = true;
      linesBodyEl.innerHTML = "<p class='hint'>Calculando rotaci√≥n de l√≠neas‚Ä¶</p>";
      if (linesMissingBodyEl) {
        linesMissingBodyEl.innerHTML = "<p class='hint'>Buscando pendientes por l√≠nea‚Ä¶</p>";
      }
      try {
        const paisValue = weeklyPaisSelect?.value || "ALL";
        const turnoValue = weeklyTurnoSelect?.value || "";
        const weeksValue = Number.isFinite(weeksOverride) ? weeksOverride : parseInt(weeklyWindowInput?.value, 10);
        const repeatsValue = Number.isFinite(repeatsOverride) ? repeatsOverride : parseInt(weeklyRepeatsInput?.value, 10);
        const dataset = Array.isArray(draws) ? draws : await getCachedDraws({ force });
        const analysis = analizarRotacionLineas(dataset, {
          pais: paisValue === "ALL" ? null : paisValue,
          turno: turnoValue || null,
          weeks: Number.isFinite(weeksValue) && weeksValue > 0 ? weeksValue : WEEKLY_DEFAULT_WINDOW,
          minRepeats: Number.isFinite(repeatsValue) ? Math.max(2, repeatsValue) : 2,
        });
        lastLinesAnalysis = analysis;
        renderLinesRotation(analysis);
      } catch (err) {
        console.error("lines rotation error", err);
        linesBodyEl.innerHTML = `<p class='hint'>No se pudo calcular: ${err.message}</p>`;
        if (linesMissingBodyEl) {
          linesMissingBodyEl.innerHTML = `<p class='hint'>Sin faltantes: ${err.message}</p>`;
        }
      } finally {
        linesLoading = false;
      }
    }

    function formatMonthLabel(year, monthIdx) {
      if (!Number.isFinite(year) || !Number.isFinite(monthIdx)) return "Mes";
      const monthName = MONTH_NAMES[monthIdx] || "Mes";
      const capitalized = `${monthName.charAt(0).toUpperCase()}${monthName.slice(1)}`;
      return `${capitalized} ${year}`;
    }

    function renderMonthlySummary(analysis = null) {
      if (!monthlySummaryEl) return;
      if (!analysis || !analysis.months?.length) {
        monthlySummaryEl.innerHTML = "<p class='hint'>A√∫n no hay meses suficientes con ese filtro.</p>";
        return;
      }
      const { stats, filtro } = analysis;
      const dowLabel = Number.isFinite(filtro?.dow) ? DOW_FULL_LABEL[filtro.dow] || "d√≠a" : "d√≠a";
      const turnoLabel = filtro?.turno || "todos los turnos";
      const paisLabel = filtro?.pais || "todos los pa√≠ses";
      const summary = document.createElement("div");
      summary.className = "panel-meta";
      summary.innerHTML = `Meses comparados: <strong>${stats.totalMonths}</strong> (${dowLabel} ¬∑ ${turnoLabel} ¬∑ ${paisLabel}).`;
      monthlySummaryEl.innerHTML = "";
      monthlySummaryEl.appendChild(summary);
      const extras = document.createElement("div");
      extras.className = "panel-meta muted";
      const snippets = [];
      if (stats.startCycle?.pattern?.length) {
        snippets.push(
          `Arranques repiten ${formatPatternWithSymbols(stats.startCycle.pattern)} (${Math.round(
            (stats.startCycle.coverage || 0) * 100,
          )}% cobertura).`,
        );
      }
      if (stats.endCycle?.pattern?.length) {
        snippets.push(
          `Cierres repiten ${formatPatternWithSymbols(stats.endCycle.pattern)} (${Math.round(
            (stats.endCycle.coverage || 0) * 100,
          )}% cobertura).`,
        );
      }
      extras.textContent = snippets.length ? snippets.join(" ") : "Sin patrones mensuales claros a√∫n.";
      monthlySummaryEl.appendChild(extras);
    }

    function formatEntryTag(entry) {
      if (!entry) return "Sin registro";
      const friendly = entry.fecha ? formatFriendlyDate(entry.fecha) : "Sin fecha";
      const turn = entry.horario ? ` ¬∑ ${entry.horario}` : "";
      return `${friendly}${turn}`;
    }

    function formatEntryList(entries = []) {
      if (!Array.isArray(entries) || !entries.length) return "";
      return entries
        .map((entry) => {
          const formatted = `${formatNumber(entry.numero)}${getSymbol(entry.numero) ? ` ${getSymbol(entry.numero)}` : ""}`;
          const friendly = entry.fecha ? formatFriendlyDate(entry.fecha) : "";
          return friendly ? `${formatted} (${friendly})` : formatted;
        })
        .join(" ¬∑ ");
    }

    function buildMonthlyBlock(label, entry, extraDetail = "") {
      const container = document.createElement("div");
      container.className = "monthly-block";
      const lbl = document.createElement("label");
      lbl.textContent = label;
      container.appendChild(lbl);
      const number = document.createElement("strong");
      const numero = entry?.numero;
      const formatted = Number.isFinite(numero) ? formatNumber(numero) : "--";
      const symbol = Number.isFinite(numero) ? getSymbol(numero) : "";
      number.innerHTML = symbol ? `${formatted} <span class="monthly-block__symbol">${symbol}</span>` : formatted;
      container.appendChild(number);
      const meta = document.createElement("small");
      meta.textContent = formatEntryTag(entry);
      container.appendChild(meta);
      if (extraDetail) {
        const extra = document.createElement("small");
        extra.textContent = extraDetail;
        container.appendChild(extra);
      }
      return container;
    }

    function renderMonthlyTable(analysis = null) {
      if (!monthlyTableEl) return;
      const months = analysis?.months || [];
      if (!months.length) {
        monthlyTableEl.innerHTML = "<p class='hint'>No hay meses con datos suficientes para este d√≠a.</p>";
        return;
      }
      const fragment = document.createDocumentFragment();
      months
        .slice()
        .reverse()
        .forEach((month) => {
          const row = document.createElement("article");
          row.className = "monthly-row";

          const head = document.createElement("div");
          head.className = "monthly-row__head";
          const meta = document.createElement("div");
          meta.className = "monthly-row__meta";
          const label = formatMonthLabel(month.year, month.month);
          meta.innerHTML = `<strong>${label}</strong><span>${month.total} sorteos reales</span>`;
          head.appendChild(meta);

          if (month.first?.fecha || month.last?.fecha) {
            const range = document.createElement("div");
            range.className = "monthly-row__range";
            const startLabel = month.first?.fecha ? formatFriendlyDate(month.first.fecha) : "Sin inicio";
            const endLabel = month.last?.fecha ? formatFriendlyDate(month.last.fecha) : "Sin cierre";
            range.innerHTML = `<span>${startLabel}</span><span>‚Üí</span><span>${endLabel}</span>`;
            head.appendChild(range);
          }
          row.appendChild(head);

          const grid = document.createElement("div");
          grid.className = "monthly-row__grid";
          grid.appendChild(buildMonthlyBlock("Arranque", month.first));
          grid.appendChild(buildMonthlyBlock("Mitad del mes", month.mid, formatEntryList(month.midWindow)));
          grid.appendChild(buildMonthlyBlock("Cierre", month.last));

          const tailBlock = document.createElement("div");
          tailBlock.className = "monthly-block";
          const tailLabel = document.createElement("label");
          tailLabel.textContent = "√öltimas jugadas";
          tailBlock.appendChild(tailLabel);
          if (month.tail?.length) {
            const tailList = document.createElement("ul");
            tailList.className = "monthly-tail";
            month.tail
              .slice()
              .reverse()
              .forEach((entry) => {
                const item = document.createElement("li");
                const value = document.createElement("strong");
                const formatted = `${formatNumber(entry.numero)}${getSymbol(entry.numero) ? ` ${getSymbol(entry.numero)}` : ""}`;
                value.textContent = formatted;
                const metaDetail = document.createElement("span");
                const detailBits = [];
                if (entry.fecha) detailBits.push(formatFriendlyDate(entry.fecha));
                if (entry.horario) detailBits.push(entry.horario);
                if (entry.pais) detailBits.push(entry.pais);
                metaDetail.textContent = detailBits.join(" ¬∑ ") || "Sin fecha";
                item.append(value, metaDetail);
                tailList.appendChild(item);
              });
            tailBlock.appendChild(tailList);
          } else {
            const emptyTail = document.createElement("small");
            emptyTail.textContent = "Sin datos recientes";
            tailBlock.appendChild(emptyTail);
          }
          grid.appendChild(tailBlock);
          row.appendChild(grid);

          const actions = document.createElement("div");
          actions.className = "monthly-row__actions";
          const viewStart = document.createElement("button");
          viewStart.type = "button";
          viewStart.textContent = "Ver arranque";
          if (month.first?.fecha) {
            viewStart.dataset.monthlyFocus = month.first.fecha;
            if (month.first.pais) viewStart.dataset.pais = month.first.pais;
          } else {
            viewStart.disabled = true;
          }
          const viewEnd = document.createElement("button");
          viewEnd.type = "button";
          viewEnd.textContent = "Ver cierre";
          if (month.last?.fecha) {
            viewEnd.dataset.monthlyFocus = month.last.fecha;
            if (month.last.pais) viewEnd.dataset.pais = month.last.pais;
          } else {
            viewEnd.disabled = true;
          }
          actions.appendChild(viewStart);
          actions.appendChild(viewEnd);
          row.appendChild(actions);
          fragment.appendChild(row);
        });
      monthlyTableEl.innerHTML = "";
      monthlyTableEl.appendChild(fragment);
    }

    async function refreshMonthlyPanel({ force = false } = {}) {
      if (!monthlyTableEl) return;
      if (monthlyLoading) return;
      monthlyLoading = true;
      if (monthlySummaryEl) monthlySummaryEl.innerHTML = "<p class='hint'>Calculando comparaci√≥n mensual‚Ä¶</p>";
      if (monthlyTableEl) monthlyTableEl.innerHTML = "<p class='hint'>Procesando meses‚Ä¶</p>";
      try {
        const paisValue = monthlyPaisSelect?.value || "ALL";
        const dowValue = parseInt(monthlyDowSelect?.value, 10);
        const turnoValue = monthlyTurnoSelect?.value || "";
        const monthsValue = parseInt(monthlyMonthsInput?.value, 10);
        const draws = await getCachedDraws({ force });
        const analysis = analizarComparacionMensual(draws, {
          pais: paisValue === "ALL" ? null : paisValue,
          dow: Number.isFinite(dowValue) ? dowValue : null,
          turno: turnoValue || null,
          monthsBack: Number.isFinite(monthsValue) ? Math.min(Math.max(monthsValue, 3), 24) : 8,
        });
        monthlyLastAnalysis = analysis;
        renderMonthlySummary(analysis);
        renderMonthlyTable(analysis);
      } catch (err) {
        console.error("monthly panel error", err);
        if (monthlySummaryEl) monthlySummaryEl.innerHTML = `<p class='hint'>No se pudo calcular: ${err.message}</p>`;
        if (monthlyTableEl) monthlyTableEl.innerHTML = "";
      } finally {
        monthlyLoading = false;
      }
    }

    function renderMonthlyTrendSummary(analysis = null) {
      if (!monthlyTrendSummaryEl) return;
      const total = analysis?.stats?.totalDraws || 0;
      if (!total) {
        monthlyTrendSummaryEl.innerHTML = "<p class='hint'>No hay suficientes sorteos reales para este mes.</p>";
        return;
      }
      const monthLabel = analysis?.monthLabel || "El mes";
      const paisLabel = analysis?.filtro?.pais || "todos los pa√≠ses";
      const turnoLabel = analysis?.filtro?.turno || "todos los turnos";
      const yearsCount = analysis?.stats?.yearsCount || 0;
      const repeatPct = Math.round((analysis?.stats?.repeatShare || 0) * 100);
      const consecutivePct = Math.round((analysis?.stats?.consecutiveShare || 0) * 100);
      const summary = document.createElement("div");
      summary.className = "panel-meta";
      summary.innerHTML = `${monthLabel} (${paisLabel} ¬∑ ${turnoLabel}): <strong>${total}</strong> sorteos reales en los √∫ltimos <strong>${yearsCount}</strong> a√±os. ${repeatPct}% repite n√∫meros ya vistos en ese mes.`;
      const trendDelta = analysis?.stats?.trend?.delta;
      const hasTrendShift = typeof trendDelta === "number" && Math.abs(trendDelta) >= 1;
      const metrics = document.createElement("div");
      metrics.className = "monthly-trend-metrics";
      const metricData = [
        { label: "Repeticiones", value: `${repeatPct}%` },
        { label: "Duplicados seguidos", value: `${consecutivePct}%` },
        { label: "N√∫meros √∫nicos", value: analysis?.stats?.uniqueNumbers ?? "‚Äî" },
        {
          label: "Tendencia",
          value: hasTrendShift ? `${trendDelta > 0 ? "+" : ""}${Math.round(trendDelta)}` : "Estable",
        },
      ];
      metrics.innerHTML = metricData
        .map(
          (item) => `
            <div class="monthly-metric">
              <span>${item.label}</span>
              <strong>${item.value}</strong>
            </div>
          `,
        )
        .join("");
      monthlyTrendSummaryEl.innerHTML = "";
      monthlyTrendSummaryEl.append(summary, metrics);
    }

    function renderMonthlyTrendAlerts(analysis = null) {
      if (!monthlyTrendAlertsEl) return;
      const alerts = analysis?.stats?.alerts || [];
      if (!alerts.length) {
        monthlyTrendAlertsEl.innerHTML = "<p class='hint'>Sin alertas cr√≠ticas para este filtro.</p>";
        return;
      }
      const fragment = document.createDocumentFragment();
      alerts.forEach((alert) => {
        const card = document.createElement("div");
        card.className = "trend-alert";
        card.dataset.type = alert.type || "generic";
        const title = document.createElement("strong");
        title.textContent = alert.title || "Alerta";
        const detail = document.createElement("p");
        detail.textContent = alert.detail || "";
        card.append(title, detail);
        fragment.appendChild(card);
      });
      monthlyTrendAlertsEl.innerHTML = "";
      monthlyTrendAlertsEl.appendChild(fragment);
    }

    function buildTrendChart(analysis = null) {
      if (!monthlyTrendChartEl) return;
      const timeline = analysis?.timeline || [];
      if (!timeline.length) {
        monthlyTrendChartEl.innerHTML = "<p class='hint'>No hay datos suficientes para graficar.</p>";
        return;
      }
      const MAX_POINTS = 160;
      const series = timeline.slice(-MAX_POINTS);
      const width = Math.max(320, series.length * 12);
      const height = 220;
      const padding = 28;
      const chartWidth = width - padding * 2;
      const chartHeight = height - padding * 2;
      const svgNS = "http://www.w3.org/2000/svg";
      const svg = document.createElementNS(svgNS, "svg");
      svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
      svg.setAttribute("preserveAspectRatio", "none");
      svg.classList.add("trend-chart__svg");

      const gridValues = [0, 25, 50, 75, 99];
      gridValues.forEach((value) => {
        const y = padding + chartHeight - (value / 99) * chartHeight;
        const line = document.createElementNS(svgNS, "line");
        line.setAttribute("x1", padding);
        line.setAttribute("x2", width - padding);
        line.setAttribute("y1", y);
        line.setAttribute("y2", y);
        line.classList.add("trend-chart__grid");
        svg.appendChild(line);
        const label = document.createElementNS(svgNS, "text");
        label.setAttribute("x", 6);
        label.setAttribute("y", y + 4);
        label.textContent = String(value).padStart(2, "0");
        label.classList.add("trend-chart__grid-label");
        svg.appendChild(label);
      });

      const coords = series.map((entry, idx) => {
        const step = series.length > 1 ? idx / (series.length - 1) : 0.5;
        const x = padding + chartWidth * step;
        const y = padding + chartHeight - (entry.numero / 99) * chartHeight;
        return { x, y, entry };
      });

      if (coords.length >= 2) {
        const path = document.createElementNS(svgNS, "path");
        path.setAttribute(
          "d",
          coords
            .map((point, idx) => `${idx === 0 ? "M" : "L"} ${point.x.toFixed(2)} ${point.y.toFixed(2)}`)
            .join(" "),
        );
        path.classList.add("trend-chart__path");
        svg.appendChild(path);
      }

      coords.forEach((point) => {
        const circle = document.createElementNS(svgNS, "circle");
        circle.setAttribute("cx", point.x);
        circle.setAttribute("cy", point.y);
        circle.setAttribute("r", point.entry.isRepeat ? 3.6 : 2.6);
        circle.classList.add("trend-chart__point");
        if (point.entry.isRepeat) circle.classList.add("trend-chart__point--repeat");
        const tooltip = document.createElementNS(svgNS, "title");
        const friendly = point.entry.fecha ? formatFriendlyDate(point.entry.fecha) : "";
        tooltip.textContent = `${friendly} ${point.entry.horario || ""} ¬∑ ${formatNumber(point.entry.numero)}${
          point.entry.isRepeat ? " (repetido)" : ""
        }`;
        circle.appendChild(tooltip);
        svg.appendChild(circle);
      });

      monthlyTrendChartEl.innerHTML = "";
      monthlyTrendChartEl.appendChild(svg);
      const legend = document.createElement("div");
      legend.className = "trend-chart__legend";
      legend.innerHTML = `
        <span>${series.length} sorteos recientes</span>
        <span>${Math.round((analysis?.stats?.repeatShare || 0) * 100)}% repeticiones ¬∑ ${Math.round(
        (analysis?.stats?.consecutiveShare || 0) * 100,
      )}% consecutivas</span>
      `;
      monthlyTrendChartEl.appendChild(legend);
    }

    function renderMonthlyTrendHotlist(analysis = null) {
      if (!monthlyTrendHotlistEl) return;
      const topNumbers = analysis?.stats?.topNumbers || [];
      if (!topNumbers.length) {
        monthlyTrendHotlistEl.innerHTML = "<p class='hint'>A√∫n no hay dominantes claros para este mes.</p>";
        return;
      }
      const list = document.createElement("ul");
      list.className = "monthly-trend-hotlist__list";
      topNumbers.forEach((item) => {
        const li = document.createElement("li");
        li.innerHTML = `
          <div class="hotlist-main">
            <span class="hotlist-number">${formatNumber(item.numero)}</span>
            <span class="hotlist-count">${item.count} repeticiones</span>
          </div>
          <div class="hotlist-meta">${item.years?.length || 0} a√±os ¬∑ √öltima vez ${item.lastFecha ? formatFriendlyDate(item.lastFecha) : "‚Äî"}</div>
        `;
        if (item.lastFecha) {
          const focusBtn = document.createElement("button");
          focusBtn.type = "button";
          focusBtn.textContent = "Ver √∫ltimo";
          focusBtn.dataset.trendFocus = item.lastFecha;
          if (item.lastPais) focusBtn.dataset.pais = item.lastPais;
          li.appendChild(focusBtn);
        }
        list.appendChild(li);
      });
      monthlyTrendHotlistEl.innerHTML = "";
      monthlyTrendHotlistEl.appendChild(list);
    }

    function renderMonthlyTrendYears(analysis = null) {
      if (!monthlyTrendYearsEl) return;
      const rows = analysis?.yearBreakdown || [];
      if (!rows.length) {
        monthlyTrendYearsEl.innerHTML = "<p class='hint'>Registra m√°s sorteos para comparar a√±os.</p>";
        return;
      }
      const table = document.createElement("table");
      table.className = "monthly-trend-years__table";
      table.innerHTML = `
        <thead>
          <tr>
            <th>A√±o</th>
            <th>Sorteos</th>
            <th>% repetidos</th>
            <th>√önicos</th>
          </tr>
        </thead>
        <tbody></tbody>
      `;
      const tbody = table.querySelector("tbody");
      rows.forEach((row) => {
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${row.year}</td>
          <td>${row.total}</td>
          <td>${Math.round((row.repeatShare || 0) * 100)}%</td>
          <td>${row.unique}</td>
        `;
        tbody.appendChild(tr);
      });
      monthlyTrendYearsEl.innerHTML = "";
      monthlyTrendYearsEl.appendChild(table);
    }

    async function refreshMonthlyTrendsPanel({ force = false } = {}) {
      if (!monthlyTrendSummaryEl) return;
      if (monthlyTrendLoading) return;
      monthlyTrendLoading = true;
      if (monthlyTrendSummaryEl) monthlyTrendSummaryEl.innerHTML = "<p class='hint'>Calculando patrones del mes‚Ä¶</p>";
      if (monthlyTrendAlertsEl) monthlyTrendAlertsEl.innerHTML = "<p class='hint'>Buscando alertas‚Ä¶</p>";
      if (monthlyTrendChartEl) monthlyTrendChartEl.innerHTML = "<p class='hint'>Generando gr√°fica‚Ä¶</p>";
      try {
        const monthValue = parseInt(monthlyTrendMonthSelect?.value, 10);
        const paisValue = monthlyTrendPaisSelect?.value || "ALL";
        const turnoValue = monthlyTrendTurnoSelect?.value || "";
        const yearsValue = parseInt(monthlyTrendYearsInput?.value, 10);
        const draws = await getCachedDraws({ force });
        const analysis = analizarPatronesMensuales(draws, {
          month: Number.isFinite(monthValue) ? monthValue : new Date().getMonth(),
          pais: paisValue === "ALL" ? null : paisValue,
          turno: turnoValue || null,
          yearsBack: Number.isFinite(yearsValue) ? Math.min(Math.max(yearsValue, 2), 10) : 5,
        });
        monthlyTrendLastAnalysis = analysis;
        renderMonthlyTrendSummary(analysis);
        renderMonthlyTrendAlerts(analysis);
        buildTrendChart(analysis);
        renderMonthlyTrendHotlist(analysis);
        renderMonthlyTrendYears(analysis);
      } catch (err) {
        console.error("monthly trend panel error", err);
        if (monthlyTrendSummaryEl) monthlyTrendSummaryEl.innerHTML = `<p class='hint'>No se pudo calcular: ${err.message}</p>`;
        if (monthlyTrendAlertsEl) monthlyTrendAlertsEl.innerHTML = "";
        if (monthlyTrendChartEl) monthlyTrendChartEl.innerHTML = "";
        if (monthlyTrendHotlistEl) monthlyTrendHotlistEl.innerHTML = "<p class='hint'>No disponible.</p>";
        if (monthlyTrendYearsEl) monthlyTrendYearsEl.innerHTML = "";
      } finally {
        monthlyTrendLoading = false;
      }
    }

    function buildRankingData(draws = []) {
      const byYear = new Map();
      const totals = new Map();
      const lastSeen = new Map();
      const totalByYear = new Map();
      draws.forEach((draw) => {
        const numero = Number(draw.numero);
        if (!Number.isFinite(numero)) return;
        const fecha = draw.fecha;
        if (!fecha || fecha.length < 4) return;
        const year = parseInt(fecha.slice(0, 4), 10);
        if (!Number.isFinite(year)) return;
        if (!byYear.has(year)) byYear.set(year, new Map());
        const yearMap = byYear.get(year);
        yearMap.set(numero, (yearMap.get(numero) || 0) + 1);
        totals.set(numero, (totals.get(numero) || 0) + 1);
        totalByYear.set(year, (totalByYear.get(year) || 0) + 1);
        const timestamp = Date.parse(`${fecha}T00:00:00Z`);
        const prev = lastSeen.get(numero);
        if (!prev || (!Number.isNaN(timestamp) && timestamp > (prev.timestamp || 0))) {
          lastSeen.set(numero, {
            fecha,
            horario: draw.horario,
            pais: draw.pais,
            timestamp: Number.isNaN(timestamp) ? null : timestamp,
          });
        }
      });
      const years = Array.from(byYear.keys()).sort((a, b) => b - a);
      return { years, byYear, totals, lastSeen, totalByYear };
    }

    async function ensureRankingData({ force = false } = {}) {
      if (!rankingDataCache || force) {
        const draws = await getCachedDraws({ force });
        rankingDataCache = buildRankingData(draws);
      }
      return rankingDataCache;
    }

    function buildRankingArray(map = new Map(), lastSeen = new Map()) {
      return Array.from(map.entries())
        .map(([numero, count]) => ({
          numero: Number(numero),
          count,
          symbol: getSymbol(numero),
          lastSeen: lastSeen.get(Number(numero)) || null,
        }))
        .sort((a, b) => {
          if (b.count !== a.count) return b.count - a.count;
          return a.numero - b.numero;
        });
    }

    function applyRankingTabFilter(list = [], tab = "hot") {
      if (!list.length) return [];
      if (tab === "hot") return list.slice(0, Math.min(10, list.length));
      if (tab === "frequent") return list.slice(10, Math.min(25, list.length));
      if (tab === "cold") {
        const safeLength = Math.max(0, list.length - 5);
        const start = Math.max(0, safeLength - 15);
        return list.slice(start, safeLength);
      }
      if (tab === "rare") return list.filter((row) => row.count <= 2).slice(0, 20);
      return list;
    }

    function formatLastSeen(info) {
      if (!info || !info.fecha) return "‚Äî";
      const friendly = formatFriendlyDate(info.fecha);
      const horario = info.horario ? ` ${info.horario}` : "";
      const pais = info.pais ? ` ¬∑ ${info.pais}` : "";
      return `${friendly}${horario}${pais}`.trim();
    }

    function updateRankingSummary({ total, yearLabel, visible }) {
      if (!rankingSummaryEl) return;
      if (!visible) {
        rankingSummaryEl.textContent = "Sin datos para este periodo.";
        return;
      }
      const label = yearLabel === "all" ? "todos los a√±os" : yearLabel;
      rankingSummaryEl.textContent = `Ranking ${label} ¬∑ ${total} apariciones ¬∑ vista ${rankingActiveTab}`;
    }

    function renderRankingInsight(entry, yearLabel) {
      if (!rankingInsightEl) return;
      if (!entry) {
        rankingInsightEl.textContent = "Busca un n√∫mero para ver su historial.";
        return;
      }
      const label = yearLabel === "all" ? "el hist√≥rico completo" : `el a√±o ${yearLabel}`;
      rankingInsightEl.textContent = `${formatNumber(entry.numero)} aparece ${entry.count} ${
        entry.count === 1 ? "vez" : "veces"
      } en ${label}. √öltima vez: ${formatLastSeen(entry.lastSeen)}.`;
    }

    async function renderRankingPanel({ force = false } = {}) {
      if (!rankingTableWrap) return;
      const data = await ensureRankingData({ force });
      if (!data.years.length && !data.totals.size) {
        rankingTableWrap.innerHTML = "<p class='hint'>Registra sorteos para ver el ranking.</p>";
        updateRankingSummary({ total: 0, yearLabel: "all", visible: false });
        renderRankingInsight(null, "all");
        return;
      }
      if (rankingYearSelect && !rankingYearSelect.options.length) {
        const frag = document.createDocumentFragment();
        const opt = document.createElement("option");
        opt.value = "all";
        opt.textContent = "Todos los a√±os";
        frag.appendChild(opt);
        data.years.forEach((year) => {
          const option = document.createElement("option");
          option.value = String(year);
          option.textContent = String(year);
          frag.appendChild(option);
        });
        rankingYearSelect.appendChild(frag);
        rankingYearSelect.value = data.years[0] ? String(data.years[0]) : "all";
      }
      const yearValue = rankingYearSelect?.value || "all";
      const map =
        yearValue === "all"
          ? data.totals
          : data.byYear.get(Number(yearValue)) || new Map();
      const dataset = buildRankingArray(map, data.lastSeen);
      if (!dataset.length) {
        rankingTableWrap.innerHTML = "<p class='hint'>Sin registros para este a√±o.</p>";
        updateRankingSummary({ total: 0, yearLabel: yearValue, visible: false });
        renderRankingInsight(null, yearValue);
        return;
      }
      const total =
        yearValue === "all"
          ? Array.from(data.totals.values()).reduce((acc, val) => acc + val, 0)
          : data.totalByYear.get(Number(yearValue)) || dataset.reduce((acc, row) => acc + row.count, 0);
      const filtered = applyRankingTabFilter(dataset, rankingActiveTab);
      if (!filtered.length) {
        rankingTableWrap.innerHTML = "<p class='hint'>No hay n√∫meros para esta vista.</p>";
      } else {
        const table = document.createElement("table");
        table.innerHTML = `
          <thead>
            <tr>
              <th>#</th>
              <th>N√∫mero</th>
              <th>S√≠mbolo</th>
              <th>Veces</th>
              <th>√öltima vez</th>
            </tr>
          </thead>
          <tbody></tbody>
        `;
        const tbody = table.querySelector("tbody");
        filtered.forEach((row, idx) => {
          const tr = document.createElement("tr");
          if (rankingSearchTarget !== null && row.numero === rankingSearchTarget) {
            tr.classList.add("history-row--tracked");
          }
          tr.innerHTML = `
            <td>${idx + 1}</td>
            <td class="history-number">${formatNumber(row.numero)}</td>
            <td>${row.symbol || "‚Äî"}</td>
            <td>${row.count}</td>
            <td>${formatLastSeen(row.lastSeen)}</td>
          `;
          tbody.appendChild(tr);
        });
        rankingTableWrap.innerHTML = "";
        rankingTableWrap.appendChild(table);
      }
      const highlightEntry =
        rankingSearchTarget === null
          ? null
          : dataset.find((row) => row.numero === rankingSearchTarget) || null;
      updateRankingSummary({
        total,
        yearLabel: yearValue,
        visible: true,
      });
      renderRankingInsight(highlightEntry, yearValue);
    }

    function handleRankingSearch() {
      const raw = (rankingSearchInput?.value || "").trim();
      if (!raw) {
        rankingSearchTarget = null;
        renderRankingPanel();
        renderRankingInsight(null, rankingYearSelect?.value || "all");
        return;
      }
      const numero = parseInt(raw, 10);
      if (!Number.isFinite(numero) || numero < 0 || numero > 99) {
        showToast("Ingresa un n√∫mero v√°lido entre 00 y 99 para buscar en el ranking.", { variant: "warning" });
        return;
      }
      rankingSearchTarget = numero;
      if (rankingSearchInput) rankingSearchInput.value = formatNumber(numero);
      renderRankingPanel();
    }

    function autoFollowIfToday(fecha, pais) {
      if (!fecha) return;
      if (fecha === todayISO && (!trackingState || trackingState.fecha !== fecha || trackingState.pais !== pais)) {
        trackingState = { fecha, pais };
        saveTrackingState(trackingState);
      }
    }

    async function handleDrawsMutated() {
      invalidateDrawCache();
      invalidateMemoryCache();
      await Promise.allSettled([
        refreshHistoryPanel({ forceReload: true }),
        renderTrackingPanel({ forceReload: true }),
        renderRankingPanel({ force: true }),
        refreshNotebookList(),
        renderMemoryBoard({ forceReload: true }),
        renderGapPanel({ forceReload: true }),
        refreshDecemberStrategyPanel({ force: true }),
      ]);
      await refreshPatternsPanel({ force: true });
      await renderStrategiesPanel({ force: true, skipEnsure: true });
      await ejecutarAnalisis({ auto: true });
      if (Number.isFinite(memorySelectedNumero)) {
        await openMemoryDetail(memorySelectedNumero);
      }
    }

    async function bootstrapExtendedPanels() {
      await Promise.allSettled([
        refreshHistoryPanel(),
        renderTrackingPanel(),
        refreshPatternsPanel(),
        renderRankingPanel(),
        refreshNotebookList(),
      ]);
    }

    await bootstrapExtendedPanels();
    await refreshDecemberStrategyPanel();

    const hypoFechaInput = document.getElementById("h-fecha");
    const hypoTurnoSelect = document.getElementById("h-turno");
    const hypoNumeroInput = document.getElementById("h-numero");
    const hypoTextoInput = document.getElementById("h-texto");
    const btnHipotesis = document.getElementById("h-guardar");
    const reminderNumeroInput = document.getElementById("hr-numero");
    const reminderNotaInput = document.getElementById("hr-nota");
    const reminderAddBtn = document.getElementById("hr-guardar");
    let editingHypothesisId = null;

    async function refreshHypothesisReminders() {
      const list = document.getElementById("hr-list");
      if (!list) return;
      const reminders = await DB.listHypothesisReminders();
      if (!reminders.length) {
        list.innerHTML = "<p class='hint'>Sin recordatorios pendientes.</p>";
        return;
      }
      list.innerHTML = "";
      reminders
        .slice()
        .sort((a, b) => (b.createdAt || 0) - (a.createdAt || 0))
        .forEach((rem) => {
          const item = document.createElement("div");
          item.className = "reminder-item";

          const info = document.createElement("div");
          info.className = "reminder-info";
          const simbolo = rem.simbolo || getSymbol(rem.numero) || "";
          info.textContent = `${formatNumber(rem.numero)} ${simbolo}`.trim();
          if (rem.nota) {
            const note = document.createElement("span");
            note.textContent = rem.nota;
            info.appendChild(note);
          }
          item.appendChild(info);

          const actions = document.createElement("div");
          actions.className = "reminder-actions";

          const useBtn = document.createElement("button");
          useBtn.type = "button";
          useBtn.className = "btn-secondary";
          useBtn.textContent = "Usar";
          useBtn.addEventListener("click", () => {
            if (hypoNumeroInput) hypoNumeroInput.value = formatNumber(rem.numero);
            if (hypoTextoInput && rem.nota) hypoTextoInput.value = rem.nota;
            showToast(`Recordatorio cargado para ${formatNumber(rem.numero)}.`, {
              variant: "info",
              timeout: 2400,
            });
          });
          actions.appendChild(useBtn);

          const removeBtn = document.createElement("button");
          removeBtn.type = "button";
          removeBtn.className = "btn-ghost";
          removeBtn.textContent = "Quitar";
          removeBtn.addEventListener("click", async () => {
            await DB.removeHypothesisReminder(rem.id);
            await refreshHypothesisReminders();
            showToast("Recordatorio eliminado.", { variant: "success", timeout: 2000 });
          });
          actions.appendChild(removeBtn);

          item.appendChild(actions);
          list.appendChild(item);
        });
    }

    async function handleReminderAdd() {
      const rawNumero = (reminderNumeroInput?.value || "").trim();
      if (!rawNumero) {
        showToast("Ingresa el n√∫mero del recordatorio.", { variant: "warning" });
        return;
      }
      const numero = parseInt(rawNumero, 10);
      if (!Number.isFinite(numero) || numero < 0 || numero > 99) {
        showToast("N√∫mero inv√°lido para el recordatorio.", { variant: "danger" });
        return;
      }
      const nota = (reminderNotaInput?.value || "").trim();
      try {
        const simbolo = getSymbol(numero) || "";
        await DB.addHypothesisReminder({ numero, nota, simbolo });
        if (reminderNumeroInput) reminderNumeroInput.value = "";
        if (reminderNotaInput) reminderNotaInput.value = "";
        await refreshHypothesisReminders();
        showToast("Recordatorio guardado.", { variant: "success", timeout: 2000 });
      } catch (err) {
        console.error("recordatorio error", err);
        showToast(`No se pudo guardar el recordatorio: ${err.message}`, { variant: "danger" });
      }
    }

    reminderAddBtn?.addEventListener("click", handleReminderAdd);
    reminderNumeroInput?.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        event.preventDefault();
        handleReminderAdd();
      }
    });
    reminderNotaInput?.addEventListener("keydown", (event) => {
      if (event.key === "Enter" && event.ctrlKey) {
        event.preventDefault();
        handleReminderAdd();
      }
    });

    function resetHypothesisForm() {
      editingHypothesisId = null;
      if (btnHipotesis) btnHipotesis.textContent = "Guardar hip√≥tesis";
      if (hypoNumeroInput) hypoNumeroInput.value = "";
      if (hypoTextoInput) hypoTextoInput.value = "";
    }

    async function refreshHypotesis() {
      await refreshHypothesisReminders();
      const cont = document.getElementById("h-list");
      if (!cont) return;
      cont.classList.add("cards", "hypo-list");
      const hyps = await DB._getAll("hypotheses");
      if (!hyps.length) {
        cont.innerHTML = "<p class='hint'>A√∫n no hay hip√≥tesis registradas.</p>";
        return;
      }
      hyps.sort((a, b) => (b.createdAt || 0) - (a.createdAt || 0));
      cont.innerHTML = "";
      for (const h of hyps) {
        const card = document.createElement("div");
        card.className = "card hypo-card";

        const simbolo = h.simbolo || getSymbol(h.numero) || "";
        const estado = (h.estado || "pendiente").toLowerCase();
        const fecha = h.fecha || "(sin fecha)";
        const turno = h.turno || "";
        const razones = (h.razones || []).filter(Boolean).join(" ¬∑ ") || "Sin notas";

        const head = document.createElement("div");
        head.className = "card-head";

        const title = document.createElement("span");
        title.className = "hypo-title";
        title.textContent = `${formatNumber(h.numero)} ${simbolo}`.trim();
        head.appendChild(title);

        const badge = document.createElement("span");
        badge.className = `badge-state badge-${estado}`;
        badge.textContent = estado;
        head.appendChild(badge);

        card.appendChild(head);

        const body = document.createElement("div");
        body.className = "card-body hypo-body";

        const fechaSpan = document.createElement("span");
        fechaSpan.innerHTML = `<strong>Fecha:</strong> ${fecha}${turno ? ` ‚Ä¢ ${turno}` : ""}`;
        body.appendChild(fechaSpan);

        const notaSpan = document.createElement("span");
        notaSpan.innerHTML = `<strong>Notas:</strong> ${razones}`;
        body.appendChild(notaSpan);

        card.appendChild(body);

        const actions = document.createElement("div");
        actions.className = "hypo-actions";

        const editBtn = document.createElement("button");
        editBtn.type = "button";
        editBtn.className = "btn-secondary";
        editBtn.textContent = "Editar";
        editBtn.addEventListener("click", () => {
          editingHypothesisId = h.id;
          if (hypoFechaInput) hypoFechaInput.value = h.fecha || "";
          if (hypoTurnoSelect) hypoTurnoSelect.value = h.turno || "";
          if (hypoNumeroInput) hypoNumeroInput.value = String(h.numero).padStart(2, "0");
          if (hypoTextoInput) hypoTextoInput.value = (h.razones && h.razones[0]) || "";
          if (btnHipotesis) btnHipotesis.textContent = "Actualizar hip√≥tesis";
          showToast(`Editando hip√≥tesis ${formatNumber(h.numero)}`, { variant: "info", timeout: 2000 });
        });
        actions.appendChild(editBtn);

        const cancelBtn = document.createElement("button");
        cancelBtn.type = "button";
        cancelBtn.className = "btn-ghost";
        cancelBtn.textContent = "Cancelar";
        cancelBtn.addEventListener("click", () => {
          resetHypothesisForm();
          showToast("Edici√≥n cancelada.", { variant: "warning", timeout: 1800 });
        });
        actions.appendChild(cancelBtn);

        card.appendChild(actions);

        cont.appendChild(card);
      }
    }

    btnHipotesis?.addEventListener("click", async () => {
      const fecha = hypoFechaInput?.value;
      const turno = hypoTurnoSelect?.value;
      const numeroRaw = hypoNumeroInput?.value.trim() ?? "";
      const texto = hypoTextoInput?.value.trim() ?? "";
      if (!/^\d{1,2}$/.test(numeroRaw)) {
        showToast("Ingresa un n√∫mero v√°lido (00-99) para la hip√≥tesis.", { variant: "warning" });
        return;
      }
      const numero = parseInt(numeroRaw, 10);
      try {
        if (editingHypothesisId) {
          await actualizarHipotesis(
            editingHypothesisId,
            numero,
            getSymbol(numero),
            texto,
            { fecha, turno }
          );
          resetHypothesisForm();
          showToast("Hip√≥tesis actualizada.", { variant: "success" });
        } else {
          await crearHipotesis(numero, getSymbol(numero), texto, { fecha, turno });
          resetHypothesisForm();
          showToast("Hip√≥tesis guardada.", { variant: "success" });
        }
        await refreshHypotesis();
      } catch (err) {
        console.error("hipotesis error", err);
        showToast(`No se pudo guardar la hip√≥tesis: ${err.message}`, { variant: "danger" });
      }
    });

    const btnAnalizar = document.getElementById("btn-analizar");
    const analysisDowSelect = document.getElementById("analysis-dow");
    if (analysisDowSelect && !analysisDowSelect.value) {
      const storedBiasDow = readBiasDowPreference();
      if (storedBiasDow !== null && storedBiasDow !== "") {
        const hasOption = Array.from(analysisDowSelect.options || []).some((opt) => opt.value === storedBiasDow);
        if (hasOption) {
          analysisDowSelect.value = storedBiasDow;
        }
      }
    }
    const resultEscenarios = document.getElementById("result-escenarios");
    const resultRecomendacion = document.getElementById("result-recomendacion");
    const resultPlan = document.getElementById("result-plan");
    const resultBias = document.getElementById("result-day-bias");
    const pega3FechaInput = document.getElementById("pega3-fecha");
    const pega3TurnoSelect = document.getElementById("pega3-turno");
    const pega3PaisSelect = document.getElementById("pega3-pais");
    const pega3ContextSyncBtn = document.getElementById("pega3-context-sync");
    const pega3FormStatus = document.getElementById("pega3-form-status");
    const pega3SaveBtn = document.getElementById("pega3-btn-registrar");
    const pega3ParInputs = [
      document.getElementById("pega3-par-1"),
      document.getElementById("pega3-par-2"),
      document.getElementById("pega3-par-3"),
    ];
    const pega3GeneratorBtn = document.getElementById("pega3-btn-generar-trio");
    const pega3GeneratorOutput = document.getElementById("pega3-generator-output");
    const pega3Historial = document.getElementById("pega3-historial");
    const pega3Resumen = document.getElementById("pega3-resumen");
    const pega3Sesgos = document.getElementById("pega3-sesgos");
    const pega3Seleccion = document.getElementById("pega3-seleccion");
    const pega3PendingDeletion = new Map();

    async function ejecutarAnalisis({ auto = false } = {}) {
      if (!auto) {
        if (resultEscenarios) resultEscenarios.innerHTML = "<p class='hint'>Analizando‚Ä¶</p>";
        if (resultRecomendacion) resultRecomendacion.innerHTML = "";
        if (resultPlan) resultPlan.innerHTML = "";
        if (resultBias) resultBias.innerHTML = "<p class='hint'>Calculando sesgos‚Ä¶</p>";
      }
      try {
        await rebuildKnowledge();
        const analisis = await analizarYProponer(GUIA);
        const patrones = await detectarPatrones();
        const memoria = await obtenerPerfilesNumeros();
        const modoEval = await evaluarModos();
        const perfilMap = new Map((memoria.perfiles || []).map((p) => [p.numero, p]));
        const { fecha: fechaFiltro, pais: paisFiltro } = getFilters();
        const referenciaFecha = fechaFiltro ? new Date(`${fechaFiltro}T00:00:00`) : new Date();
        const fechaValida = Number.isNaN(referenciaFecha.getTime()) ? new Date() : referenciaFecha;
        const contextoPred = {
          dow: fechaValida.getDay(),
          year: fechaValida.getFullYear(),
          pais: paisFiltro || null,
        };
        const dowOverrideValue = parseInt(analysisDowSelect?.value ?? "", 10);
        if (Number.isFinite(dowOverrideValue)) {
          contextoPred.dow = dowOverrideValue;
        }
        const drawsList = await getCachedDraws({ force: auto });
        const biasPredicciones = generarPredicciones(memoria.perfiles || [], { top: 100, contexto: contextoPred });
        biasDataInput = {
          perfilMap,
          predictions: biasPredicciones,
          draws: drawsList,
          contexto: { ...contextoPred },
          patrones,
        };
        biasPanelState.dow = contextoPred.dow;
        renderSesgosPorDia(perfilMap, { dow: contextoPred.dow, year: contextoPred.year });

        let predicciones = generarPredicciones(memoria.perfiles || [], { top: 9, contexto: contextoPred });
        predicciones = mezclarPrediccionesConModos(predicciones, modoEval);
        predicciones = aplicarBonusEstrategias(
          predicciones,
          patrones.estrategiasAritmeticas || [],
          { fecha: fechaFiltro || null, pais: paisFiltro || null }
        );
        const insights = generarInsights(memoria.perfiles || []);
        const shouldLogPreds = !auto && predicciones.length && (fechaFiltro || paisFiltro);

        if (shouldLogPreds) {
          await DB.logPredictions(predicciones, {
            fecha: fechaFiltro || null,
            pais: paisFiltro || null,
          });
        } else if (!auto && predicciones.length) {
          showToast(
            "Predicciones registradas como simulaci√≥n. Selecciona fecha y pa√≠s para evaluar aciertos.",
            { variant: "warning", timeout: 5000 }
          );
        }

        const resumenPred = await obtenerResumenPredicciones();

        renderEscenarios(
          analisis.escenarios || [],
          patrones,
          predicciones,
          perfilMap,
          memoria.totalDraws || 0,
          memoria.latestTimestamp || null,
          insights,
          modoEval
        );
        renderRecomendaciones(
          analisis.recomendacion || [],
          analisis.nota,
          predicciones,
          perfilMap,
          resumenPred
        );
        let drawsSeleccionados = [];
        if (fechaFiltro && paisFiltro) {
          const drawsDelDia = await DB.listDraws({ excludeTest: true });
          drawsSeleccionados = drawsDelDia.filter(
            (draw) => draw.fecha === fechaFiltro && draw.pais === paisFiltro
          );
        }

        renderPlanDia(
          predicciones,
          perfilMap,
          modoEval,
          contextoPred,
          patrones.timelineActiva || [],
          patrones.hallazgos || [],
          patrones.resumenVentana || "",
          drawsSeleccionados
        );
      } catch (err) {
        console.error("analizar error", err);
        if (!auto && resultEscenarios)
          resultEscenarios.innerHTML = `<p class='hint'>No se pudo completar el an√°lisis: ${err.message}</p>`;
      }
    }

    btnAnalizar?.addEventListener("click", () => ejecutarAnalisis());
    analysisDowSelect?.addEventListener("change", (event) => {
      persistBiasDowPreference(event.target.value || "");
      ejecutarAnalisis();
    });

    function mejorTurnoSegunPerfil(perfil) {
      const aprendizaje = perfil?.aprendizaje?.porHorario || {};
      let bestTurno = null;
      let bestRatio = -1;
      Object.entries(aprendizaje).forEach(([turno, stats]) => {
        if (!stats.total) return;
        const rate = stats.aciertos / stats.total;
        if (rate > bestRatio) {
          bestRatio = rate;
          bestTurno = turno;
        }
      });
      if (bestTurno) {
        return { turno: bestTurno, ratio: bestRatio, fuente: "aprendizaje" };
      }

      const historico = perfil?.porHorario || {};
      let bestCount = -1;
      Object.entries(historico).forEach(([turno, total]) => {
        if (total > bestCount) {
          bestCount = total;
          bestTurno = turno;
        }
      });
      if (bestTurno) {
        return { turno: bestTurno, ratio: bestCount, fuente: "historial" };
      }

      if (perfil?.lastSeen?.horario) {
        return { turno: perfil.lastSeen.horario, ratio: 0, fuente: "√∫ltimo" };
      }
      return { turno: TURNOS[0], ratio: 0, fuente: "predeterminado" };
    }

    function describirOperacionModo(modo, numero) {
      if (!modo) return "";
      const base =
        modo.baseNumero !== undefined && modo.baseNumero !== null && !Number.isNaN(modo.baseNumero)
          ? formatNumber(modo.baseNumero)
          : null;
      const destino = Number.isFinite(numero) ? formatNumber(numero) : null;
      const op = modo.operacion || "";
      switch (op) {
        case "mirror":
          if (base && destino) return `${base} ‚Üí ${destino} invirtiendo d√≠gitos`;
          return "Invirti√≥ los d√≠gitos del n√∫mero base";
        case "digit-map":
          if (base && destino) return `${base} ‚Üí ${destino} con mapa de d√≠gitos personalizado`;
          return "Aplic√≥ el mapa personalizado del modo";
        case "sum-digits":
          return base ? `${base} ‚Üí suma de d√≠gitos` : "Suma de d√≠gitos";
        case "sum-digits-keep-first":
          if (base && destino) return `${base} ‚Üí conserva decena y suma unidades`;
          return "Conserva decena, ajusta unidad";
        case "add-constant":
          return base ? `${base} + constante` : "Suma una constante";
        case "sub-constant":
          return base ? `${base} ‚àí constante` : "Resta una constante";
        case "neighbor":
          return base ? `${base} ¬± vecino` : "Vecinos alrededor del n√∫mero base";
        default:
          return op ? `Operaci√≥n ${op}` : "";
      }
    }

    function resumenSoporte(modo) {
      if (typeof modo.soporte === "number" && modo.soporte > 0) {
        return modo.soporte === 1 ? "1 ejemplo" : `${modo.soporte} ejemplos`;
      }
      return "";
    }

    function detallesModos(modos = [], numero) {
      if (!modos.length) return [];
      return modos.slice(0, 3).map((modo) => {
        const nombre = modo.modeNombre || "Modo";
        const conf = Math.round((modo.confianza || 0) * 100);
        const opDesc = describirOperacionModo(modo, numero);
        const soporte = resumenSoporte(modo);
        const partes = [`${nombre}${conf ? ` (${conf}%)` : ""}`];
        if (opDesc) partes.push(opDesc);
        if (soporte) partes.push(soporte);
        return partes.join(" ‚Äî ");
      });
    }

    function notasPatronNumero(hallazgos, numero) {
      const notes = [];
      hallazgos
        .filter((h) => h.id?.startsWith("repeat-") && h.numero === numero)
        .slice(0, 2)
        .forEach((h) => {
          const datos = h.datos || {};
          const muestras = datos.muestras?.length ? ` ¬∑ ${datos.muestras.join(" ¬∑ ")}` : "";
          notes.push(`${datos.tipo || "Repetici√≥n"}${muestras}`);
        });

      const gapHallazgo = hallazgos.find((h) => h.id?.startsWith("gap-") && h.numero === numero);
      if (gapHallazgo?.datos?.gap) {
        const gapDias = gapHallazgo.datos.gap;
        const evidencia = gapHallazgo.evidencia || [];
        const ultimaCoincidencia = evidencia.length ? evidencia[evidencia.length - 1] : null;
        const ultimaFecha = parseISODate(ultimaCoincidencia?.fecha);
        const nextDate =
          parseISODate(gapHallazgo.siguienteFechaEsperada) ||
          (ultimaFecha ? new Date(ultimaFecha.getTime() + gapDias * DAY_MS) : null);
        if (nextDate) {
          const today = new Date();
          today.setHours(0, 0, 0, 0);
          const diffDays = Math.round((nextDate - today) / DAY_MS);
          const status =
            diffDays > 0
              ? `en ${diffDays} d√≠as`
              : diffDays === 0
                ? "hoy"
                : `hace ${Math.abs(diffDays)} d√≠as`;
          const friendly = formatFriendlyDate(nextDate);
          notes.push(`Intervalo ${gapDias}d ‚Üí pr√≥ximo ${friendly || "sin fecha"} (${status})`);
        } else {
          notes.push(`Intervalo ${gapDias}d observado`);
        }
      }

      hallazgos
        .filter((h) => h.id?.startsWith("transition-") && h.datos?.destino === numero)
        .slice(0, 2)
        .forEach((h) => {
          const datos = h.datos || {};
          const origen = typeof datos.origen === "number" ? formatNumber(datos.origen) : null;
          const ratio = typeof datos.ratio === "number" ? `${Math.round(datos.ratio * 100)}%` : null;
          const horario = datos.destinoHorario ? ` ${datos.destinoHorario}` : "";
          const base = origen ? `Suele seguir al ${origen}` : "Transici√≥n frecuente";
          const detalle = ratio ? ` (${ratio})` : "";
          notes.push(`${base}${horario}${detalle}`);
        });
      return notes;
    }

    function renderPlanDia(
      predicciones,
      perfilMap,
      modoEval,
      contexto = null,
      timelineActiva = [],
      hallazgos = [],
      resumenVentana = "",
      drawsDia = []
    ) {
      if (!resultPlan) return;
      resultPlan.innerHTML = "";

      if (!predicciones.length) {
        resultPlan.innerHTML = "<p class='hint'>A√∫n no hay un plan diario ‚Äî registra sorteos reales para 2025.</p>";
        return;
      }

      const { fecha: filtrosFecha, pais: filtrosPais } = getFilters();
      const fechaObjetivo = filtrosFecha || "(sin fecha)";
      const paisObjetivo = filtrosPais || "";
      const drawsJugados = Array.isArray(drawsDia) ? drawsDia : [];
      const generadoEn = new Date();
      const generadoHora = generadoEn.toLocaleTimeString("es-ES", {
        hour: "2-digit",
        minute: "2-digit",
      });
      const today = new Date();
      today.setHours(0, 0, 0, 0);

      const lastByNumero = new Map();
      timelineActiva.forEach((draw) => {
        lastByNumero.set(draw.numero, draw);
      });

      const detallePorNumero = modoEval?.detallePorNumero || {};

      const planBuckets = new Map();
      TURNOS.forEach((turno) => planBuckets.set(turno, []));

      let planSections = 0;
      const usedPlanNumbers = new Set();
      const limitPorTurno = 3;
      const sortedPreds = predicciones
        .slice()
        .sort((a, b) => (b.score || 0) - (a.score || 0));

      predicciones.forEach((item) => {
        const perfil = perfilMap.get(item.numero);
        const turnoInfo = mejorTurnoSegunPerfil(perfil);
        const bucket = planBuckets.get(turnoInfo.turno) || planBuckets.get(TURNOS[0]);
        const yaJugadoMismoTurno = drawsJugados.some(
          (draw) => draw.numero === item.numero && draw.horario === turnoInfo.turno
        );
        if (yaJugadoMismoTurno) return;
        const lastSeen = perfil?.lastSeen || null;
        const modoDetalles = detallesModos(item.modos, item.numero);
        const patronNotas = notasPatronNumero(hallazgos, item.numero);
        bucket.push({
          item,
          perfil,
          turnoInfo,
          lastSeen,
          modoDetalles,
          patronNotas,
        });
      });

      const planGrid = document.createElement("div");
      planGrid.className = "plan-grid";

      TURNOS.forEach((turno) => {
        const bucketEntries = (planBuckets.get(turno) || [])
          .filter(Boolean)
          .sort((a, b) => b.item.score - a.item.score);
        const candidatos = [];
        const numbersInCard = new Set();
        bucketEntries.forEach((entry) => {
          if (candidatos.length >= limitPorTurno) return;
          if (usedPlanNumbers.has(entry.item.numero)) return;
          candidatos.push({ ...entry, isFallback: false });
          numbersInCard.add(entry.item.numero);
        });
        const needFallback = limitPorTurno - candidatos.length;
        if (needFallback > 0) {
          const fallback = [];
          for (const item of sortedPreds) {
            if (fallback.length >= needFallback) break;
            if (numbersInCard.has(item.numero) || usedPlanNumbers.has(item.numero)) continue;
            const yaJugado = drawsJugados.some(
              (draw) => draw.numero === item.numero && draw.horario === turno
            );
            if (yaJugado) continue;
            const perfil = perfilMap.get(item.numero);
            fallback.push({
              item,
              perfil,
              turnoInfo: { turno, ratio: 0, fuente: "contexto" },
              lastSeen: perfil?.lastSeen || null,
              modoDetalles: detallesModos(item.modos, item.numero),
              patronNotas: notasPatronNumero(hallazgos, item.numero),
              isFallback: true,
            });
            numbersInCard.add(item.numero);
          }
          candidatos.push(...fallback);
        }

        const card = document.createElement("div");
        card.className = "analysis-card plan";

        const head = document.createElement("div");
        head.className = "card-head";
        head.textContent = `Candidatos ${turno}`;
        card.appendChild(head);

        const meta = document.createElement("div");
        meta.className = "plan-meta";
        meta.textContent = `Fecha ${fechaObjetivo}${paisObjetivo ? ` ¬∑ ${paisObjetivo}` : ""} ¬∑ Generado ${generadoHora}`;
        card.appendChild(meta);

        const list = document.createElement("div");
        list.className = "plan-list";

        if (!candidatos.length) {
          const empty = document.createElement("p");
          empty.className = "plan-empty";
          empty.textContent = "Sin base suficiente para proponer este turno.";
          list.appendChild(empty);
        } else {
          candidatos.forEach(
            ({ item, perfil, turnoInfo, lastSeen, modoDetalles, patronNotas, isFallback }) => {
              const row = document.createElement("div");
              row.className = "plan-item";
              if (isFallback) row.classList.add("plan-item--fallback");

              const numberEl = document.createElement("div");
              numberEl.className = "plan-number";
              const symbol = getSymbol(item.numero);
              numberEl.textContent = symbol
                ? `${formatNumber(item.numero)} ${symbol}`
                : formatNumber(item.numero);
              row.appendChild(numberEl);

              const scoreEl = document.createElement("div");
              scoreEl.className = "plan-score";
              scoreEl.textContent = `${Math.round(item.score * 100)}% score`;
              row.appendChild(scoreEl);

              const details = document.createElement("ul");
              details.className = "plan-detail";

              if (lastSeen) {
                const li = document.createElement("li");
                const fechaFmt = formatFriendlyDate(lastSeen.fecha);
                li.textContent = `√öltima vez: ${fechaFmt}${lastSeen.horario ? ` ¬∑ ${lastSeen.horario}` : ""}`;
                details.appendChild(li);
              }

              if (
                contexto &&
                Number.isFinite(item.afinidadDia) &&
                typeof contexto.dow === "number"
              ) {
                const biasDia = item.afinidadDia - BASELINE_DOW_RATIO;
                if (biasDia > 0.01) {
                  const li = document.createElement("li");
                  const dowLabel = DOW_FULL_LABEL[contexto.dow] || "este d√≠a";
                  li.textContent = `Sesgo ${dowLabel}: ${(item.afinidadDia * 100).toFixed(0)}% (${(biasDia * 100).toFixed(1)} pts)`;
                  details.appendChild(li);
                }
              }

              if (contexto?.pais && Number.isFinite(item.afinidadPais) && item.afinidadPais > 0) {
                const li = document.createElement("li");
                li.textContent = `Afinidad ${contexto.pais}: ${(item.afinidadPais * 100).toFixed(0)}%`;
                details.appendChild(li);
              }

              if (Number.isFinite(item.afinidadAnio) && item.afinidadAnio > 0) {
                const li = document.createElement("li");
                li.textContent = `Participaci√≥n ${contexto?.year || new Date().getFullYear()}: ${(item.afinidadAnio * 100).toFixed(0)}%`;
                details.appendChild(li);
              }

              if (turnoInfo?.fuente === "aprendizaje" && Number.isFinite(turnoInfo.ratio)) {
                const li = document.createElement("li");
                li.textContent = `Historial turno ${turno}: ${(turnoInfo.ratio * 100).toFixed(0)}% acierto`;
                details.appendChild(li);
              }

              if (isFallback) {
                const li = document.createElement("li");
                li.textContent = "Sin historial en este turno; sugerido por score general.";
                details.appendChild(li);
              }

              if (!details.children.length) {
                const li = document.createElement("li");
                li.textContent = "Sin contexto adicional";
                details.appendChild(li);
              }

              row.appendChild(details);
              list.appendChild(row);
            }
          );
        }

        card.appendChild(list);
        if (resumenVentana) {
          const foot = document.createElement("div");
          foot.className = "plan-footnote";
          foot.textContent = resumenVentana;
          card.appendChild(foot);
        }

        planGrid.appendChild(card);
        if (candidatos.length) {
          candidatos.forEach(({ item }) => usedPlanNumbers.add(item.numero));
        }
        planSections += 1;
      });

      if (planSections) {
        resultPlan.appendChild(planGrid);
      }

      const LONG_GAP_THRESHOLD = 120;
      const sequiasActivas = [];
      perfilMap.forEach((perfil) => {
        const gaps = perfil?.gaps || {};
        const lastSeen = perfil?.lastSeen || null;
        const daysSince = typeof gaps.daysSince === "number" ? Math.round(gaps.daysSince) : null;
        if (daysSince === null || daysSince < LONG_GAP_THRESHOLD) return;
        const gapPrevio =
          typeof gaps.ultimo === "number" && Number.isFinite(gaps.ultimo)
            ? Math.round(gaps.ultimo)
            : daysSince;
        const promedio = typeof gaps.promedio === "number" ? gaps.promedio : null;
        sequiasActivas.push({
          numero: perfil.numero,
          perfilRef: perfil,
          lastSeen,
          gapPrevio,
          promedio,
          daysSince,
        });
      });

      let droughtCard = null;
      if (sequiasActivas.length) {
        droughtCard = document.createElement("div");
        droughtCard.className = "analysis-card drought";

        const head = document.createElement("div");
        head.className = "card-head";
        head.textContent = "Alertas de sequ√≠a";
        droughtCard.appendChild(head);

        const meta = document.createElement("div");
        meta.className = "plan-meta";
        meta.textContent = `Solo se muestran n√∫meros con m√°s de ${LONG_GAP_THRESHOLD} d√≠as sin salir.`;
        droughtCard.appendChild(meta);

        const list = document.createElement("div");
        list.className = "plan-list";

        const buildRow = (entry) => {
          const row = document.createElement("div");
          row.className = "plan-item";

          const numberEl = document.createElement("div");
          numberEl.className = "plan-number";
          const symbol = getSymbol(entry.numero);
          numberEl.textContent = symbol
            ? `${formatNumber(entry.numero)} ${symbol}`
            : formatNumber(entry.numero);
          row.appendChild(numberEl);

          const details = document.createElement("ul");
          details.className = "plan-detail";

          const lastSeenText = entry.lastSeen
            ? `√öltima vez: ${formatFriendlyDate(entry.lastSeen.fecha)}${entry.lastSeen.horario ? ` ¬∑ ${entry.lastSeen.horario}` : ""}`
            : null;
          if (lastSeenText) {
            const li = document.createElement("li");
            li.textContent = lastSeenText;
            details.appendChild(li);
          }

          const gapLi = document.createElement("li");
          gapLi.textContent = `Gap previo relevante: ${entry.gapPrevio} d√≠as`;
          details.appendChild(gapLi);

          if (entry.promedio) {
            const avgLi = document.createElement("li");
            avgLi.textContent = `Gap promedio hist√≥rico: ${entry.promedio.toFixed(1)} d√≠as`;
            details.appendChild(avgLi);
          }

          if (typeof entry.daysSince === "number") {
            const sinceLi = document.createElement("li");
            sinceLi.textContent = `D√≠as sin salir: ${entry.daysSince}`;
            details.appendChild(sinceLi);
          }

          const perfilRef = entry.perfilRef;
          const historialRegistros = Array.isArray(perfilRef?.gaps?.historial)
            ? perfilRef.gaps.historial.filter(
              (item) => Number.isFinite(item?.gap) && item.gap >= LONG_GAP_THRESHOLD
            )
            : [];
          if (historialRegistros.length) {
            const minHist = Math.min(...historialRegistros.map((h) => h.gap));
            const maxHist = Math.max(...historialRegistros.map((h) => h.gap));
            const avgHist =
              historialRegistros.reduce((acc, h) => acc + h.gap, 0) / historialRegistros.length;
            const rangeLi = document.createElement("li");
            rangeLi.textContent = `Historial largo: ${minHist}-${maxHist} d√≠as (${historialRegistros.length} eventos)`;
            details.appendChild(rangeLi);

            const lastSeenDate = parseISODate(entry.lastSeen?.fecha);
            if (lastSeenDate && Number.isFinite(avgHist) && avgHist > 0) {
              const avgGapRounded = Math.round(avgHist);
              const estimado = new Date(lastSeenDate.getTime() + avgGapRounded * DAY_MS);
              if (!Number.isNaN(estimado.getTime())) {
                const diff = Math.round((estimado - today) / DAY_MS);
                const statusHist =
                  diff > 0
                    ? `faltan ${diff} d√≠as`
                    : diff === 0
                      ? "hoy"
                      : `vencido hace ${Math.abs(diff)} d√≠as`;
                const avgLi = document.createElement("li");
                avgLi.textContent = `Proyecci√≥n hist√≥rica: ${formatFriendlyDate(estimado)} (~${avgGapRounded}d, ${statusHist})`;
                details.appendChild(avgLi);
              }
            }

            const ultimoComparable = historialRegistros[historialRegistros.length - 1];
            if (ultimoComparable?.gap && ultimoComparable?.hasta?.fecha) {
              const li = document.createElement("li");
              const desde =
                ultimoComparable.desde?.fecha ? `${formatFriendlyDate(ultimoComparable.desde.fecha)} ‚Üí ` : "";
              const hasta = formatFriendlyDate(ultimoComparable.hasta.fecha);
              li.textContent = `√öltima sequ√≠a similar: ${ultimoComparable.gap}d (${desde || ""}${hasta})`;
              details.appendChild(li);
            }
          }

          row.appendChild(details);
          return row;
        };

        sequiasActivas
          .sort((a, b) => b.daysSince - a.daysSince)
          .forEach((entry) => list.appendChild(buildRow(entry)));

        droughtCard.appendChild(list);
        planGrid.appendChild(droughtCard);
      }

      let hasGapCard = false;
      const gapSeguimiento = hallazgos
        .filter((h) => h.id?.startsWith("gap-"))
        .map((h) => {
          const gapDias = Number(h.datos?.gap);
          if (!Number.isFinite(gapDias) || gapDias <= 0) return null;
          const evidencia = Array.isArray(h.evidencia) ? h.evidencia : [];
          const ultimaCoincidencia = evidencia.length ? evidencia[evidencia.length - 1] : null;
          const lastDate = parseISODate(ultimaCoincidencia?.fecha);
          const nextDate =
            parseISODate(h.siguienteFechaEsperada) ||
            (lastDate ? new Date(lastDate.getTime() + gapDias * DAY_MS) : null);
          const diffDays =
            nextDate && Number.isFinite(nextDate.getTime())
              ? Math.round((nextDate - today) / DAY_MS)
              : null;
          const status =
            diffDays === null
              ? "sin estimaci√≥n"
              : diffDays > 0
                ? `faltan ${diffDays} d√≠as`
                : diffDays === 0
                  ? "esperado hoy"
                  : `vencido hace ${Math.abs(diffDays)} d√≠as`;
          return {
            numero: h.numero,
            gap: gapDias,
            coincidencias: Number(h.datos?.coincidencias || 0),
            intervalos: Number(h.datos?.intervalos || 0),
            lastSeen: ultimaCoincidencia
              ? {
                fecha: ultimaCoincidencia.fecha,
                horario: ultimaCoincidencia.horario,
              }
              : null,
            nextDate,
            diffDays,
            status,
            horarioSugerido: h.datos?.siguienteHorario || ultimaCoincidencia?.horario || null,
          };
        })
        .filter(Boolean)
        .sort((a, b) => {
          const aDiff = a.diffDays === null ? Number.POSITIVE_INFINITY : a.diffDays;
          const bDiff = b.diffDays === null ? Number.POSITIVE_INFINITY : b.diffDays;
          return aDiff - bDiff;
        });

      if (gapSeguimiento.length) {
        hasGapCard = true;
        const gapCard = document.createElement("div");
        gapCard.className = "analysis-card interval";

        const head = document.createElement("div");
        head.className = "card-head";
        head.textContent = "Seguimiento de intervalos";
        gapCard.appendChild(head);

        const meta = document.createElement("div");
        meta.className = "plan-meta";
        meta.textContent = "N√∫meros con patr√≥n de d√≠as constantes.";
        gapCard.appendChild(meta);

        const list = document.createElement("div");
        list.className = "plan-list";

        gapSeguimiento.forEach((entry) => {
          const row = document.createElement("div");
          row.className = "plan-item";

          const numberEl = document.createElement("div");
          numberEl.className = "plan-number";
          const symbol = getSymbol(entry.numero);
          numberEl.textContent = symbol
            ? `${formatNumber(entry.numero)} ${symbol}`
            : formatNumber(entry.numero);
          row.appendChild(numberEl);

          const badge = document.createElement("div");
          badge.className = "plan-score";
          badge.textContent = `${entry.gap} d√≠as`;
          row.appendChild(badge);

          const details = document.createElement("ul");
          details.className = "plan-detail";

          if (entry.lastSeen) {
            const li = document.createElement("li");
            const friendly = formatFriendlyDate(entry.lastSeen.fecha);
            li.textContent = `√öltima coincidencia: ${friendly}${entry.lastSeen.horario ? ` ¬∑ ${entry.lastSeen.horario}` : ""}`;
            details.appendChild(li);
          }

          if (entry.nextDate) {
            const li = document.createElement("li");
            const fechaFmt = formatFriendlyDate(entry.nextDate);
            const horario = entry.horarioSugerido ? ` ${entry.horarioSugerido}` : "";
            li.textContent = `Pr√≥xima estimada: ${fechaFmt || "Sin fecha"}${horario ? ` ${horario}` : ""} (${entry.status})`;
            details.appendChild(li);
          } else {
            const li = document.createElement("li");
            li.textContent = `Pr√≥xima estimada: sin datos (${entry.status})`;
            details.appendChild(li);
          }

          const ratioLi = document.createElement("li");
          const total = entry.intervalos || 0;
          ratioLi.textContent = `Coincidencias: ${entry.coincidencias}/${total} intervalos`;
          details.appendChild(ratioLi);

          row.appendChild(details);
          list.appendChild(row);
        });

        gapCard.appendChild(list);
        planGrid.appendChild(gapCard);
      }

      if (!planSections) {
        resultPlan.innerHTML = "<p class='hint'>No hay suficientes datos para construir un plan diario.</p>";
        return;
      }

      resultPlan.appendChild(planGrid);

      if (planSections === 0 && !droughtCard && !hasGapCard) {
        resultPlan.innerHTML = "<p class='hint'>No hay suficientes datos recientes para un plan diario.</p>";
        return;
      }


      const note = document.createElement("p");
      note.className = "plan-note";
      note.textContent = "Plan generado con sorteos 2025 y modos validados.";
      resultPlan.appendChild(note);
    }

    function renderSesgosPorDia(perfilMap = null, { dow = null, year = null } = {}) {
      if (!resultBias) return;
      resultBias.innerHTML = "";
      const map = perfilMap || biasDataInput.perfilMap;
      if (!map || !map.size) {
        resultBias.innerHTML = "<p class='hint'>A√∫n no hay datos suficientes para sesgos diarios.</p>";
        return;
      }
      const targetDow = Number.isFinite(dow) ? dow : Number.isFinite(biasPanelState.dow) ? biasPanelState.dow : null;
      if (!Number.isFinite(targetDow)) {
        resultBias.innerHTML = "<p class='hint'>Selecciona un d√≠a para revisar sesgos hist√≥ricos.</p>";
        return;
      }
      const perfiles = Array.from(map.values());
      const entries = perfiles
        .map((perfil) => {
          const stats = computePerfilSesgoDia(perfil, targetDow, year);
          if (!stats) return null;
          const dayTurn = perfil.porDiaHorario?.[targetDow] || {};
          const turnBreakdown = TURNOS.map((turno) => {
            const countTurno = dayTurn?.[turno] || 0;
            return {
              turno,
              count: countTurno,
              ratio: stats.count ? countTurno / Math.max(stats.count, 1) : 0,
            };
          });
          return {
            numero: perfil.numero,
            ...stats,
            turnBreakdown,
          };
        })
        .filter(Boolean);
      if (!entries.length) {
        resultBias.innerHTML = "<p class='hint'>Sin registros suficientes para evaluar sesgos.</p>";
        return;
      }
      const strongBias = entries
        .filter((entry) => entry.bias > 0.01)
        .sort((a, b) => b.bias - a.bias);
      let usedStrongBias = strongBias.length > 0;
      let sortedEntries = usedStrongBias ? strongBias : entries.slice().sort((a, b) => b.ratio - a.ratio);
      if (!sortedEntries.length) {
        resultBias.innerHTML = "<p class='hint'>Sin n√∫meros con recurrencia destacada para ese d√≠a.</p>";
        return;
      }
      if (biasPanelState.dow !== targetDow) {
        biasPanelState = {
          dow: targetDow,
          page: 0,
          selected: [],
          rankingTurn: biasPanelState.rankingTurn || DEFAULT_RANKING_TURN,
          expiresAt: 0,
        };
      } else {
        if (!Array.isArray(biasPanelState.selected)) biasPanelState.selected = [];
        if (!biasPanelState.rankingTurn) biasPanelState.rankingTurn = DEFAULT_RANKING_TURN;
      }
      if (biasPanelState.expiresAt && biasPanelState.expiresAt < Date.now()) {
        biasPanelState.selected = [];
        biasPanelState.expiresAt = 0;
      }
      const persistedNotes = getBiasNotesForDow(targetDow);
      if (persistedNotes) {
        const persistedSelected = Array.isArray(persistedNotes.selected) ? persistedNotes.selected : [];
        biasPanelState.selected = persistedSelected.map((entry) => ({
          ...entry,
          turnBreakdown: Array.isArray(entry.turnBreakdown)
            ? entry.turnBreakdown.map((turn) => ({ ...turn }))
            : [],
        }));
        biasPanelState.rankingTurn = persistedNotes.rankingTurn || biasPanelState.rankingTurn || DEFAULT_RANKING_TURN;
        biasPanelState.expiresAt = persistedNotes.expiresAt || biasPanelState.expiresAt || 0;
      }
      const pageSize = 6;
      const totalPages = Math.max(1, Math.ceil(sortedEntries.length / pageSize));
      const currentPage = Math.min(Math.max(biasPanelState.page || 0, 0), totalPages - 1);
      if (biasPanelState.page !== currentPage) biasPanelState.page = currentPage;
      const pageEntries = sortedEntries.slice(currentPage * pageSize, currentPage * pageSize + pageSize);
      if (!pageEntries.length) {
        biasPanelState.page = 0;
        renderSesgosPorDia(map, { dow: targetDow, year });
        return;
      }
      const dowLabel = DOW_FULL_LABEL[targetDow] || "este d√≠a";
      const card = document.createElement("div");
      card.className = "analysis-card bias accent-soft";

      const head = document.createElement("div");
      head.className = "card-head";
      head.textContent = `Sesgos ${dowLabel}`;
      card.appendChild(head);

      const meta = document.createElement("div");
      meta.className = "analysis-note";
      const yearLabel = Number.isFinite(year) ? ` ${year}` : "";
      meta.textContent = usedStrongBias
        ? `Top sesgos positivos para ${dowLabel}${yearLabel ? ` (${yearLabel})` : ""}.`
        : `Sin sesgos fuertes para ${dowLabel}; se muestran las participaciones m√°s altas${yearLabel ? ` ${yearLabel}` : ""}.`;
      card.appendChild(meta);

      let selectedEntries = Array.isArray(biasPanelState.selected) ? biasPanelState.selected : [];
      let needsSelectionResync = false;
      selectedEntries = selectedEntries.map((entry) => {
        const resolvedSymbol = entry.symbol || getSymbol(entry.numero) || "";
        if (entry.symbol !== resolvedSymbol) needsSelectionResync = true;
        return {
          ...entry,
          symbol: resolvedSymbol,
          turnBreakdown: Array.isArray(entry.turnBreakdown)
            ? entry.turnBreakdown.map((turn) => ({ ...turn }))
            : [],
        };
      });
      biasPanelState.selected = selectedEntries;
      if (needsSelectionResync && selectedEntries.length) {
        syncBiasNotesPersistence(targetDow);
      }

      const selectionPanel = document.createElement("div");
      selectionPanel.className = "bias-selection";
      const selectionTitle = document.createElement("div");
      selectionTitle.className = "bias-selection__title";
      selectionTitle.textContent = "Apunte r√°pido";
      selectionPanel.appendChild(selectionTitle);
      const selectionBody = document.createElement("div");
      selectionBody.className = "bias-selection__body";
      if (!selectedEntries.length) {
        selectionBody.textContent = "Selecciona uno o varios n√∫meros para guardarlos mientras revisas este d√≠a.";
        selectionPanel.appendChild(selectionBody);
      } else {
        const selectionGrid = document.createElement("div");
        selectionGrid.className = "bias-selection__grid";
        selectedEntries.forEach((savedEntry) => {
          const chip = document.createElement("div");
          chip.className = "bias-selection-chip";

          const chipHead = document.createElement("div");
          chipHead.className = "bias-selection-chip__head";
          const chipNumber = document.createElement("div");
          chipNumber.className = "bias-selection-chip__number";
          const chipSymbol = savedEntry.symbol ? `<span class="bias-number-symbol">${savedEntry.symbol}</span>` : "";
          chipNumber.innerHTML = `<span class="bias-selection-chip__number-main">${formatNumber(savedEntry.numero)}</span>${chipSymbol}`;
          const removeBtn = document.createElement("button");
          removeBtn.type = "button";
          removeBtn.className = "bias-selection-chip__remove";
          removeBtn.textContent = "Quitar";
          removeBtn.addEventListener("click", () => {
            biasPanelState.selected = selectedEntries.filter((item) => item.numero !== savedEntry.numero);
            syncBiasNotesPersistence(targetDow);
            renderSesgosPorDia(map, { dow: targetDow, year });
          });
          chipHead.append(chipNumber, removeBtn);
          chip.appendChild(chipHead);

        const chipMeta = document.createElement("div");
        chipMeta.className = "bias-selection-chip__meta";
        const totalMuestras = Number.isFinite(savedEntry.total) ? savedEntry.total : "?";
        const countMuestras = Number.isFinite(savedEntry.count) ? savedEntry.count : 0;
        chipMeta.textContent = `Sesgo ${(savedEntry.bias * 100).toFixed(2)} pts ¬∑ ${countMuestras}/${totalMuestras} muestras`;
        chip.appendChild(chipMeta);
          const turnEl = savedEntry.turnBreakdown?.length
            ? (() => {
                const turn = document.createElement("div");
                turn.className = "bias-selection-chip__turn";
                const breakdown = savedEntry.turnBreakdown
                  .filter((t) => t.count)
                  .map((t) => `${t.turno}: ${(t.ratio * 100).toFixed(0)}% (${t.count}x)`);
                turn.textContent = breakdown.length ? breakdown.join(" ¬∑ ") : "Sin historial por turno";
                return turn;
              })()
            : null;

          chip.append(chipHead, chipMeta);
          if (turnEl) chip.appendChild(turnEl);
          selectionGrid.appendChild(chip);
        });
        selectionBody.appendChild(selectionGrid);
        selectionPanel.appendChild(selectionBody);
        const clearBtn = document.createElement("button");
        clearBtn.type = "button";
        clearBtn.className = "bias-selection__reset";
        clearBtn.textContent = "Vaciar apunte";
        clearBtn.addEventListener("click", () => {
          biasPanelState.selected = [];
          syncBiasNotesPersistence(targetDow);
          renderSesgosPorDia(map, { dow: targetDow, year });
        });
        selectionPanel.appendChild(clearBtn);
      }
      card.appendChild(selectionPanel);

      if (selectedEntries.length) {
        const rankingTurn = TURNOS.includes(biasPanelState.rankingTurn) ? biasPanelState.rankingTurn : DEFAULT_RANKING_TURN;
        if (rankingTurn !== biasPanelState.rankingTurn) biasPanelState.rankingTurn = rankingTurn;
        const rankingBlock = document.createElement("div");
        rankingBlock.className = "bias-ranking";
        const rankingHead = document.createElement("div");
        rankingHead.className = "bias-ranking__head";
        const rankingTitleWrap = document.createElement("div");
        rankingTitleWrap.className = "bias-ranking__title-wrap";
        const rankingTitle = document.createElement("div");
        rankingTitle.className = "bias-ranking__title";
        rankingTitle.textContent = "Ranking por sorteo";
        const rankingCount = document.createElement("span");
        rankingCount.className = "bias-ranking__count";
        rankingCount.textContent = `${selectedEntries.length} seleccionados`;
        const rankingControl = document.createElement("label");
        rankingControl.className = "bias-ranking-control";
        const rankingLabel = document.createElement("span");
        rankingLabel.textContent = "Horario objetivo";
        const rankingSelect = document.createElement("select");
        TURNOS.forEach((turno) => {
          const option = document.createElement("option");
          option.value = turno;
          option.textContent = turno;
          if (turno === rankingTurn) option.selected = true;
          rankingSelect.appendChild(option);
        });
        rankingSelect.addEventListener("change", (e) => {
          biasPanelState.rankingTurn = e.target.value;
          syncBiasNotesPersistence(targetDow);
          renderSesgosPorDia(map, { dow: targetDow, year });
        });
        rankingControl.append(rankingLabel, rankingSelect);
        rankingTitleWrap.append(rankingTitle, rankingCount);
        rankingHead.append(rankingTitleWrap, rankingControl);
        rankingBlock.appendChild(rankingHead);

        const rankingEntries = selectedEntries
          .map((entry) => {
            const matchTurn = (entry.turnBreakdown || []).find((turn) => turn.turno === rankingTurn) || null;
            const turnRatio = matchTurn?.ratio || 0;
            const turnCount = matchTurn?.count || 0;
            return {
              numero: entry.numero,
              symbol: entry.symbol || "",
              turnRatio,
              turnCount,
              inverse: getInverseNumero(entry.numero),
            };
          })
          .sort((a, b) => b.turnRatio - a.turnRatio || b.turnCount - a.turnCount);

        const rankingList = document.createElement("div");
        rankingList.className = "bias-ranking__list";
        rankingEntries.forEach((entry, index) => {
          const item = document.createElement("div");
          item.className = "bias-ranking-item";
          const ratio = Math.max(0, Math.min(1, entry.turnRatio || 0));
          const accentStrength = 0.35 + ratio * 0.4;
          const meterStrength = 0.55 + ratio * 0.3;
          const accent = `rgba(37, 99, 235, ${accentStrength})`;
          const meterColor = `rgba(37, 99, 235, ${meterStrength})`;
          item.style.setProperty("--rank-accent", accent);
          item.style.setProperty("--rank-meter", meterColor);

          const numberEl = document.createElement("div");
          numberEl.className = "bias-ranking-item__number";
          const indexBadge = document.createElement("span");
          indexBadge.className = "bias-ranking-item__index";
          indexBadge.textContent = index + 1;

          const numberBlock = document.createElement("div");
          numberBlock.className = "bias-ranking-item__number-block";
          const mainLine = document.createElement("div");
          mainLine.className = "bias-ranking-item__main";
          const mainNumber = document.createElement("span");
          mainNumber.className = "bias-selection-chip__number-main";
          mainNumber.textContent = formatNumber(entry.numero);
          mainLine.appendChild(mainNumber);
          if (entry.symbol) {
            const symbolSpan = document.createElement("span");
            symbolSpan.className = "bias-number-symbol";
            symbolSpan.textContent = entry.symbol;
            mainLine.appendChild(symbolSpan);
          }
          numberBlock.appendChild(mainLine);

          const inverseInfo = entry.inverse || getInverseNumero(entry.numero);
          if (inverseInfo) {
            const inverseLine = document.createElement("div");
            inverseLine.className = "bias-ranking-item__inverse";
            inverseLine.textContent = formatNumber(inverseInfo.numero);
            if (inverseInfo.symbol) {
              const inverseSymbol = document.createElement("span");
              inverseSymbol.className = "bias-number-symbol";
              inverseSymbol.textContent = inverseInfo.symbol;
              inverseLine.appendChild(inverseSymbol);
            }
            numberBlock.appendChild(inverseLine);
          }

          numberEl.append(indexBadge, numberBlock);

          const details = document.createElement("div");
          details.className = "bias-ranking-item__details";
          const pct = (ratio * 100).toFixed(1);
          details.innerHTML = `<strong>${pct}%</strong> en ${rankingTurn} ¬∑ ${entry.turnCount} apariciones`;

          const meter = document.createElement("div");
          meter.className = "bias-ranking-item__meter";
          const fill = document.createElement("div");
          fill.className = "bias-ranking-item__meter-fill";
          fill.style.width = `${Math.min(100, ratio * 100)}%`;
          meter.appendChild(fill);

          item.append(numberEl, details, meter);
          rankingList.appendChild(item);
        });
        rankingBlock.appendChild(rankingList);
        card.appendChild(rankingBlock);
      }

      const list = document.createElement("div");
      list.className = "bias-list";

      const selectedSet = new Set(selectedEntries.map((entry) => entry.numero));
      pageEntries.forEach((entry) => {
        const row = document.createElement("div");
        row.className = "bias-row";
        const isSelected = selectedSet.has(entry.numero);
        if (isSelected) row.classList.add("bias-row--selected");

        const numberEl = document.createElement("div");
        numberEl.className = "bias-number";
        const symbol = getSymbol(entry.numero);
        const symbolSpan = symbol ? `<span class="bias-number-symbol">${symbol}</span>` : "";
        numberEl.innerHTML = `<span class="bias-number-main">${formatNumber(entry.numero)}</span>${symbolSpan}`;

        const statsEl = document.createElement("div");
        statsEl.className = "bias-metrics";
        const ratioPct = (entry.ratio * 100).toFixed(1);
        const biasPct = (entry.bias * 100).toFixed(1);
        const biasTag = document.createElement("span");
        biasTag.className = `bias-chip ${entry.bias >= 0 ? "bias-chip--positive" : "bias-chip--neutral"}`;
        biasTag.textContent = `${entry.bias >= 0 ? "+" : ""}${biasPct} pts`;
        statsEl.innerHTML = `<strong>${ratioPct}%</strong> apariciones`;
        statsEl.appendChild(biasTag);

        const metaEl = document.createElement("div");
        metaEl.className = "bias-meta";
        const totalReg = Number.isFinite(entry.total) ? entry.total : "?";
        metaEl.textContent = `${entry.count} de ${totalReg} registros`;

        row.appendChild(numberEl);
        row.appendChild(statsEl);
        row.appendChild(metaEl);
        const turnWrap = document.createElement("div");
        turnWrap.className = "bias-turns";
        entry.turnBreakdown.forEach((turnEntry) => {
          const chip = document.createElement("span");
          chip.className = "bias-turn";
          if (!turnEntry.count) chip.classList.add("bias-turn--zero");
          chip.innerHTML = `<strong>${turnEntry.turno}</strong> ${(turnEntry.ratio * 100).toFixed(0)}% ¬∑ ${turnEntry.count}x`;
          turnWrap.appendChild(chip);
        });
        row.appendChild(turnWrap);

        const actions = document.createElement("div");
        actions.className = "bias-row-actions";
        const selectBtn = document.createElement("button");
        selectBtn.type = "button";
        selectBtn.className = `bias-select-btn${isSelected ? " bias-select-btn--active" : ""}`;
        selectBtn.textContent = isSelected ? "En apunte" : "Agregar al apunte";
        selectBtn.disabled = isSelected;
        selectBtn.addEventListener("click", () => {
          if (isSelected) return;
          const payload = {
            numero: entry.numero,
            ratio: entry.ratio,
            bias: entry.bias,
            count: entry.count,
            total: Number.isFinite(entry.total) ? entry.total : null,
            turnBreakdown: entry.turnBreakdown.map((turn) => ({ ...turn })),
            symbol: symbol || "",
          };
          biasPanelState.selected = [...selectedEntries, payload];
          syncBiasNotesPersistence(targetDow);
          renderSesgosPorDia(map, { dow: targetDow, year });
        });
        actions.appendChild(selectBtn);
        row.appendChild(actions);

        list.appendChild(row);
      });

      card.appendChild(list);
      if (totalPages > 1) {
        const pager = document.createElement("div");
        pager.className = "bias-pagination";
        const prevBtn = document.createElement("button");
        prevBtn.type = "button";
        prevBtn.textContent = "‚Äπ";
        prevBtn.disabled = currentPage === 0;
        prevBtn.addEventListener("click", () => {
          if (biasPanelState.page > 0) {
            biasPanelState.page -= 1;
            renderSesgosPorDia(map, { dow: targetDow, year });
          }
        });
        const info = document.createElement("span");
        info.textContent = `P√°gina ${currentPage + 1}/${totalPages}`;
        const nextBtn = document.createElement("button");
        nextBtn.type = "button";
        nextBtn.textContent = "‚Ä∫";
        nextBtn.disabled = currentPage >= totalPages - 1;
        nextBtn.addEventListener("click", () => {
          if (biasPanelState.page < totalPages - 1) {
            biasPanelState.page += 1;
            renderSesgosPorDia(map, { dow: targetDow, year });
          }
        });
        pager.append(prevBtn, info, nextBtn);
        card.appendChild(pager);
      }
      resultBias.appendChild(card);
    }

    function computePerfilSesgoDia(perfil, dow, year = null) {
      if (!perfil || !Number.isFinite(dow)) return null;
      const total = perfil.total || 0;
      if (!total) return null;
      const porDia = perfil.porDiaSemana || {};
      const histCount = porDia[dow] || 0;
      const histRatio = total ? histCount / total : 0;
      let combined = histRatio;
      if (year !== null && perfil.porDiaSemanaPorAnio?.[year]) {
        const bucket = perfil.porDiaSemanaPorAnio[year];
        const yearTotal = bucket?._total || 0;
        if (yearTotal) {
          const yearRatio = (bucket[dow] || 0) / yearTotal;
          combined = yearRatio * 0.7 + histRatio * 0.3;
        }
      }
      const bias = combined - BASELINE_DOW_RATIO;
      return {
        ratio: combined,
        bias,
        count: histCount,
        total,
      };
    }


    const PEGA3_TURN_LABELS = {
      "11AM": "11 AM",
      "3PM": "3 PM",
      "9PM": "9 PM",
    };
    const PEGA3_TURN_SEQUENCE = ["11AM", "3PM", "9PM"];
    let pega3TurnPointer = 0;
    const PEGA3_COUNTRY_LABELS = {
      HN: "Honduras",
      NI: "Nicaragua",
      SV: "El Salvador",
    };
    const PEGA3_COLOR_BUCKETS = 6;
    const PEGA3_CONVERSION_LABELS = {
      simple: "Conversi√≥n simple",
      ajuste: "Ajuste (100‚àín)",
      composite: "Conversi√≥n compuesta",
    };

    function detectPega3Turno(now = new Date()) {
      const hour = now.getHours();
      if (hour >= 20) return "9PM";
      if (hour >= 14) return "3PM";
      return "11AM";
    }

    function updatePega3TurnPointer(value) {
      const idx = PEGA3_TURN_SEQUENCE.indexOf(value);
      pega3TurnPointer = idx >= 0 ? idx : 0;
    }

    function normalizeTwoDigit(numero) {
      if (!Number.isFinite(numero)) return null;
      const mod = numero % 100;
      return mod < 0 ? mod + 100 : mod;
    }

    function computePega3Ajuste(numero) {
      const normalized = normalizeTwoDigit(numero);
      if (normalized === null) return null;
      return (100 - normalized) % 100;
    }

    function buildPega3ConversionPool(numero) {
      const normalized = normalizeTwoDigit(numero);
      if (normalized === null) return [];
      const entries = new Map();
      const pushCandidate = (value, label) => {
        const candidate = normalizeTwoDigit(value);
        if (candidate === null) return;
        if (!entries.has(candidate)) {
          entries.set(candidate, { numero: candidate, label });
        }
      };
      const simpleList = getSimpleConversions(normalized) || [];
      simpleList.forEach((value) => pushCandidate(value, PEGA3_CONVERSION_LABELS.simple));
      const ajuste = computePega3Ajuste(normalized);
      if (ajuste !== null) pushCandidate(ajuste, PEGA3_CONVERSION_LABELS.ajuste);
      const compositeList = getCompositeConversions(normalized) || [];
      compositeList.forEach((value) => pushCandidate(value, PEGA3_CONVERSION_LABELS.composite));
      if (!entries.size) {
        pushCandidate(normalized, "Base");
      }
      return Array.from(entries.values());
    }

    function pickRandomEntry(list = []) {
      if (!Array.isArray(list) || !list.length) return null;
      const idx = Math.floor(Math.random() * list.length);
      return list[idx] || null;
    }

    function advancePega3TurnPointer({ rollDate = false } = {}) {
      const prevPointer = pega3TurnPointer;
      pega3TurnPointer = (pega3TurnPointer + 1) % PEGA3_TURN_SEQUENCE.length;
      const loopedToStart =
        prevPointer === PEGA3_TURN_SEQUENCE.length - 1 && pega3TurnPointer === 0;
      if (pega3TurnoSelect) {
        if (rollDate && loopedToStart && pega3FechaInput) {
          const nextDate = incrementISODate(pega3FechaInput.value, 1);
          if (nextDate) pega3FechaInput.value = nextDate;
        }
        pega3TurnoSelect.value = PEGA3_TURN_SEQUENCE[pega3TurnPointer];
        prefillPega3Inputs({ forceClear: true });
      }
    }

    function syncPega3Context({ force = false } = {}) {
      if (!pega3FechaInput || !pega3TurnoSelect || !pega3PaisSelect) return;
      const now = new Date();
      if (force || !pega3FechaInput.value) {
        pega3FechaInput.value = getTodayISODate();
      }
      if (force || !pega3TurnoSelect.value) {
        pega3TurnoSelect.value = detectPega3Turno(now);
      }
      if (force || !pega3PaisSelect.value) {
        pega3PaisSelect.value = "HN";
      }
      updatePega3TurnPointer(pega3TurnoSelect.value);
      prefillPega3Inputs({ forceClear: true });
    }

    syncPega3Context();
    pega3ContextSyncBtn?.addEventListener("click", () => syncPega3Context({ force: true }));
    pega3TurnoSelect?.addEventListener("change", () => {
      updatePega3TurnPointer(pega3TurnoSelect.value);
      prefillPega3Inputs({ forceClear: true });
    });
    pega3FechaInput?.addEventListener("change", () => prefillPega3Inputs({ forceClear: true }));
    pega3PaisSelect?.addEventListener("change", () => prefillPega3Inputs({ forceClear: true }));

    async function handlePega3Save(event) {
      event?.preventDefault();
      const fecha = pega3FechaInput?.value;
      const horario = pega3TurnoSelect?.value || "11AM";
      const pais = (pega3PaisSelect?.value || "HN").toUpperCase();
      const pares = pega3ParInputs
        .map((input) => parseInt(input?.value ?? "", 10))
        .filter((value) => Number.isFinite(value));
      if (!fecha || pares.length !== 3) {
        showToast("Completa la fecha y los tres pares antes de guardar.", { variant: "warning" });
        return;
      }
      const cachedMatch = findCachedPega3Draw({ fecha, horario, pais });
      if (cachedMatch && pega3ActiveDrawId !== cachedMatch.id) {
        showToast("Ya tienes un sorteo registrado para ese turno y fecha. Usa la vista de historial o edita el registro actual.", {
          variant: "warning",
          timeout: 4000,
        });
        fillPega3InputsFromDraw(cachedMatch);
        updatePega3FormStatus(cachedMatch);
        return;
      }
      const isUpdating = Boolean(pega3ActiveDrawId);
      try {
        await DB.savePega3Draw({ fecha, horario, pais, pares });
        const toastMsg = isUpdating ? "Sorteo Pega3 actualizado." : "Sorteo Pega3 guardado.";
        showToast(toastMsg, { variant: "success", timeout: 2000 });
        pega3ParInputs.forEach((input) => {
          if (input) input.value = "";
        });
        advancePega3TurnPointer({ rollDate: horario === "9PM" });
        await refreshPega3Historial({ silent: true });
      } catch (err) {
        console.error("pega3 save error", err);
        showToast(`No se pudo guardar el sorteo: ${err.message}`, { variant: "danger" });
      }
    }

    async function refreshPega3Historial({ silent = false } = {}) {
      if (!pega3Historial) return;
      if (!silent) pega3Historial.innerHTML = "<p class='hint'>Cargando historial‚Ä¶</p>";
      try {
        const list = await DB.listPega3Draws();
        pega3DrawCache = list
          .slice()
          .sort((a, b) => {
            if (a.fecha === b.fecha) {
              return TURNOS.indexOf(b.horario) - TURNOS.indexOf(a.horario);
            }
            return a.fecha > b.fecha ? -1 : 1;
          });
        renderPega3HistorialList(pega3DrawCache);
        prefillPega3Inputs();
      } catch (err) {
        console.error("pega3 historial error", err);
        pega3Historial.innerHTML = `<p class='hint'>No se pudo leer el historial: ${err.message}</p>`;
      }
    }

    function clearPega3Inputs() {
      pega3ParInputs.forEach((input) => {
        if (input) input.value = "";
      });
    }

    function updatePega3FormStatus(draw = null) {
      pega3ActiveDrawId = draw?.id ?? null;
      const statusEl = pega3FormStatus;
      if (statusEl) {
        if (draw) {
          const friendlyDate = draw.fecha ? formatFriendlyDate(draw.fecha) : "";
          const turnoLabel = PEGA3_TURN_LABELS[draw.horario] || draw.horario || "";
          const paisCode = (draw.pais || "HN").toUpperCase();
          const paisLabel = PEGA3_COUNTRY_LABELS[paisCode] || paisCode;
          const descriptor = [friendlyDate || draw.fecha || "", turnoLabel, paisLabel]
            .filter(Boolean)
            .join(" ¬∑ ");
          statusEl.textContent = descriptor ? `Sorteo registrado: ${descriptor}` : "Sorteo registrado.";
          statusEl.dataset.state = "filled";
        } else {
          statusEl.textContent = "";
          statusEl.dataset.state = "empty";
        }
      }
      if (pega3SaveBtn) {
        pega3SaveBtn.textContent = draw ? "Actualizar sorteo" : "Guardar sorteo";
      }
    }

    function normalizePega3Value(value) {
      if (typeof value === "number") {
        return Number.isFinite(value) ? value : null;
      }
      if (typeof value === "string" && value.trim() !== "") {
        const parsed = parseInt(value, 10);
        return Number.isNaN(parsed) ? null : parsed;
      }
      return null;
    }

    function fillPega3InputsFromDraw(draw) {
      if (!draw) return;
      pega3ParInputs.forEach((input, idx) => {
        if (!input) return;
        const rawValue = Array.isArray(draw.pares) ? draw.pares[idx] : null;
        const normalized = normalizePega3Value(rawValue);
        input.value = normalized === null ? "" : formatNumber(normalized);
      });
    }

    function computePega3DateColorIndex(key) {
      if (!key || !PEGA3_COLOR_BUCKETS) return 0;
      let hash = 0;
      for (let i = 0; i < key.length; i += 1) {
        hash = (hash * 31 + key.charCodeAt(i)) | 0;
      }
      return Math.abs(hash) % PEGA3_COLOR_BUCKETS;
    }

    function findCachedPega3Draw({ fecha, horario, pais }) {
      if (!fecha || !horario) return null;
      const targetPais = (pais || "HN").toUpperCase();
      return (pega3DrawCache || []).find(
        (draw) =>
          draw.fecha === fecha &&
          draw.horario === horario &&
          ((draw.pais || "HN").toUpperCase() === targetPais),
      );
    }

    function prefillPega3Inputs({ forceClear = false } = {}) {
      if (!pega3FechaInput || !pega3TurnoSelect) return;
      const fecha = pega3FechaInput.value;
      const turno = pega3TurnoSelect.value;
      const paisValue = (pega3PaisSelect?.value || "HN").toUpperCase();
      if (!fecha || !turno) {
        if (forceClear) {
          clearPega3Inputs();
          updatePega3FormStatus(null);
        }
        return;
      }
      const match = findCachedPega3Draw({ fecha, horario: turno, pais: paisValue });
      if (match) {
        fillPega3InputsFromDraw(match);
        updatePega3FormStatus(match);
      } else {
        if (forceClear || pega3ParInputs.every((input) => !input || !input.value?.trim())) {
          clearPega3Inputs();
        }
        updatePega3FormStatus(null);
      }
    }

    function renderPega3HistorialList(draws = []) {
      if (!pega3Historial) return;
      if (!draws.length) {
        pega3Historial.innerHTML = "<p class='hint'>A√∫n no registras sorteos Pega3.</p>";
        return;
      }
      const fragment = document.createDocumentFragment();
      draws.slice(0, 60).forEach((row) => {
        const item = document.createElement("div");
        item.className = "pega3-entry";
        const colorIndex = computePega3DateColorIndex(row.fecha || "");
        item.dataset.colorIndex = colorIndex;
        const info = document.createElement("div");
        info.className = "pega3-entry__info";
        const title = document.createElement("strong");
        const friendly = row.fecha ? formatFriendlyDate(row.fecha) : row.fecha;
        title.textContent = `${friendly || "‚Äî"}`;
        const meta = document.createElement("span");
        meta.className = "pega3-entry__meta";
        const paisCode = (row.pais || "HN").toUpperCase();
        const paisLabel = PEGA3_COUNTRY_LABELS[paisCode] || paisCode;
        meta.textContent = `${PEGA3_TURN_LABELS[row.horario] || row.horario || ""} ¬∑ ${paisLabel}`;
        const nums = document.createElement("div");
        nums.className = "pega3-entry__pairs";
        nums.textContent = row.pares.map((n) => formatNumber(n)).join(" ‚Äì ");
        info.append(title, meta, nums);

        const actions = document.createElement("div");
        actions.className = "pega3-entry__actions";
        const deleteBtn = document.createElement("button");
        deleteBtn.type = "button";
        deleteBtn.className = "btn-ghost pega3-entry__delete";
        deleteBtn.textContent = "Eliminar";
        deleteBtn.addEventListener("click", () => handlePega3Delete(row));
        actions.appendChild(deleteBtn);

        item.appendChild(info);
        item.appendChild(actions);
        fragment.appendChild(item);
      });
      pega3Historial.innerHTML = "";
      pega3Historial.appendChild(fragment);
    }

    async function handlePega3Delete(row) {
      if (!row?.id) return;
      const labelDate = row.fecha ? formatFriendlyDate(row.fecha) || row.fecha : "este registro";
      const labelTurn = PEGA3_TURN_LABELS[row.horario] || row.horario || "";
      if (!pega3PendingDeletion.has(row.id)) {
        const timer = setTimeout(() => pega3PendingDeletion.delete(row.id), 5000);
        pega3PendingDeletion.set(row.id, timer);
        showToast(`Presiona eliminar otra vez para borrar el sorteo de ${labelDate}${labelTurn ? ` (${labelTurn})` : ""}.`, {
          variant: "warning",
          timeout: 3500,
        });
        return;
      }
      clearTimeout(pega3PendingDeletion.get(row.id));
      pega3PendingDeletion.delete(row.id);
      if (typeof DB.deletePega3Draw !== "function") {
        showToast("Esta versi√≥n no soporta eliminar sorteos. Actualiza la aplicaci√≥n.", { variant: "danger" });
        return;
      }
      try {
        await DB.deletePega3Draw(row.id);
        showToast("Sorteo Pega3 eliminado.", { variant: "success" });
        await refreshPega3Historial({ silent: true });
      } catch (err) {
        console.error("pega3 delete error", err);
        showToast(`No se pudo eliminar: ${err.message}`, { variant: "danger" });
      }
    }

    async function runPega3Analysis() {
      if (!pega3DrawCache.length) {
        showToast("Registra sorteos Pega3 para analizar.", { variant: "info" });
        return;
      }
      pega3Resumen.innerHTML = "<p class='hint'>Analizando patrones‚Ä¶</p>";
      pega3Sesgos.innerHTML = "";
      pega3Seleccion.innerHTML = "";
      try {
        const diariaDraws = await DB.listDraws({ excludeTest: true });
        const resultado = evaluarMotorPega3(pega3DrawCache, { externa: diariaDraws });
        pega3AnalysisCache = resultado;
        renderPega3Panels();
      } catch (err) {
        console.error("pega3 analysis error", err);
        pega3Resumen.innerHTML = `<p class='hint'>No se pudo completar el an√°lisis: ${err.message}</p>`;
      }
    }

    function renderPega3Panels() {
      if (!pega3Resumen) return;
      if (!pega3AnalysisCache?.stats) {
        pega3Resumen.innerHTML = "<p class='hint'>Registra sorteos y ejecuta el an√°lisis para ver los hallazgos.</p>";
        pega3Sesgos.innerHTML = "";
        pega3Seleccion.innerHTML = "";
        return;
      }
      renderPega3Summary(pega3AnalysisCache.stats);
      renderPega3Sesgos(pega3AnalysisCache.sesgos);
      renderPega3Seleccion(pega3AnalysisCache.seleccion);
    }

    function renderPega3Summary(stats) {
      if (!pega3Resumen) return;
      const totalDraws = stats.totalDraws || 0;
      const topNumero = stats.numeroList?.[0];
      const topPair = stats.pairList?.[0];
      const pattern = stats.patternSummary || {};
      const cross = stats.crossTurn || {};
      const external = stats.externalSummary || [];
      const parts = [];
      parts.push(`<strong>Total sorteos:</strong> ${totalDraws}`);
      if (topNumero) {
        parts.push(
          `<strong>N√∫mero dominante:</strong> ${formatNumber(topNumero.numero)} ¬∑ ${(topNumero.freq * 100).toFixed(2)}% global ¬∑ Turno favorito ${topNumero.turnoFuerte}`,
        );
      }
      if (topPair) {
        parts.push(
          `<strong>Par destacado:</strong> [${topPair.numeros.map((n) => formatNumber(n)).join(" ‚Äì ")}] ¬∑ ${topPair.total} repeticiones`,
        );
      }
      parts.push(
        `<strong>Patrones internos:</strong> repetidos ${pattern.repetidos || 0}, vecinos ${pattern.vecinos || 0}, espejos ${pattern.espejos || 0}, progresiones ${pattern.escaleras || 0}`,
      );
      parts.push(
        `<strong>Arrastres entre turnos:</strong> coincidencias directas ${cross.directas || 0}, espejos ${cross.espejos || 0}, repeticiones ${cross.repeticiones || 0}`,
      );
      if (external.length) {
        const topExt = external.slice(0, 2).map((item) => `${formatNumber(item.numero)} (${Math.round(item.coef * 100)}%)`);
        parts.push(`<strong>Correlaci√≥n con La Diaria:</strong> ${topExt.join(" ¬∑ ")}`);
      }
      pega3Resumen.innerHTML = `<ul class="analysis-note">${parts.map((text) => `<li>${text}</li>`).join("")}</ul>`;
    }

    function renderPega3Sesgos({ fuertes = [], moderados = [], debiles = [] } = {}) {
      if (!pega3Sesgos) return;
      const build = (titulo, lista) => {
        if (!lista.length) {
          return `<p class="hint">${titulo}: sin datos.</p>`;
        }
        const items = lista
          .slice(0, 8)
          .map(
            (entry) =>
              `<li><span>${formatNumber(entry.numero)}</span><span>${Math.round((entry.score || 0) * 100)}%</span></li>`,
          )
          .join("");
        return `<div class="pega3-sesgo"><h5>${titulo}</h5><ul>${items}</ul></div>`;
      };
      pega3Sesgos.innerHTML = `
        <div class="pega3-sesgos-grid">
          ${build("Sesgos fuertes", fuertes)}
          ${build("Sesgos moderados", moderados)}
          ${build("Sesgos d√©biles", debiles)}
        </div>
      `;
    }

    function renderPega3Seleccion(seleccion) {
      if (!pega3Seleccion) return;
      if (!seleccion?.top?.length) {
        pega3Seleccion.innerHTML = "<p class='hint'>Calcula los sesgos para generar candidatos finales.</p>";
        return;
      }
      const topList = seleccion.top
        .map((item) => `<li><span>${formatNumber(item.numero)}</span><span>${Math.round(item.score * 100)}%</span></li>`)
        .join("");
      const secList = (seleccion.secundarios || [])
        .map((item) => `<li><span>${formatNumber(item.numero)}</span><span>${Math.round(item.score * 100)}%</span></li>`)
        .join("");
      pega3Seleccion.innerHTML = `
        <div class="final-selection">
          <div class="final-selection__head">
            <h3>Selecci√≥n final Pega3</h3>
            <p class="hint">Turno objetivo: ${seleccion.turnoObjetivo?.label || "pendiente"}</p>
          </div>
          <article class="final-block">
            <h4>Top Picks</h4>
            <ul class="final-block__list">${topList}</ul>
          </article>
          <article class="final-block">
            <h4>Candidatos secundarios</h4>
            ${
              secList
                ? `<ul class="final-block__list">${secList}</ul>`
                : "<p class='hint'>Sin secundarios con score ‚â• 35%.</p>"
            }
          </article>
          <article class="final-block final-block--wildcard">
            <h4>Comod√≠n disruptor</h4>
            <div class="final-block__wildcard">${formatNumber(seleccion.comodin ?? seleccion.top[seleccion.top.length - 1].numero)}</div>
          </article>
        </div>
      `;
    }

    function resetPega3GeneratorOutput(message = "Ingresa los tres pares para desbloquear una propuesta.") {
      if (!pega3GeneratorOutput) return;
      pega3GeneratorOutput.innerHTML = `<p class='hint small'>${message}</p>`;
    }

    function renderPega3ConversionResult(result = []) {
      if (!pega3GeneratorOutput) return;
      if (!result.length) {
        resetPega3GeneratorOutput("No hay conversiones suficientes. Revisa los pares ingresados.");
        return;
      }
      const summary = document.createElement("div");
      summary.className = "pega3-generator__summary";
      summary.innerHTML = `
        <strong>${result.map((entry) => formatNumber(entry.numero)).join(" ‚Äì ")}</strong>
        <span>Tr√≠o sugerido con conversiones aleatorias.</span>
      `;
      const grid = document.createElement("div");
      grid.className = "pega3-generator__trio";
      result.forEach((entry, idx) => {
        const block = document.createElement("div");
        block.className = "pega3-generator__item";
        const badge = document.createElement("span");
        badge.className = "pega3-generator__badge";
        badge.textContent = `Par ${idx + 1}`;
        const strong = document.createElement("strong");
        strong.textContent = formatNumber(entry.numero);
        const detail = document.createElement("small");
        detail.textContent = entry.label || "Conversi√≥n";
        const base = document.createElement("span");
        base.className = "pega3-generator__base";
        base.textContent = `Base ${formatNumber(entry.base)}`;
        block.append(badge, strong, detail, base);
        grid.appendChild(block);
      });
      pega3GeneratorOutput.innerHTML = "";
      pega3GeneratorOutput.append(summary, grid);
    }

    function generatePega3ConversionTrio() {
      if (!pega3GeneratorOutput) return;
      const bases = pega3ParInputs
        .map((input) => normalizePega3Value(input?.value))
        .map((value) => (Number.isFinite(value) ? value : null));
      if (bases.some((value) => value === null)) {
        showToast("Completa los tres pares para generar el tr√≠o de conversiones.", { variant: "warning" });
        resetPega3GeneratorOutput("Completa los tres pares para poder calcular el tr√≠o.");
        return;
      }
      const trio = bases.map((numero) => {
        const pool = buildPega3ConversionPool(numero);
        const pick = pickRandomEntry(pool) || { numero, label: "Base" };
        return { ...pick, base: numero };
      });
      renderPega3ConversionResult(trio);
    }

    resetPega3GeneratorOutput();
    pega3SaveBtn?.addEventListener("click", handlePega3Save);
    document.getElementById("pega3-btn-cargar")?.addEventListener("click", () => refreshPega3Historial());
    document.getElementById("pega3-btn-analizar")?.addEventListener("click", () => runPega3Analysis());
    pega3GeneratorBtn?.addEventListener("click", () => generatePega3ConversionTrio());
    pega3ParInputs.forEach((input) => {
      input?.addEventListener("input", () => resetPega3GeneratorOutput("Vuelve a generar el tr√≠o para reflejar los cambios."));
    });

    function aplicarBonusEstrategias(predicciones = [], estrategias = [], contexto = {}) {
      if (!Array.isArray(predicciones) || !predicciones.length) return predicciones;
      if (!Array.isArray(estrategias) || !estrategias.length) return predicciones;
      const bonusByNumero = new Map();
      const matchFecha = contexto.fecha || null;
      const matchPais = (contexto.pais || "").trim().toUpperCase() || null;
      estrategias.forEach((entry) => {
        const targetNumero = Number(entry?.target?.numero);
        if (!Number.isFinite(targetNumero)) return;
        if (matchFecha && entry.target?.fecha !== matchFecha) return;
        if (
          matchPais &&
          (entry.target?.pais || "").trim().toUpperCase() !== matchPais
        )
          return;
        const base = entry.operador === "+" ? 0.18 : 0.14;
        const historyBoost = Math.min(0.12, (entry.historyCount || 0) * 0.02);
        bonusByNumero.set(targetNumero, (bonusByNumero.get(targetNumero) || 0) + base + historyBoost);
      });
      if (!bonusByNumero.size) return predicciones;
      return predicciones
        .map((pred) => {
          const bonus = bonusByNumero.get(pred.numero);
          if (!bonus) return pred;
          return {
            ...pred,
            score: (pred.score || 0) + bonus,
            strategyBonus: (pred.strategyBonus || 0) + bonus,
          };
        })
        .sort((a, b) => (b.score || 0) - (a.score || 0));
    }

    function mezclarPrediccionesConModos(predicciones, modoEval) {
      if (!modoEval) return predicciones;
      const scoreMap = new Map();
      Object.entries(modoEval.scorePorNumero || {}).forEach(([key, value]) => {
        const numero = parseInt(key, 10);
        if (!Number.isFinite(numero)) return;
        if (Number.isFinite(value)) scoreMap.set(numero, value);
      });
      const detallePorNumero = modoEval.detallePorNumero || {};

      const merged = predicciones.map((p) => {
        const boost = scoreMap.get(p.numero) || 0;
        const key = String(p.numero).padStart(2, "0");
        const modos = detallePorNumero[key] || [];
        const newScore = Math.min(1, p.score + boost * 0.35);
        return { ...p, score: newScore, modoBoost: boost, modos };
      });

      const existentes = new Set(merged.map((p) => p.numero));
      (modoEval.sugerencias || []).forEach((sug) => {
        const numero = parseInt(sug.numero, 10);
        if (!Number.isFinite(numero)) return;
        if (!existentes.has(numero)) {
          const score = Math.min(1, (sug.confianza || 0) * 0.6);
          merged.push({
            numero,
            score,
            frecuencia: 0,
            recencia: 0,
            hipotesis: 0,
            contexto: 0,
            modoBoost: sug.confianza || 0,
            modos: [sug],
            afinidadDia: 0,
            afinidadPais: 0,
            afinidadAnio: 0,
          });
          existentes.add(numero);
        } else {
          const target = merged.find((p) => p.numero === numero);
          if (target) target.modos = [...(target.modos || []), sug];
        }
      });

      merged.sort((a, b) => b.score - a.score);
      return merged.slice(0, 9);
    }

    function renderEscenarios(
      escenarios,
      patrones,
      predicciones = [],
      perfilMap = new Map(),
      totalDraws = 0,
      latestTimestamp = null,
      insights = [],
      modoEval = null
    ) {
      if (!resultEscenarios) return;
      resultEscenarios.innerHTML = "";

      const grid = document.createElement("div");
      grid.className = "analysis-grid";
      resultEscenarios.appendChild(grid);

      if (latestTimestamp) {
        const daysDiff = Math.floor((Date.now() - latestTimestamp) / (1000 * 60 * 60 * 24));
        if (daysDiff > 30) {
          const lastWarnTs = getRecencyWarnTs();
          if (lastWarnTs !== latestTimestamp) {
            const lastDate = formatDateISO(latestTimestamp);
            showToast(
              `√öltimo sorteo registrado: ${lastDate} (‚âà${daysDiff} d√≠as). Agrega resultados recientes para reemplazar las predicciones simuladas.`,
              { variant: "warning", timeout: 9000 }
            );
            setRecencyWarnTs(latestTimestamp);
          }
        }
      }

      if (patrones?.mensaje) {
        const card = document.createElement("div");
        card.className = "analysis-card summary";
        const head = document.createElement("div");
        head.className = "card-head";
        head.textContent = "Tendencias recientes";
        card.appendChild(head);

        const note = document.createElement("div");
        note.className = "analysis-note";
        note.textContent = patrones.mensaje;
        card.appendChild(note);

        if (patrones.resumenVentana) {
          const windowNote = document.createElement("div");
          windowNote.className = "analysis-footnote";
          windowNote.textContent = patrones.resumenVentana;
          card.appendChild(windowNote);
        }
        grid.appendChild(card);
      }

      if (modoEval?.sugerencias?.length) {
        const card = document.createElement("div");
        card.className = "analysis-card insight accent-medium";
        const head = document.createElement("div");
        head.className = "card-head";
        head.textContent = "Modos aprendidos";
        card.appendChild(head);

        const list = document.createElement("ul");
        list.className = "analysis-insights";
        modoEval.sugerencias.slice(0, 6).forEach((sug) => {
          const li = document.createElement("li");
          const conf = Math.round((sug.confianza || 0) * 100);
          const base = String(sug.baseNumero ?? sug.original ?? "").padStart(2, "0");
          const target = String(sug.numero).padStart(2, "0");
          const modeName = sug.modeNombre || "Modo";
          const opLabel = OPERACION_LABELS[sug.operacion];
          const opTag = opLabel ? ` ¬∑ ${opLabel}` : "";
          const nota = sug.nota ? ` ‚Äî ${sug.nota}` : "";
          li.innerHTML = `<strong>${modeName}</strong>${opTag}: ${base} ‚Üí ${target} (${conf}% conf)${nota}`;
          list.appendChild(li);
        });
        card.appendChild(list);
        grid.appendChild(card);
      }

      if (patrones?.hallazgos?.length) {
        patrones.hallazgos.forEach((hallazgo) => {
          const card = document.createElement("div");
          card.className = "analysis-card pattern";
          const conf = Math.round((hallazgo.confianza || 0) * 100);
          const level = hallazgo.confianza >= 0.75 ? "accent-strong" : hallazgo.confianza >= 0.5 ? "accent-medium" : "accent-soft";
          card.classList.add(level);

          const header = document.createElement("div");
          header.className = "card-head";
          header.textContent = hallazgo.titulo;

          const badge = document.createElement("span");
          badge.className = `analysis-badge ${level}`;
          badge.textContent = conf ? `${conf}% confianza` : "Sin m√©trica";
          header.appendChild(badge);
          card.appendChild(header);

          const number = Number.isFinite(hallazgo.numero)
            ? hallazgo.numero
            : Number.isFinite(hallazgo.evidencia?.[0]?.numero)
              ? hallazgo.evidencia[0].numero
              : null;
          if (Number.isFinite(number)) {
            const numberBadge = document.createElement("div");
            numberBadge.className = "analysis-number-lg";
            const formattedNumber = formatNumber(number);
            const symbol = getSymbol(number);
            const symbolSpan = symbol
              ? `<span class="analysis-number-symbol">${symbol}</span>`
              : "";
            numberBadge.innerHTML = `<span class="analysis-number-main">${formattedNumber}</span>${symbolSpan}`;
            card.appendChild(numberBadge);
          }

          const resumen = document.createElement("div");
          resumen.className = "pattern-summary";

          const detailList = document.createElement("ul");
          detailList.className = "pattern-detail";

          const addLine = (entry, fallbackClass) => {
            if (!entry) return;
            const config = typeof entry === "string" ? { text: entry } : { ...entry };
            const rawContent =
              typeof config.html === "string" ? config.html : config.text ?? "";
            if (typeof rawContent === "string" && !rawContent.trim()) return;
            const li = document.createElement("li");
            const classNames = (config.className || fallbackClass || "")
              .split(/\s+/)
              .map((cls) => cls.trim())
              .filter(Boolean);
            classNames.forEach((cls) => li.classList.add(cls));
            if (typeof config.html === "string") {
              li.innerHTML = config.html;
            } else {
              li.textContent = rawContent;
            }
            const hasSubentry = li.classList.contains("pattern-subentry");
            const iconValue =
              config.icon !== undefined
                ? config.icon
                : hasSubentry
                  ? "‚Ü≥"
                  : "‚Ä¢";
            if (iconValue) li.dataset.icon = iconValue;
            detailList.appendChild(li);
          };

          const formatTimelineSample = (s) => formatSampleDisplay({ fecha: s?.fecha, horario: s?.horario }) || "";

          if (hallazgo.id?.startsWith("gap-")) {
            const datos = hallazgo.datos || {};
            addLine({
              html: `<span class="pattern-label">Apariciones en ventana</span><div class="pattern-line"><span class="pattern-value">${datos.apariciones ?? "?"}</span></div>`,
              icon: "üìà",
            });
            addLine({
              html: `<span class="pattern-label">Intervalo modal</span><div class="pattern-line"><span class="pattern-value">${datos.gap ?? "?"} d√≠as</span><span class="pattern-muted">Coincidencias ${datos.coincidencias ?? "?"} de ${datos.intervalos ?? "?"}</span></div>`,
              icon: "‚è±Ô∏è",
            });
            if (hallazgo.siguienteFechaEsperada) {
              const proximoDisplay = formatSampleDisplay({
                fecha: hallazgo.siguienteFechaEsperada,
                horario: datos.siguienteHorario,
              });
              addLine({
                html: `<span class="pattern-label">Pr√≥xima estimada</span><div class="pattern-line"><span class="pattern-value">${proximoDisplay || hallazgo.siguienteFechaEsperada}</span></div>`,
                icon: "üß≠",
              });
            }
            (hallazgo.evidencia || []).slice(-3).forEach((item) => {
              if (!item) return;
              const origen = item.origen || {};
              const baseTxt = formatTimelineSample(origen) || "?";
              const destTxt = formatTimelineSample(item) || "?";
              addLine({
                text: `${baseTxt} ‚Üí ${destTxt}`,
                className: "pattern-subentry",
                icon: "‚Ü¨",
              });
            });
          } else if (hallazgo.id?.startsWith("dayOfWeek")) {
            const datos = hallazgo.datos || {};
            const etiqueta = datos.etiquetaCompleta || hallazgo.etiqueta || "";
            const ratio = Number.isFinite(datos.ratio) ? Math.round(datos.ratio * 100) : null;
            addLine({
              html: `<span class="pattern-label">D√≠a dominante</span><div class="pattern-line"><span class="pattern-value">${etiqueta}</span></div>`,
              icon: "üìÖ",
            });
            addLine({
              html: `<span class="pattern-label">Apariciones</span><div class="pattern-line"><span class="pattern-value">${datos.count ?? "?"}/${datos.total ?? "?"}</span>${ratio !== null ? `<span class="pattern-muted">${ratio}%</span>` : ""}</div>`,
              icon: "üìä",
            });
            const samples = datos.samples || [];
            if (samples.length) {
              addLine({ html: `<span class="pattern-label">√öltimos registros</span>`, icon: "üóÇÔ∏è" });
              samples.forEach((s) =>
                addLine({
                  text: formatTimelineSample(s) || "?",
                  className: "pattern-subentry",
                })
              );
            }
            if (datos.historial?.count) {
              const hist = datos.historial;
              const histRatio = Number.isFinite(hist.ratio) ? Math.round(hist.ratio * 100) : null;
              addLine({
                html: `<span class="pattern-label">Historial</span><div class="pattern-line"><span class="pattern-value">${hist.count} coincidencias</span>${histRatio !== null ? `<span class="pattern-muted">${histRatio}% del hist√≥rico</span>` : ""}</div>`,
                icon: "üß¨",
              });
              (hist.muestras || []).forEach((texto) =>
                addLine({ text: texto, className: "pattern-subentry" })
              );
            }
          } else if (hallazgo.id?.startsWith("horario")) {
            const datos = hallazgo.datos || {};
            const etiqueta = hallazgo.etiqueta || "";
            const ratio = Number.isFinite(datos.ratio) ? Math.round(datos.ratio * 100) : null;
            addLine({
              html: `<span class="pattern-label">Turno preferido</span><div class="pattern-line"><span class="pattern-value">${etiqueta}</span></div>`,
              icon: "üïí",
            });
            addLine({
              html: `<span class="pattern-label">Coincidencias</span><div class="pattern-line"><span class="pattern-value">${datos.count ?? "?"}/${datos.total ?? "?"}</span>${ratio !== null ? `<span class="pattern-muted">${ratio}%</span>` : ""}</div>`,
              icon: "üìä",
            });
            const samples = datos.samples || [];
            if (samples.length) {
              addLine({ html: `<span class="pattern-label">√öltimos registros</span>`, icon: "üóÇÔ∏è" });
              samples.forEach((s) =>
                addLine({
                  text: formatTimelineSample(s) || "?",
                  className: "pattern-subentry",
                })
              );
            }
            if (datos.historial?.count) {
              const hist = datos.historial;
              const histRatio = Number.isFinite(hist.ratio) ? Math.round(hist.ratio * 100) : null;
              addLine({
                html: `<span class="pattern-label">Historial</span><div class="pattern-line"><span class="pattern-value">${hist.count} coincidencias</span>${histRatio !== null ? `<span class="pattern-muted">${histRatio}% del hist√≥rico</span>` : ""}</div>`,
                icon: "üßæ",
              });
              (hist.muestras || []).forEach((texto) =>
                addLine({ text: texto, className: "pattern-subentry" })
              );
            }
          } else if (hallazgo.id?.startsWith("repeat-")) {
            const datos = hallazgo.datos || {};
            const tipo = datos.tipo || "";
            const ratio = Number.isFinite(datos.ratio) ? Math.round(datos.ratio * 100) : null;
            addLine({
              html: `<span class="pattern-label">Repite ${tipo}</span><div class="pattern-line"><span class="pattern-value">${datos.repeticiones ?? "?"} de ${datos.total ?? "?"}</span>${ratio !== null ? `<span class="pattern-muted">${ratio}%</span>` : ""}</div>`,
              icon: "üîÅ",
            });
            (datos.muestras || []).forEach((linea) =>
              addLine({
                text: formatTimelineSample(linea) || "",
                className: "pattern-subentry",
              })
            );
            if (datos.historial?.count) {
              const hist = datos.historial;
              const histRatio = Number.isFinite(hist.ratio) ? Math.round(hist.ratio * 100) : null;
              addLine({
                html: `<span class="pattern-label">Historial</span><div class="pattern-line"><span class="pattern-value">${hist.count} repeticiones</span>${histRatio !== null ? `<span class="pattern-muted">${histRatio}% del hist√≥rico</span>` : ""}</div>`,
                icon: "üßæ",
              });
            }
          } else {
            addLine({ text: hallazgo.resumen, icon: "‚ú®" });
          }

          if (!detailList.children.length) {
            addLine({ text: hallazgo.resumen ?? "Sin detalles adicionales.", icon: "‚ÑπÔ∏è" });
          }

          resumen.appendChild(detailList);
          card.appendChild(resumen);

          if (hallazgo.siguienteFechaEsperada) {
            const proximo = document.createElement("div");
            proximo.className = "analysis-chip";
            proximo.textContent = `Pr√≥xima: ${hallazgo.siguienteFechaEsperada}`;
            card.appendChild(proximo);
          }

          if (Array.isArray(hallazgo.evidencia) && hallazgo.evidencia.length) {
            const evidBox = document.createElement("div");
            evidBox.className = "analysis-evidence";
            hallazgo.evidencia.slice(-6).forEach((item) => {
              const line = document.createElement("span");
              const numeroFmt = formatNumber(item.numero);
              const origenText = item.origen ? ` ‚Üê ${item.origen.fecha} ${item.origen.horario}` : "";
              let text = `${item.fecha} ${item.horario} ¬∑ ${numeroFmt}${origenText}`;
              if (item.hipotesis?.length) {
                const hipos = item.hipotesis
                  .map((h) => (h.texto ? h.texto.trim() : `Hip√≥tesis #${h.id}`))
                  .filter(Boolean)
                  .slice(0, 2)
                  .join(" ¬∑ ");
                if (hipos) text += ` ¬∑ ${hipos}`;
                if (item.hipotesis.length > 2) text += " ‚Ä¶";
              }
              line.textContent = text;
              evidBox.appendChild(line);
            });
            card.appendChild(evidBox);
          }

          grid.appendChild(card);
        });
      }

      if (patrones?.repeticionesHistoricas?.length) {
        const historicos = patrones.repeticionesHistoricas.slice(0, 5);
        const card = document.createElement("div");
        card.className = "analysis-card history accent-soft";
        const head = document.createElement("div");
        head.className = "card-head";
        head.textContent = "Repeticiones hist√≥ricas";
        card.appendChild(head);

        const list = document.createElement("div");
        list.className = "history-repeat-list";

        historicos.forEach((item) => {
          const block = document.createElement("div");
          block.className = "history-repeat-item";

          const headerRow = document.createElement("div");
          headerRow.className = "history-repeat-header";

          const numEl = document.createElement("div");
          numEl.className = "analysis-number history-repeat-number";
          const formatted = formatNumber(item.numero);
          const symbol = item.simbolo || getSymbol(item.numero);
          const symbolSpan = symbol
            ? `<span class="analysis-number-symbol analysis-number-symbol--sm">${symbol}</span>`
            : "";
          numEl.innerHTML = `<span class="analysis-number-main">${formatted}</span>${symbolSpan}`;
          headerRow.appendChild(numEl);

          const countEl = document.createElement("div");
          countEl.className = "history-repeat-count";
          const ratioPct = Number.isFinite(item.ratio) ? Math.round(item.ratio * 100) : null;
          countEl.textContent = ratioPct !== null
            ? `${item.totalEventos} repeticiones (${ratioPct}% hist√≥rico)`
            : `${item.totalEventos} repeticiones`;
          headerRow.appendChild(countEl);

          block.appendChild(headerRow);

          const metaLine = document.createElement("div");
          metaLine.className = "history-repeat-meta";
          const familiaTag = item.familia ? ` ¬∑ Familia ${item.familia}` : "";
          metaLine.textContent = `${item.totalApariciones} apariciones registradas${familiaTag}`;
          block.appendChild(metaLine);

          if (item.years?.length) {
            const yearsLine = document.createElement("div");
            yearsLine.className = "history-repeat-meta history-repeat-meta--years";
            yearsLine.textContent = item.years
              .slice(0, 4)
              .map((y) => `${y.year}: ${y.count}`)
              .join(" ¬∑ ");
            block.appendChild(yearsLine);
          }

          const events = document.createElement("ul");
          events.className = "history-repeat-events";
          const muestras = item.eventos.slice(-4).reverse();
          muestras.forEach((ev) => {
            const li = document.createElement("li");
            const origen = document.createElement("span");
            origen.className = "history-repeat-event history-repeat-event--origin";
            origen.textContent = `${ev.origenFecha} ${ev.origenHorario || ""}`.trim();
            const arrow = document.createElement("span");
            arrow.className = "history-repeat-arrow";
            arrow.textContent = "‚Üí";
            const destino = document.createElement("span");
            destino.className = "history-repeat-event history-repeat-event--dest";
            destino.textContent = `${ev.destinoFecha} ${ev.destinoHorario || ""}`.trim();
            const tipo = document.createElement("span");
            tipo.className = "history-repeat-type";
            tipo.textContent = ev.tipo || "";
            li.append(origen, arrow, destino, tipo);
            events.appendChild(li);
          });
          block.appendChild(events);

          list.appendChild(block);
        });

        card.appendChild(list);
        grid.appendChild(card);
      }

      if (predicciones?.length) {
        const card = document.createElement("div");
        card.className = "analysis-card forecast";

        const header = document.createElement("div");
        header.className = "card-head";
        header.textContent = "Predicci√≥n aprendida";
        card.appendChild(header);

        if (totalDraws) {
          const meta = document.createElement("div");
          meta.className = "analysis-note";
          meta.textContent = `Aprendido de ${totalDraws} sorteos reales`;
          card.appendChild(meta);
        }

        const list = document.createElement("div");
        list.className = "analysis-forecast";

        predicciones.forEach((item) => {
          const perfil = perfilMap.get(item.numero);
          const row = document.createElement("div");
          row.className = "analysis-forecast-item";
          const headerRow = document.createElement("div");
          headerRow.className = "analysis-forecast-header";

          const numEl = document.createElement("div");
          numEl.className = "analysis-number";
          const formatted = formatNumber(item.numero);
          const symbol = getSymbol(item.numero);
          const symbolSpan = symbol
            ? `<span class="analysis-number-symbol analysis-number-symbol--sm">${symbol}</span>`
            : "";
          numEl.innerHTML = `<span class="analysis-number-main">${formatted}</span>${symbolSpan}`;

          const scoreEl = document.createElement("div");
          scoreEl.className = "analysis-score";
          scoreEl.innerHTML = `<strong>${Math.round(item.score * 100)}%</strong><span>score</span>`;

          headerRow.appendChild(numEl);
          headerRow.appendChild(scoreEl);

          const metrics = document.createElement("div");
          metrics.className = "analysis-forecast-metrics";
          metrics.innerHTML = `
            <span>Freq ${(item.frecuencia * 100).toFixed(1)}%</span>
            <span>Rec ${(item.recencia * 100).toFixed(1)}%</span>
            <span>Hip ${(item.hipotesis * 100).toFixed(1)}%</span>
            <span>Ctx ${(item.contexto * 100).toFixed(1)}%</span>
          `;

          row.appendChild(headerRow);
          row.appendChild(metrics);

          if (item.modos?.length) {
            const modes = document.createElement("div");
            modes.className = "analysis-forecast-context";
            const summary = item.modos
              .slice(0, 2)
              .map((m) => {
                const conf = Math.round((m.confianza || 0) * 100);
                const nombre = m.modeNombre || "Modo";
                const opLabel = OPERACION_LABELS[m.operacion];
                const opTag = opLabel ? ` ¬∑ ${opLabel}` : "";
                const confTag = conf ? ` ¬∑ ${conf}%` : "";
                return `${nombre}${opTag}${confTag}`;
              })
              .join(" | ");
            modes.textContent = summary;
            row.appendChild(modes);
          }

          if (perfil) {
            const desc = describirPerfil(perfil);
            if (desc) row.title = desc;

            const contextDetail = document.createElement("div");
            contextDetail.className = "analysis-forecast-context";

            const bestContext = (() => {
              const evaluators = [];
              const pickBest = (records, formatter) => {
                let best = null;
                Object.entries(records || {}).forEach(([key, stats]) => {
                  if (!stats.total) return;
                  const rate = stats.aciertos / stats.total;
                  if (!best || rate > best.rate) {
                    best = { rate, label: formatter(key, stats) };
                  }
                });
                if (best) evaluators.push(best);
              };

              pickBest(perfil.aprendizaje?.porPais, (key, stats) => `${key} ${Math.round((stats.aciertos / stats.total) * 100)}%`);
              pickBest(perfil.aprendizaje?.porHorario, (key, stats) => `${key} ${Math.round((stats.aciertos / stats.total) * 100)}%`);
              pickBest(perfil.aprendizaje?.porDiaSemana, (key, stats) => `${["Dom", "Lun", "Mar", "Mi√©", "Jue", "Vie", "S√°b"][key]} ${Math.round((stats.aciertos / stats.total) * 100)}%`);

              if (!evaluators.length) return null;
              evaluators.sort((a, b) => b.rate - a.rate);
              return evaluators[0];
            })();

            if (bestContext) {
              contextDetail.textContent = `Contexto destacado: ${bestContext.label}`;
              row.appendChild(contextDetail);
            }
          }

          list.appendChild(row);
        });

        card.appendChild(list);
        grid.appendChild(card);

        if (perfilMap.size) {
          const detail = document.createElement("div");
          detail.className = "analysis-card detail";
          const h = document.createElement("div");
          h.className = "card-head";
          h.textContent = "Perfiles destacados";
          detail.appendChild(h);

          const detailList = document.createElement("div");
          detailList.className = "analysis-detail-list";

          predicciones.slice(0, 3).forEach((item) => {
            const perfil = perfilMap.get(item.numero);
            if (!perfil) return;

            const block = document.createElement("div");
            block.className = "analysis-detail-item";

            const headerRow = document.createElement("div");
            headerRow.className = "analysis-detail-header";
            headerRow.innerHTML = `
              <span class="analysis-number">${formatNumber(item.numero)}</span>
              <span class="analysis-detail-score">${Math.round(item.score * 100)}%</span>
            `;

            const desc = document.createElement("div");
            desc.className = "analysis-detail-body";
            desc.textContent = describirPerfil(perfil) || "Sin historial suficiente.";

            const hypoSummary = document.createElement("div");
            hypoSummary.className = "analysis-detail-foot";
            const totalHyp = perfil.aprendizaje?.total || 0;
            if (totalHyp) {
              hypoSummary.textContent = `Hip√≥tesis: ${perfil.aprendizaje.aciertos}/${totalHyp} aciertos (${Math.round(
                (perfil.scoreHipotesis || 0) * 100
              )}%)`;
            } else if (perfil.hipotesis?.pendientes) {
              hypoSummary.textContent = `${perfil.hipotesis.pendientes} hip√≥tesis pendientes.`;
            } else {
              hypoSummary.textContent = "Sin hip√≥tesis registradas.";
            }

            block.appendChild(headerRow);
            block.appendChild(desc);
            block.appendChild(hypoSummary);
            detailList.appendChild(block);
          });

          detail.appendChild(detailList);
          grid.appendChild(detail);
        }
      }

      if (insights?.length) {
        const insightCard = document.createElement("div");
        insightCard.className = "analysis-card insight";
        insightCard.innerHTML = `<div class="card-head">Insights aprendidos</div>`;
        const list = document.createElement("ul");
        list.className = "analysis-insights";
        insights.slice(0, 6).forEach((item) => {
          const li = document.createElement("li");
          li.innerHTML = `<strong>${item.titulo}:</strong> ${item.descripcion}`;
          list.appendChild(li);
        });
        insightCard.appendChild(list);
        grid.appendChild(insightCard);
      }

      if (!escenarios.length) {
        const empty = document.createElement("p");
        empty.className = "hint";
        empty.textContent = "No hay escenarios disponibles. Registra sorteos para obtener proyecciones.";
        resultEscenarios.appendChild(empty);
        return;
      }

      escenarios.forEach((esc) => {
        const card = document.createElement("div");
        card.className = "analysis-card scenario";
        const conf = Math.round((esc.confianza || 0) * 100);

        const header = document.createElement("div");
        header.className = "card-head";
        header.textContent = `${esc.nombre || "Escenario"} ‚Äî conf ${conf}%`;
        card.appendChild(header);

        const lista = document.createElement("div");
        lista.className = "analysis-pill-wrap";
        for (const cand of esc.candidatos || []) {
          const pill = document.createElement("div");
          pill.className = "analysis-pill";
          pill.style.borderColor = getColorPolaridad(cand.numero);
          pill.textContent = `${formatNumber(cand.numero)} ${cand.simbolo || getSymbol(cand.numero) || ""}`.trim();
          const etiqueta = cand.etiqueta || (cand.razones?.length ? cand.razones[0] : "");
          if (etiqueta) {
            const chip = document.createElement("span");
            chip.className = "analysis-chip";
            chip.textContent = etiqueta;
            pill.appendChild(chip);
          }
          pill.title = (cand.razones || []).join(" ¬∑ ") || "";
          lista.appendChild(pill);
        }
        card.appendChild(lista);

        if (esc.explicacion) {
          const hint = document.createElement("div");
          hint.className = "analysis-note";
          hint.textContent = esc.explicacion;
          card.appendChild(hint);
        }

        grid.appendChild(card);
      });
    }

    function renderRecomendaciones(
      recomendacion,
      nota,
      predicciones = [],
      perfilMap = new Map(),
      resumenPred = null
    ) {
      if (!resultRecomendacion) return;
      resultRecomendacion.innerHTML = "";
      if (!recomendacion.length) {
        resultRecomendacion.innerHTML = "<p class='hint'>Sin recomendaciones por el momento.</p>";
      } else {
        const card = document.createElement("div");
        card.className = "analysis-card recommendation";

        const header = document.createElement("div");
        header.className = "card-head";
        header.textContent = "Recomendaci√≥n consolidada";
        card.appendChild(header);

        const lista = document.createElement("div");
        lista.className = "analysis-pill-wrap";
        for (const cand of recomendacion) {
          const pill = document.createElement("div");
          pill.className = "analysis-pill";
          pill.style.borderColor = getColorPolaridad(cand.numero);
          pill.textContent = `${formatNumber(cand.numero)} ${cand.simbolo || getSymbol(cand.numero) || ""}`.trim();
          pill.title = (cand.razones || []).join(" ¬∑ ") || "";
          lista.appendChild(pill);
        }
        card.appendChild(lista);

        if (nota) {
          const hint = document.createElement("div");
          hint.className = "analysis-note";
          hint.textContent = nota;
          card.appendChild(hint);
        }

        resultRecomendacion.appendChild(card);
      }

      if (resumenPred && resumenPred.total) {
        const perf = document.createElement("div");
        perf.className = "analysis-card performance";
        const overall = resumenPred.precision !== null
          ? `${Math.round(resumenPred.precision * 100)}% acierto (${resumenPred.aciertos}/${resumenPred.total})`
          : `${resumenPred.aciertos}/${resumenPred.total} aciertos`;
        perf.innerHTML = `
          <div class="card-head">Precisi√≥n hist√≥rica</div>
          <div class="analysis-note">${overall}</div>
        `;
        if (resumenPred.turnos?.length) {
          const table = document.createElement("div");
          table.className = "analysis-performance-turnos";
          resumenPred.turnos.forEach((turno) => {
            const row = document.createElement("div");
            row.className = "analysis-performance-row";
            const label = document.createElement("span");
            label.textContent = turno.turno;
            const value = document.createElement("span");
            const prec = turno.precision !== null ? `${Math.round(turno.precision * 100)}%` : "‚Äî";
            value.textContent = `${prec} (${turno.aciertos}/${turno.total})`;
            row.appendChild(label);
            row.appendChild(value);
            table.appendChild(row);
          });
          perf.appendChild(table);
        }
        resultRecomendacion.appendChild(perf);
      }
    }

    async function jumpToDayView(fecha, pais) {
      if (!fecha) return;
      if (dayFecha) {
        dayFecha.value = fecha;
        updateDayFechaDow(fecha);
      }
      if (pais && dayPais) dayPais.value = pais;
      const dayBtn = Array.from(sidebarButtons || []).find((btn) => btn.dataset.view === "day");
      dayBtn?.click();
      await refreshSlots();
      await refreshHistoryPanel({ forceReload: true });
      await renderTrackingPanel({ forceReload: true });
    }

    const MEMORY_RELATION_LABELS = {
      mismo: "Directo",
      invertido: "Invertido",
      "100-n": "Ajuste (100‚àín)",
      vecino: "Ajuste ¬±1",
      "mapa simple": "Mapa simple",
      "mapa compuesta": "Mapa compuesta",
    };
    const MEMORY_RELATION_VALUES = {
      mismo: (profile) => [profile.base],
      invertido: (profile) => (profile.ctx?.mirror !== null ? [profile.ctx.mirror] : []),
      "100-n": (profile) => (profile.ctx?.adjust !== null ? [profile.ctx.adjust] : []),
      vecino: (profile) => profile.ctx?.neighbors ?? [],
      "mapa simple": (profile) => profile.ctx?.simpleConversions ?? [],
      "mapa compuesta": (profile) => profile.ctx?.compositeConversions ?? [],
    };

    const formatDaysGap = (value) => {
      if (value === null || typeof value === "undefined") return "‚Äî";
      const abs = Math.abs(value);
      if (abs < 0.5) return "<1 d√≠a";
      if (abs < 2) return `${abs.toFixed(1)} d√≠as`;
      return `${Math.round(abs)} d√≠as`;
    };
    const formatGapText = (value) => formatDaysGap(value);

    const relativeDaysLabel = (value) => {
      if (value === null || typeof value === "undefined") return "Nunca";
      if (value < 0.5) return "Hoy";
      if (value < 1.5) return "Ayer";
      if (value < 7) return `Hace ${Math.round(value)} d√≠as`;
      if (value < 30) return `Hace ${Math.round(value)} d√≠as`;
      const months = Math.round(value / 30);
      if (months < 12) return `Hace ${months} mes${months === 1 ? "" : "es"}`;
      const years = Math.round(months / 12);
      return `Hace ${years} a√±o${years === 1 ? "" : "s"}`;
    };

    const formatShortSpan = (value) => {
      if (!Number.isFinite(value)) return "‚Äî";
      const abs = Math.abs(value);
      if (abs >= 1) return `${Math.round(abs)} d`;
      const hours = abs * 24;
      if (hours >= 1) return `${Math.round(hours)} h`;
      const minutes = Math.max(1, Math.round(hours * 60));
      return `${minutes} m`;
    };

    const getGapState = (avg, current) => {
      if (!Number.isFinite(avg) || !Number.isFinite(current) || avg <= 0) {
        return { status: "unknown", remaining: null, diff: Infinity };
      }
      const remaining = avg - current;
      const diffAbs = Math.abs(remaining);
      if (diffAbs <= 2) {
        return { status: "window", remaining, diff: diffAbs };
      }
      if (remaining > 2) {
        return { status: "waiting", remaining, diff: diffAbs };
      }
      return { status: "overdue", remaining, diff: diffAbs };
    };

    function updateGapCard(card, nowMs = Date.now()) {
      if (!card) return;
      const valueEl = card.querySelector("[data-gap-value]");
      const metaEl = card.querySelector("[data-gap-meta]");
      const avgAttr = card.dataset.avgGap;
      const lastAttr = card.dataset.lastTs;
      const avgGap = avgAttr ? Number(avgAttr) : null;
      const lastTs = lastAttr ? Number(lastAttr) : null;
      const currentDays =
        Number.isFinite(lastTs) && lastTs > 0 ? (nowMs - lastTs) / DAY_MS : null;
      const state = getGapState(avgGap, currentDays);
      card.dataset.status = state.status;

      const countdownLabel = (() => {
        if (state.status === "unknown") return "Sin historial";
        if (!Number.isFinite(avgGap) || !Number.isFinite(currentDays)) return "‚Äî";
        const remaining = avgGap - currentDays;
        if (remaining >= 0) {
          if (remaining >= 1) return `${Math.round(remaining)} d√≠a(s) restantes`;
          return `${Math.round(remaining * 24)} hora(s) restantes`;
        }
        const overdue = Math.abs(remaining);
        if (overdue >= 1) return `Atrasado ${Math.round(overdue)} d√≠a(s)`;
        return `Atrasado ${Math.round(overdue * 24)} hora(s)`;
      })();

      const formattedValue = (() => {
        if (state.status === "unknown") return "Sin historial";
        if (state.status === "window") {
          const delta = formatShortSpan(state.remaining);
          return `En ventana (${state.remaining >= 0 ? "‚àí" : "+"}${delta})`;
        }
        if (state.status === "waiting") {
          return `Faltan ${formatShortSpan(state.remaining)}`;
        }
        return `Atrasado ${formatShortSpan(Math.abs(state.remaining))}`;
      })();
      const formattedMeta = (() => {
        const current = Number.isFinite(currentDays) ? formatShortSpan(currentDays) : "‚Äî";
        const avg = Number.isFinite(avgGap) ? formatShortSpan(avgGap) : "‚Äî";
        const lastTxt = card.dataset.lastLabel || "";
        return `Actual: ${current} ¬∑ Prom: ${avg}${lastTxt ? ` ¬∑ √ölt: ${lastTxt}` : ""}`;
      })();
      if (valueEl) valueEl.textContent = formattedValue;
      if (metaEl) metaEl.textContent = formattedMeta;
      const countdownEl = card.querySelector("[data-gap-countdown]");
      if (countdownEl) countdownEl.textContent = countdownLabel;
    }

    function updateGapCardsTime() {
      if (!memoryGapGrid) return;
      const now = Date.now();
      memoryGapGrid.querySelectorAll("[data-gap-card='true']").forEach((card) => {
        updateGapCard(card, now);
      });
    }

    function scheduleGapTimer() {
      if (memoryGapTimer) clearInterval(memoryGapTimer);
      if (!memoryGapGrid) return;
      if (!memoryGapGrid.querySelector("[data-gap-card='true']")) return;
      memoryGapTimer = setInterval(updateGapCardsTime, 60 * 1000);
    }

    function highlightMemoryNode(numero) {
      if (!memoryBoardGrid) return;
      memoryBoardGrid.querySelectorAll(".memory-node").forEach((node) => {
        const nodeNum = parseInt(node.dataset.numero, 10);
        node.classList.toggle("active", Number.isFinite(numero) && nodeNum === numero);
      });
    }

    function renderMemoryDetailEmpty(message) {
      if (!memoryDetail) return;
      memoryDetail.innerHTML = `<p class="hint">${message}</p>`;
    }

    function buildRelationCards(profile, limitValues = 4) {
      const cards = [];
      Object.entries(MEMORY_RELATION_LABELS).forEach(([key, label]) => {
        const count = profile.relationCounts[key] || 0;
        if (!count) return;
        const resolver = MEMORY_RELATION_VALUES[key];
        const values = resolver ? resolver(profile) : [profile.base];
        const uniqueValues = Array.from(new Set(values.filter((val) => Number.isFinite(val))));
        cards.push({
          key,
          label,
          count,
          values: uniqueValues.slice(0, limitValues),
          extraValues: uniqueValues.length > limitValues ? uniqueValues.length - limitValues : 0,
        });
      });
      return cards;
    }

function buildVariantEntries(profile) {
      const variants = [];
      const ctx = profile.ctx;
      if (!ctx) return variants;
      const pushVariant = (key, label, value, extra = "") => {
        if (value === null || typeof value === "undefined") return;
        const variantKey = `${key}-${value}`;
        variants.push({
          key,
          label,
          value,
          extra,
          last: profile.variantStats[variantKey] || null,
        });
      };
      pushVariant("invertido", "Invertido", ctx.mirror);
      pushVariant("100-n", "100 ‚àí n", ctx.adjust);
      ctx.neighbors.forEach((value) => {
        const delta = ((value - ctx.base + 100) % 100) === 1 ? "+1" : "-1";
        pushVariant("vecino", `Ajuste ${delta}`, value, delta);
      });
      ctx.simpleConversions.forEach((value) => pushVariant("mapa simple", "Mapa simple", value));
      ctx.compositeConversions.forEach((value) =>
        pushVariant("mapa compuesta", "Mapa compuesta", value)
      );
      return variants;
}

    async function renderGapPanel({ forceReload = false } = {}) {
      if (!memoryGapGrid) return;
      memoryGapGrid.innerHTML = "<p class='hint'>Calculando huecos‚Ä¶</p>";
      if (memoryGapTimer) {
        clearInterval(memoryGapTimer);
        memoryGapTimer = null;
      }
      try {
        const draws = await getMemoryDraws({ force: forceReload });
        const summary = construirGapSummary(draws, { referenceDate: new Date() });
        memoryGapData = summary;
        const sorted = summary
          .slice()
          .sort((a, b) => {
            const stateA = getGapState(a.avgGap, a.currentGap);
            const stateB = getGapState(b.avgGap, b.currentGap);
            const priority = { window: 0, waiting: 1, overdue: 2, unknown: 3 };
            const diffPriority =
              (priority[stateA.status] ?? 3) - (priority[stateB.status] ?? 3);
            if (diffPriority !== 0) return diffPriority;
            return (stateA.diff ?? Infinity) - (stateB.diff ?? Infinity);
          });

        const hasHistory = summary.some((entry) => entry.count > 0);
        if (!hasHistory) {
          memoryGapGrid.innerHTML =
            "<p class='hint'>A√∫n no hay suficientes registros para calcular huecos.</p>";
          return;
        }
        const fragment = document.createDocumentFragment();
        sorted.forEach((entry) => {
          const card = document.createElement("button");
          card.type = "button";
          card.className = "memory-gap-card";
          card.dataset.gapCard = "true";
          card.dataset.numero = entry.numero;
          if (Number.isFinite(entry.avgGap)) card.dataset.avgGap = String(entry.avgGap);
          else card.dataset.avgGap = "";
          if (Number.isFinite(entry.lastTimestamp))
            card.dataset.lastTs = String(entry.lastTimestamp);
          else card.dataset.lastTs = "";
          const state = getGapState(entry.avgGap, entry.currentGap);
          card.dataset.status = state.status;
          if (entry.lastFecha) {
            const lastLabel = `${formatFriendlyDate(entry.lastFecha)}${
              entry.lastHorario ? ` ${entry.lastHorario}` : ""
            }`.trim();
            card.dataset.lastLabel = lastLabel;
          } else {
            card.dataset.lastLabel = "";
          }
          const rawSymbol = getSymbol(entry.numero);
          const symbol = rawSymbol && rawSymbol.trim().length ? rawSymbol : "Sin s√≠mbolo";
          card.innerHTML = `
            <div class="memory-gap-card__head">
              <div class="memory-gap-card__identity">
                <span class="memory-gap-card__number">${formatNumber(entry.numero)}</span>
                <span class="memory-gap-card__symbol">${symbol}</span>
              </div>
              <div class="memory-gap-card__stats">
                <span class="memory-gap-card__label">Apariciones</span>
                <span class="memory-gap-card__count">${entry.count || 0}</span>
              </div>
            </div>
            <div class="memory-gap-card__value" data-gap-value>‚Äî</div>
            <div class="memory-gap-card__countdown" data-gap-countdown>‚Äî</div>
            <div class="memory-gap-card__meta" data-gap-meta>Actual: ‚Äî ¬∑ Promedio: ‚Äî</div>
          `;
          card.addEventListener("click", () => openMemoryDetail(entry.numero));
          fragment.appendChild(card);
        });
        memoryGapGrid.innerHTML = "";
        memoryGapGrid.appendChild(fragment);
        updateGapCardsTime();
        scheduleGapTimer();
      } catch (err) {
        console.error("memory gap error", err);
        memoryGapGrid.innerHTML = "<p class='hint'>No se pudo generar el monitor de huecos.</p>";
      }
    }

    function renderMemoryDetail(profile) {
      if (!memoryDetail) return;
      if (!profile || profile.base === null) {
        renderMemoryDetailEmpty("Selecciona un n√∫mero v√°lido.");
        return;
      }
      if (!profile.timeline.length) {
        renderMemoryDetailEmpty("A√∫n no hay registros para este n√∫mero.");
        return;
      }
      const symbol = getSymbol(profile.base);
      const last = profile.timeline[profile.timeline.length - 1];
      const variants = buildVariantEntries(profile);
      const relationCards = buildRelationCards(profile);
      const gapAverage = formatDaysGap(profile.gaps.average);
      const gapMax = formatDaysGap(profile.gaps.max);
      const gapCurrent = formatDaysGap(profile.gaps.current);
      const turnItems = Object.entries(profile.turnStats)
        .map(([turno, stats]) => ({
          turno,
          order: HORARIO_ORDER[turno] ?? 99,
          count: stats.count || 0,
          lastFecha: stats.lastFecha || null,
          lastPais: stats.lastPais || "",
        }))
        .sort((a, b) => a.order - b.order);
      const recentTimeline = profile.timeline.slice(-8).reverse();

      memoryDetail.innerHTML = `
        <div class="memory-detail__header">
          <div>
            <div class="memory-detail__number">${formatNumber(profile.base)}</div>
            <div class="memory-detail__symbol">${symbol || "Sin s√≠mbolo registrado"}</div>
          </div>
          <div class="memory-tag">√öltima vez: ${last ? formatFriendlyDate(last.fecha) : "‚Äî"}</div>
        </div>
        <div class="memory-stats">
          <div class="memory-stat">
            <strong>${profile.totals.total}</strong>
            <span>Apariciones</span>
          </div>
          <div class="memory-stat">
            <strong>${profile.totals.direct}</strong>
            <span>Directos</span>
          </div>
          <div class="memory-stat">
            <strong>${profile.totals.transforms}</strong>
            <span>Transformaciones</span>
          </div>
          <div class="memory-stat">
            <strong>${gapAverage}</strong>
            <span>Promedio</span>
          </div>
        </div>
        <div class="memory-stats">
          <div class="memory-stat">
            <strong>${gapMax}</strong>
            <span>Hueco m√°ximo</span>
          </div>
          <div class="memory-stat">
            <strong>${gapCurrent}</strong>
            <span>Hueco actual</span>
          </div>
        </div>
        <div>
          <h4>Transformaciones activas</h4>
          <div class="memory-transform-grid">
            ${
              relationCards.length
                ? relationCards
                    .map(
                      (card) => `<div class="memory-transform-card">
                        <div class="memory-transform-count">${card.count}</div>
                        <div class="memory-transform-label">${card.label}</div>
                        <div class="memory-transform-values">
                          ${
                            card.values
                              .map(
                                (value) =>
                                  `<span class="memory-transform-chip">${formatNumber(value)}</span>`
                              )
                              .join("")
                          }
                          ${
                            card.extraValues
                              ? `<span class="memory-transform-chip">+${card.extraValues}</span>`
                              : ""
                          }
                        </div>
                      </div>`
                    )
                    .join("")
                : "<p class='hint'>A√∫n no hay conversiones registradas.</p>"
            }
          </div>
        </div>
        <div>
          <h4>Variantes rastreadas</h4>
          <div class="memory-variant-grid">
            ${
              variants.length
                ? variants
                    .map((variant) => {
                      const lastSeen = variant.last
                        ? `${formatFriendlyDate(variant.last.fecha)} ¬∑ ${variant.last.horario || "‚Äî"}`
                        : "Sin registro";
                      return `<div class="memory-variant-card">
                        <strong>${formatNumber(variant.value)}</strong>
                        <div>${variant.label}</div>
                        <small>${lastSeen}</small>
                      </div>`;
                    })
                    .join("")
                : "<p class='hint'>No hay variantes configuradas para este n√∫mero.</p>"
            }
          </div>
        </div>
        <div>
          <h4>Actividad por turno</h4>
          <div class="memory-turns">
            ${
              turnItems.length
                ? turnItems
                    .map(
                      (item) => `<div class="memory-turn">
                        <strong>${item.turno}</strong>
                        <div>${item.count} registro(s)</div>
                        <small>${item.lastFecha ? formatFriendlyDate(item.lastFecha) : "‚Äî"}</small>
                      </div>`
                    )
                    .join("")
                : "<p class='hint'>Sin datos por turno.</p>"
            }
          </div>
        </div>
        <div>
          <h4>L√≠nea temporal</h4>
          <div class="memory-timeline" id="memory-timeline-list"></div>
        </div>
      `;
      const timelineContainer = memoryDetail.querySelector("#memory-timeline-list");
      if (timelineContainer) {
        if (!recentTimeline.length) {
          timelineContainer.innerHTML = "<p class='hint'>Sin registros a√∫n.</p>";
        } else {
          recentTimeline.forEach((entry) => {
            const relText = entry.relaciones
              .map((key) => MEMORY_RELATION_LABELS[key] || key)
              .join(" ¬∑ ");
            const meta = `${formatFriendlyDate(entry.fecha)} ¬∑ ${entry.horario || "‚Äî"} ¬∑ ${entry.pais || "‚Äî"}`;
            const gapText = entry.gapToNextDays !== null
              ? `Pr√≥x. aparici√≥n despu√©s de ${formatGapText(entry.gapToNextDays)}`
              : "√öltimo registro";
            const row = document.createElement("div");
            row.className = "memory-timeline-entry";
            row.innerHTML = `
              <div class="memory-timeline-head">
                <strong>${formatNumber(entry.numero)}</strong>
                <span class="memory-gap-badge">${gapText}</span>
              </div>
              <div>${relText || "‚Äî"}</div>
              <div class="memory-timeline-meta">${meta}</div>
            `;
            const actions = document.createElement("div");
            actions.className = "memory-timeline-actions";
            const jumpBtn = document.createElement("button");
            jumpBtn.type = "button";
            jumpBtn.className = "btn-ghost";
            jumpBtn.textContent = "Ver d√≠a";
            jumpBtn.addEventListener("click", () => {
              jumpToDayView(entry.fecha, entry.pais || dayPais?.value || "HN");
            });
            actions.appendChild(jumpBtn);
            row.appendChild(actions);
            timelineContainer.appendChild(row);
          });
        }
      }
    }

    async function openMemoryDetail(numero) {
      if (!Number.isFinite(numero)) return;
      memorySelectedNumero = numero;
      highlightMemoryNode(numero);
      if (memoryDetail) {
        memoryDetail.innerHTML = "<p class='hint'>Calculando expediente‚Ä¶</p>";
      }
      try {
        const draws = await getMemoryDraws();
        const profile = construirPerfilNumero(draws, numero, { referenceDate: new Date() });
        renderMemoryDetail(profile);
        memoryDetail?.scrollIntoView({ behavior: "smooth", block: "start" });
      } catch (err) {
        console.error("memory detail error", err);
        renderMemoryDetailEmpty("No se pudo cargar el perfil de este n√∫mero.");
      }
    }

    async function renderMemoryBoard({ forceReload = false } = {}) {
      if (!memoryBoardGrid) return;
      memoryBoardGrid.innerHTML = "<p class='hint'>Procesando historial‚Ä¶</p>";
      try {
        const draws = await getMemoryDraws({ force: forceReload });
        const summary = resumirActividadNumeros(draws, { referenceDate: new Date() });
        memorySummary = summary;
        const maxCount = summary.reduce((max, entry) => Math.max(max, entry.total), 0);
        if (!summary.length || maxCount === 0) {
          memoryBoardGrid.innerHTML =
            "<p class='hint'>A√∫n no hay sorteos registrados. Guarda resultados para activar esta vista.</p>";
          renderMemoryDetailEmpty("Selecciona un n√∫mero para ver su bit√°cora.");
          return;
        }
        const fragment = document.createDocumentFragment();
        summary.forEach((entry) => {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "memory-node";
          btn.dataset.numero = entry.numero;
          const ratio = maxCount ? entry.total / maxCount : 0;
          btn.style.setProperty("--memory-node-intensity", Math.min(1, ratio).toFixed(2));
          if (entry.numero === memorySelectedNumero) btn.classList.add("active");
          btn.innerHTML = `
            <span class="memory-node__number">${formatNumber(entry.numero)}</span>
            <span class="memory-node__count">${entry.total || "‚Äî"}</span>
            <span class="memory-node__meta">${relativeDaysLabel(entry.daysSinceLast)}</span>
          `;
          fragment.appendChild(btn);
        });
        memoryBoardGrid.innerHTML = "";
        memoryBoardGrid.appendChild(fragment);
      } catch (err) {
        console.error("memory board error", err);
        memoryBoardGrid.innerHTML = "<p class='hint'>No se pudo generar el mapa.</p>";
      }
    }

    memoryRefreshBtn?.addEventListener("click", async () => {
      await renderMemoryBoard({ forceReload: true });
      await renderGapPanel({ forceReload: true });
      if (Number.isFinite(memorySelectedNumero)) openMemoryDetail(memorySelectedNumero);
    });

    memoryGapRefreshBtn?.addEventListener("click", async () => {
      await renderGapPanel({ forceReload: true });
    });

    memoryBoardGrid?.addEventListener("click", (event) => {
      const target = event.target.closest(".memory-node");
      if (!target) return;
      const numero = parseInt(target.dataset.numero, 10);
      if (!Number.isFinite(numero)) return;
      openMemoryDetail(numero);
    });

    await renderMemoryBoard();
    await renderGapPanel();

    const toggleTech = document.getElementById("toggle-tech");
    const memOut = document.getElementById("mem-out");
    toggleTech?.addEventListener("click", async () => {
      if (!memOut) return;
      memOut.classList.toggle("hidden");
      if (!memOut.classList.contains("hidden")) {
        const draws = await DB.listDraws({ excludeTest: false });
        memOut.textContent = JSON.stringify(draws.slice(-50), null, 2);
      }
    });

    const btnTransform = document.getElementById("t-ver");
    btnTransform?.addEventListener("click", () => {
      const raw = document.getElementById("t-numero")?.value.trim() ?? "";
      const numero = parseInt(raw, 10);
      mostrarTransformaciones(numero);
    });

    const btnGeometria = document.getElementById("g-generar");
    btnGeometria?.addEventListener("click", async () => {
      const fecha = geometryDateInput?.value;
      const paisSeleccionado = geometryPaisSelect?.value || dayPais?.value || "HN";
      if (!fecha) {
        showToast("Selecciona una fecha para generar la cruceta/tri√°ngulo.", { variant: "warning" });
        return;
      }
      const cruceta = generarCruceta(fecha);
      renderCruceta(cruceta);
      const niveles = generarTrianguloInvertido(fecha);
      const contTri = document.getElementById("g-tri");
      if (contTri) dibujarTrianguloInvertido(contTri, niveles);
      await renderTurnoCruceta(fecha, paisSeleccionado);
    });

    function renderCruceta(data) {
      const cont = document.getElementById("g-cruceta");
      if (!cont) return;
      cont.innerHTML = `
        <div class="c-row">
          <div class="ball small">${formatNumber(data.norte)}</div>
        </div>
        <div class="c-row">
          <div class="ball small">${formatNumber(data.oeste)}</div>
          <div class="ball small">${formatNumber(data.centro)}</div>
          <div class="ball small">${formatNumber(data.este)}</div>
        </div>
        <div class="c-row">
          <div class="ball small">${formatNumber(data.sur)}</div>
        </div>
      `;
    }

    async function renderTurnoCruceta(fecha, pais) {
      const cont = document.getElementById("g-turnos");
      const candWrap = document.getElementById("g-turnos-cands");
      if (!cont || !candWrap) return;
      cont.innerHTML = "<p class='hint'>Calculando cruceta con los sorteos de 11 AM y 3 PM‚Ä¶</p>";
      candWrap.innerHTML = "";
      try {
        const draws = await getCachedDraws();
        const draw11 = pickDraw(draws, fecha, pais, "11AM");
        const draw3 = pickDraw(draws, fecha, pais, "3PM");
        if (!draw11 || !draw3) {
          cont.innerHTML = `<p class='hint'>Registra los sorteos reales de 11 AM y 3 PM para ${fecha} (${pais}).</p>`;
          return;
        }
        const cruceta = generarCrucetaTurnos(draw11.numero, draw3.numero);
        const formatNode = (value) => `${value}`;
        cont.innerHTML = `
          <div class="c-row">
            <div class="ball small">${formatNode(cruceta.north)}</div>
          </div>
          <div class="c-row">
            <div class="ball small">${formatNode(cruceta.west)}</div>
            <div class="ball small">${formatNode(cruceta.center)}</div>
            <div class="ball small">${formatNode(cruceta.east)}</div>
          </div>
          <div class="c-row">
            <div class="ball small">${formatNode(cruceta.south)}</div>
          </div>
          <p class="geom-note">11 AM: ${formatNumber(draw11.numero)} ¬∑ 3 PM: ${formatNumber(
            draw3.numero,
          )} ¬∑ ${pais}</p>
        `;
        if (cruceta.candidates.length) {
          candWrap.innerHTML = `
            <p class="geom-note">Candidatos sugeridos para las 9 PM</p>
            <div class="geom-candidate-chips">
              ${cruceta.candidates
                .map(
                  (num) =>
                    `<span class="geom-chip"><strong>${formatNumber(num)}</strong><small>${getSymbol(num) || ""}</small></span>`,
                )
                .join("")}
            </div>
            ${
              cruceta.candidateNotes?.length
                ? `<ul class="geom-steps">${cruceta.candidateNotes
                    .map((note) => `<li>${note.detail}</li>`)
                    .join("")}</ul>`
                : ""
            }
            ${
              cruceta.steps?.length
                ? `<details class="geom-steps-details"><summary>Ver operaciones</summary><ul class="geom-steps">${cruceta.steps
                    .map((step) => `<li><strong>${step.label}:</strong> ${step.expr} ‚áí ${step.result}</li>`)
                    .join("")}</ul></details>`
                : ""
            }
          `;
        } else {
          candWrap.innerHTML = "<p class='hint'>Sin candidatos suficientes con estos datos.</p>";
        }
      } catch (err) {
        console.error("cruceta turnos error", err);
        cont.innerHTML = `<p class='hint'>No se pudo calcular la cruceta de turnos: ${err.message}</p>`;
      }
    }

    const btnDup = document.getElementById("btn-list-dup");
    const btnMarkTestDup = document.getElementById("btn-marktest-dup");
    const btnDeleteDup = document.getElementById("btn-delete-dup");
    const dupOut = document.getElementById("dup-out");
    const btnFixDates = document.getElementById("btn-fix-dates");
    const fixDatesOut = document.getElementById("fix-dates-out");

    btnDup?.addEventListener("click", refreshDuplicados);

    btnMarkTestDup?.addEventListener("click", async () => {
      const ids = getSelectedDupIds();
      if (!ids.length) {
        showToast("Selecciona al menos un registro duplicado.", { variant: "warning" });
        return;
      }
      try {
        await marcarGrupoComoTest(ids);
        await refreshDuplicados();
        await refreshSlots();
        showToast("Marcados como prueba.", { variant: "success" });
        await rebuildKnowledge();
        await handleDrawsMutated();
      } catch (err) {
        console.error("mark dup error", err);
        showToast(`No se pudo marcar como prueba: ${err.message}`, { variant: "danger" });
      }
    });

    btnDeleteDup?.addEventListener("click", async () => {
      const ids = getSelectedDupIds();
      if (!ids.length) {
        showToast("Selecciona registros para eliminar.", { variant: "warning" });
        return;
      }
      const confirmar = await mostrarModal(
        "Eliminar registros",
        "¬øEliminar los registros seleccionados?",
        { okText: "Eliminar", cancelText: "Cancelar", okVariant: "danger" }
      );
      if (!confirmar) return;
      try {
        await borrarIds(ids);
        await refreshDuplicados();
        await refreshSlots();
        showToast("Registros eliminados.", { variant: "success" });
        await rebuildKnowledge();
        await handleDrawsMutated();
      } catch (err) {
        console.error("delete dup error", err);
        showToast(`No se pudieron eliminar los registros: ${err.message}`, { variant: "danger" });
      }
    });

    async function refreshDuplicados() {
      if (!dupOut) return;
      dupOut.innerHTML = "<p class='hint'>Buscando duplicados‚Ä¶</p>";
      try {
        const grupos = await revisarDuplicados();
        if (!grupos.length) {
          dupOut.innerHTML = "<p class='hint'>Sin duplicados detectados.</p>";
          return;
        }
        dupOut.innerHTML = "";
        grupos.forEach((group, idx) => {
          const box = document.createElement("div");
          box.className = "card";
          box.style.width = "100%";
          box.style.marginBottom = "10px";
          const head = document.createElement("div");
          head.className = "card-head";
          head.textContent = `Grupo #${idx + 1}`;
          const list = document.createElement("div");
          list.className = "card-body";
          list.style.flexDirection = "column";
          list.style.alignItems = "flex-start";
          group.forEach((reg) => {
            const label = document.createElement("label");
            label.className = "symbol-tag";
            label.innerHTML = `
              <input type="checkbox" value="${reg.id}" />
              <span>${formatNumber(reg.numero)}</span>
              <span>${reg.fecha} ${reg.horario} ${reg.pais}</span>
              <span class="hint">${reg.isTest ? "test" : "real"}</span>
            `;
            list.appendChild(label);
          });
          box.appendChild(head);
          box.appendChild(list);
          dupOut.appendChild(box);
        });
      } catch (err) {
        console.error("dup error", err);
        dupOut.innerHTML = `<p class='hint'>No se pudieron obtener duplicados: ${err.message}</p>`;
      }
    }

    function getSelectedDupIds() {
      if (!dupOut) return [];
      return Array.from(dupOut.querySelectorAll("input[type='checkbox']:checked"))
        .map((el) => parseInt(el.value, 10))
        .filter((n) => !Number.isNaN(n));
    }

    btnFixDates?.addEventListener("click", async () => {
      if (!fixDatesOut) return;
      btnFixDates.disabled = true;
      fixDatesOut.innerHTML = "<p class='hint'>Revisando registros‚Ä¶</p>";
      try {
        const cambios = await corregirFechasDesfasadas({ maxAheadDays: 1 });
        if (!cambios.length) {
          fixDatesOut.innerHTML = "<p class='hint'>No se detectaron sorteos adelantados.</p>";
          showToast("No se encontraron registros con desfase.", { variant: "info" });
          return;
        }
        const detailItems = cambios
          .map(
            (reg) =>
              `<li>${reg.before} ‚Üí ${reg.after} ‚Ä¢ ${reg.horario || ""} ${reg.pais || ""} #${formatNumber(reg.numero)}</li>`
          )
          .join("");
        fixDatesOut.innerHTML = `
          <p class='hint'>Se corrigieron ${cambios.length} registro(s) con desfase:</p>
          <ul class="analysis-note">${detailItems}</ul>
        `;
        await refreshSlots();
        await handleDrawsMutated();
        await rebuildKnowledge();
        showToast(`Listo: ${cambios.length} registro(s) corrigieron su fecha.`, { variant: "success" });
      } catch (err) {
        console.error("fix dates error", err);
        fixDatesOut.innerHTML = `<p class='hint'>No se pudo completar la correcci√≥n: ${err.message}</p>`;
        showToast(`Error al corregir fechas: ${err.message}`, { variant: "danger" });
      } finally {
        btnFixDates.disabled = false;
      }
    });

    // ‚úÖ Navegaci√≥n lateral
    const sidebar = document.getElementById("sidebar");
    const toggleBtn = document.getElementById("btn-toggle-sidebar");
    const logoutBtn = document.getElementById("btn-logout");

    async function cerrarSesion() {
      try {
        await supabaseLogout();
      } catch (err) {
        console.error("logout error", err);
      } finally {
        window.location.href = "./login.html";
      }
    }

    logoutBtn?.addEventListener("click", cerrarSesion);

    const closeSidebarMobile = () => {
      if (!sidebar) return;
      sidebar.classList.remove("show-mobile");
      if (toggleBtn) {
        toggleBtn.classList.remove("sidebar-open");
        toggleBtn.setAttribute("aria-expanded", "false");
      }
    };

    const openSidebarMobile = () => {
      if (!sidebar) return;
      sidebar.classList.add("show-mobile");
      if (toggleBtn) {
        toggleBtn.classList.add("sidebar-open");
        toggleBtn.setAttribute("aria-expanded", "true");
      }
    };

    // ‚úÖ Cambio de vistas
    const views = {
      day: "view-day",
      hypo: "view-hypo",
      analysis: "view-analysis",
      transform: "view-transform",
      strategies: "view-strategies",
      weekly: "view-weekly",
      abono: "view-abono",
      gatillo: "view-gatillo",
      pega3: "view-pega3",
      notebook: "view-notebook",
      geometry: "view-geometry",
      memory: "view-memory",
      guide: "view-guide",
      config: "view-config",
      maint: "view-maint",
      modes: "view-modes",
    };
    const sidebarButtons = document.querySelectorAll(".sidebar button");
    sidebarButtons.forEach((b) => {
      b.onclick = () => {
        if (b.dataset.view === "login") {
          window.location.href = "./login.html?mode=switch";
          return;
        }
        document.querySelectorAll(".view").forEach((v) => v.classList.add("hidden"));
        const id = views[b.dataset.view];
        const el = document.getElementById(id);
        if (!el) return logWarn("Vista no encontrada:", id);
        el.classList.remove("hidden");
        if (id === "view-guide") mostrarGuia();
        if (id === "view-hypo") refreshHypotesis();
        if (id === "view-maint") refreshDuplicados();
        if (id === "view-modes") refreshModesPanel();
        if (id === "view-strategies") renderStrategiesPanel();
        if (id === "view-weekly") {
          refreshWeeklyPanel({ force: true });
          refreshMonthlyPanel({ force: true });
          refreshMonthlyTrendsPanel({ force: true });
        }
        if (id === "view-gatillo") {
          runGatillo({ force: true });
        }
        if (id === "view-pega3") {
          syncPega3Context();
          refreshPega3Historial();
          renderPega3Panels();
        }
        if (id === "view-notebook") refreshNotebookList();
        if (id === "view-memory") {
          renderMemoryBoard();
          renderGapPanel();
        }
        if (window.innerWidth <= 768) closeSidebarMobile();
      };
    });

    // ‚úÖ Toggle de sidebar m√≥vil
    if (toggleBtn && sidebar) {
      toggleBtn.setAttribute("aria-controls", "sidebar");
      toggleBtn.setAttribute("aria-expanded", "false");
      if (window.innerWidth > 768 && !document.body.classList.contains("sidebar-collapsed")) {
        toggleBtn.classList.add("sidebar-open");
        toggleBtn.setAttribute("aria-expanded", "true");
      }

      toggleBtn.addEventListener("click", (event) => {
        event.stopPropagation();
        if (window.innerWidth <= 768) {
          const shouldOpen = !sidebar.classList.contains("show-mobile");
          if (shouldOpen) {
            openSidebarMobile();
          } else {
            closeSidebarMobile();
          }
        } else {
          const collapsed = document.body.classList.toggle("sidebar-collapsed");
          const expanded = !collapsed;
          toggleBtn.classList.toggle("sidebar-open", expanded);
          toggleBtn.setAttribute("aria-expanded", expanded ? "true" : "false");
        }
      });

      const handleOutside = (event) => {
        if (!sidebar.classList.contains("show-mobile")) return;
        if (sidebar.contains(event.target)) return;
        if (toggleBtn.contains(event.target)) return;
        closeSidebarMobile();
      };

      const outsideEvents = window.PointerEvent
        ? ["pointerdown"]
        : ["mousedown", "touchstart"];
      outsideEvents.forEach((evt) => {
        document.addEventListener(evt, handleOutside);
      });
      document.addEventListener("click", handleOutside);
      document.addEventListener("focusin", handleOutside);
      window.addEventListener("keydown", (event) => {
        if (event.key === "Escape") closeSidebarMobile();
      });
      sidebar.addEventListener("focusout", (event) => {
        if (!sidebar.contains(event.relatedTarget)) closeSidebarMobile();
      });
      window.addEventListener("resize", () => {
        if (window.innerWidth > 768) {
          sidebar.classList.remove("show-mobile");
          const collapsed = document.body.classList.contains("sidebar-collapsed");
          toggleBtn.classList.toggle("sidebar-open", !collapsed);
          toggleBtn.setAttribute("aria-expanded", collapsed ? "false" : "true");
        } else {
          toggleBtn.classList.remove("sidebar-open");
          toggleBtn.setAttribute("aria-expanded", sidebar.classList.contains("show-mobile") ? "true" : "false");
        }
      });
    }

    try {
      await refreshHypotesis();
      await refreshSlots();
      await rebuildKnowledge();
      await refreshModesPanel();
    } catch (err) {
      console.error("initial load error", err);
      showToast("La app no pudo cargar completamente. Revisa la consola para m√°s detalles.", { variant: "danger" });
    } finally {
      hideSavingModal();
      await waitForFirstPaint();
      hideBootLoader();
    }

    // === Migraci√≥n Dexie ‚Üí Supabase (solo interfaz) ===
    const dexieMigrationBtn = document.getElementById("btn-migrar-dexie");
    const dexieModal = document.getElementById("dexie-supabase-modal");
    const dexieList = document.getElementById("dexie-migration-list");
    const dexieErrors = document.getElementById("dexie-migration-errors");
    const dexieErrorsList = dexieErrors?.querySelector("ul");
    const dexieSummary = document.getElementById("dexie-migration-summary");
    const dexieCloseBtn = document.getElementById("dexie-migration-close");
    const dexieStatusChip = document.getElementById("dexie-migration-status");
    const dexieTables = [
      "draws",
      "hypotheses",
      "reasons",
      "rules",
      "edges",
      "knowledge",
      "hypothesis_logs",
      "prediction_logs",
      "game_modes",
      "game_mode_examples",
      "game_mode_logs",
      "hypothesis_reminders",
      "notebook_entries",
      "pega3",
    ];
    let dexieMigrationRunning = false;
    const dexieTableState = new Map();

    const setDexieState = (table, patch = {}) => {
      const current = dexieTableState.get(table) || {};
      dexieTableState.set(table, { ...current, ...patch });
      const row = dexieList?.querySelector(`[data-table="${table}"]`);
      if (!row) return;
      const meta = row.querySelector("[data-meta]");
      const status = row.querySelector("[data-status]");
      const bar = row.querySelector("[data-bar]");
      const { total, processed, state, message } = dexieTableState.get(table);
      if (status && state) {
        status.textContent = {
          pending: "Pendiente",
          running: "Importando",
          done: "Completada",
          empty: "Sin datos",
          error: "Error",
        }[state] || state;
        row.dataset.state = state;
      }
      if (meta) {
        if (message) {
          meta.textContent = message;
        } else if (Number.isFinite(processed) && Number.isFinite(total) && total > 0) {
          meta.textContent = `${processed}/${total} registros`;
        } else if (Number.isFinite(total) && total === 0) {
          meta.textContent = "Sin registros";
        } else {
          meta.textContent = "En espera‚Ä¶";
        }
      }
      if (bar) {
        if (Number.isFinite(processed) && Number.isFinite(total) && total > 0) {
          const percent = Math.min(100, Math.round((processed / total) * 100));
          bar.style.width = `${percent}%`;
        } else {
          bar.style.width = "0%";
        }
      }
    };

    const resetDexieUI = () => {
      dexieTableState.clear();
      if (dexieList) dexieList.innerHTML = "";
      dexieTables.forEach((table) => {
        const row = document.createElement("div");
        row.className = "migration-row";
        row.dataset.table = table;
        const head = document.createElement("div");
        head.className = "migration-row__head";
        const title = document.createElement("strong");
        title.textContent = table;
        const status = document.createElement("span");
        status.className = "migration-row__status";
        status.dataset.status = "true";
        head.appendChild(title);
        head.appendChild(status);
        const bar = document.createElement("div");
        bar.className = "migration-row__bar";
        const fill = document.createElement("div");
        fill.className = "migration-row__bar-fill";
        fill.dataset.bar = "true";
        bar.appendChild(fill);
        const meta = document.createElement("div");
        meta.className = "migration-row__meta";
        meta.dataset.meta = "true";
        row.appendChild(head);
        row.appendChild(bar);
        row.appendChild(meta);
        dexieList?.appendChild(row);
        setDexieState(table, { state: "pending" });
      });
      if (dexieErrors) dexieErrors.classList.add("hidden");
      if (dexieErrorsList) dexieErrorsList.innerHTML = "";
      if (dexieSummary) dexieSummary.textContent = "Listo para migrar con el importador existente.";
      if (dexieStatusChip) dexieStatusChip.textContent = "En espera";
      if (dexieCloseBtn) {
        dexieCloseBtn.disabled = true;
        dexieCloseBtn.textContent = "Importando‚Ä¶";
      }
    };

    const openDexieModal = () => {
      if (!dexieModal) return;
      dexieModal.classList.remove("hidden");
    };

    const closeDexieModal = () => {
      if (!dexieModal) return;
      if (dexieMigrationRunning) return;
      dexieModal.classList.add("hidden");
    };

    const addDexieError = (message) => {
      if (!dexieErrors || !dexieErrorsList) return;
      dexieErrors.classList.remove("hidden");
      const item = document.createElement("li");
      item.textContent = message;
      dexieErrorsList.appendChild(item);
    };

    const attachDexieConsoleTap = () => {
      const originalInfo = console.info;
      const originalError = console.error;
      const originalWarn = console.warn;

      const parseInfo = (text = "") => {
        const start = text.match(/^\[(.+?)\] Iniciando importaci√≥n \((\d+) registros\)/);
        if (start) {
          const [, table, total] = start;
          setDexieState(table, { total: Number(total), processed: 0, state: "running", message: "" });
          return;
        }
        const progress = text.match(/^\[(.+?)\] (\d+)\/(\d+)/);
        if (progress) {
          const [, table, processed, total] = progress;
          setDexieState(table, {
            total: Number(total),
            processed: Number(processed),
            state: "running",
            message: "",
          });
          return;
        }
        const done = text.match(/^\[(.+?)\] Importaci√≥n completa \((\d+) registros\)\./);
        if (done) {
          const [, table, total] = done;
          setDexieState(table, {
            total: Number(total),
            processed: Number(total),
            state: "done",
            message: "",
          });
          return;
        }
        const empty = text.match(/^\[(.+?)\] Tabla vac√≠a, se omite\./);
        if (empty) {
          const [, table] = empty;
          setDexieState(table, { total: 0, processed: 0, state: "empty", message: "" });
        }
      };

      console.info = (...args) => {
        if (args.length) {
          const text = typeof args[0] === "string" ? args[0] : "";
          parseInfo(text);
        }
        return originalInfo.apply(console, args);
      };

      console.warn = (...args) => originalWarn.apply(console, args);

      console.error = (...args) => {
        if (args.length) {
          const text = typeof args[0] === "string" ? args[0] : "";
          const match = text.match(/^\[(.+?)\] Error durante la importaci√≥n:/);
          if (match) {
            const [, table] = match;
            setDexieState(table, { state: "error", message: "Fall√≥ la importaci√≥n" });
            addDexieError(`${table}: ${args[1]?.message || args[1] || "Error desconocido"}`);
          } else {
            addDexieError(args.map((a) => (a instanceof Error ? a.message : String(a))).join(" "));
          }
        }
        return originalError.apply(console, args);
      };

      return () => {
        console.info = originalInfo;
        console.error = originalError;
        console.warn = originalWarn;
      };
    };

    const startDexieMigration = async () => {
      if (dexieMigrationRunning) {
        showToast("Ya hay una migraci√≥n en curso.", { variant: "warning" });
        return;
      }
      resetDexieUI();
      openDexieModal();
      dexieMigrationRunning = true;
      if (dexieStatusChip) dexieStatusChip.textContent = "Importando‚Ä¶";
      const detach = attachDexieConsoleTap();
      try {
        await runDexieToSupabaseImport();
        if (dexieSummary) dexieSummary.textContent = "Migraci√≥n finalizada. Revisa el detalle por tabla.";
      } catch (err) {
        addDexieError(err?.message || String(err));
        if (dexieSummary) dexieSummary.textContent = "No se pudo completar la migraci√≥n.";
      } finally {
        detach?.();
        dexieMigrationRunning = false;
        if (dexieCloseBtn) {
          dexieCloseBtn.disabled = false;
          dexieCloseBtn.textContent = "Cerrar";
        }
        const hasErrors = Boolean(dexieErrorsList && dexieErrorsList.children.length);
        if (dexieStatusChip) dexieStatusChip.textContent = hasErrors ? "Finalizado con errores" : "Completado";
        if (hasErrors && dexieSummary && !dexieSummary.textContent.includes("No se pudo")) {
          dexieSummary.textContent = "Migraci√≥n completa con errores. Revisa los detalles.";
        }
      }
    };

    if (dexieMigrationBtn) dexieMigrationBtn.addEventListener("click", startDexieMigration);
    if (dexieCloseBtn) dexieCloseBtn.addEventListener("click", closeDexieModal);

    // === SISTEMA DE MODALES UNIFICADO ===
    function mostrarModal(titulo, mensaje, opciones = {}) {
      return new Promise((resolve) => {
        const modal = document.getElementById("sys-modal");
        const tEl = document.getElementById("modal-title");
        const mEl = document.getElementById("modal-msg");
        const okBtn = document.getElementById("modal-ok");
        const cancelBtn = document.getElementById("modal-cancel");

        if (!modal) return resolve(false);

        // Personalizar texto
        tEl.textContent = titulo || "Confirmar acci√≥n";
        mEl.textContent = mensaje || "¬øDeseas continuar?";
        okBtn.textContent = opciones.okText || "Aceptar";
        cancelBtn.textContent = opciones.cancelText || "Cancelar";
        okBtn.className = "";
        cancelBtn.className = "";
        if (opciones.okVariant === "danger") okBtn.classList.add("btn-danger");
        else if (opciones.okVariant === "secondary") okBtn.classList.add("btn-secondary");
        cancelBtn.classList.add("btn-ghost");

        // Mostrar modal
        modal.classList.remove("hidden");

        // Manejo de cierre
        const cerrar = (res) => {
          modal.classList.add("hidden");
          okBtn.onclick = cancelBtn.onclick = null;
          resolve(res);
        };

        okBtn.onclick = () => cerrar(true);
        cancelBtn.onclick = () => cerrar(false);
      });
    }

    // === Notificaci√≥n breve (sin botones, tipo toast simple) ===
    function mostrarAviso(mensaje, opciones = {}) {
      showToast(mensaje, opciones);
    }


    // === NUEVA FUNCI√ìN COMPLETA: Mostrar/Ocultar y eliminar sorteos individualmente ===
    // === Mostrar/Ocultar y eliminar sorteos individualmente (versi√≥n robusta) ===
    const btnListAll = document.getElementById("btn-list-all");
    const allOut = document.getElementById("all-out");
    const allFilterDate = document.getElementById("all-filter-date");
    const allFilterText = document.getElementById("all-filter-text");
    const allFilterClear = document.getElementById("all-filter-clear");
    let allDrawsCache = null;

    const hasActiveAllFilters = () => {
      const dateValue = (allFilterDate?.value || "").trim();
      const textValue = (allFilterText?.value || "").trim();
      return Boolean(dateValue || textValue);
    };

    function filterAllDraws(draws = []) {
      const dateValue = (allFilterDate?.value || "").trim();
      const textValue = (allFilterText?.value || "").trim().toLowerCase();
      if (!dateValue && !textValue) return draws;
      return draws.filter((draw) => {
        if (dateValue && draw.fecha !== dateValue) return false;
        if (textValue) {
          const numero = String(draw.numero).padStart(2, "0");
          const simbolo = GUIA[numero]?.simbolo || "";
          const haystack = `${draw.fecha} ${draw.pais} ${draw.horario} ${numero} ${simbolo} ${
            draw.isTest ? "prueba" : "real"
          }`.toLowerCase();
          if (!haystack.includes(textValue)) return false;
        }
        return true;
      });
    }

    async function renderAllTable({ forceReload = false } = {}) {
      if (!allOut) return;
      const shouldReload = forceReload || !Array.isArray(allDrawsCache);
      if (shouldReload) {
        allOut.innerHTML = "<p class='hint'>Cargando todos los sorteos‚Ä¶</p>";
        allDrawsCache = await DB.listDraws({ excludeTest: false });
      }

      const draws = Array.isArray(allDrawsCache) ? allDrawsCache : [];
      if (!draws.length && !hasActiveAllFilters()) {
        allOut.innerHTML = "<p class='hint'>No hay sorteos registrados a√∫n.</p>";
        return;
      }

      const filtered = filterAllDraws(draws);
      if (!filtered.length) {
        const message = hasActiveAllFilters()
          ? "No hay sorteos que coincidan con los filtros aplicados."
          : "No hay sorteos registrados a√∫n.";
        allOut.innerHTML = `<p class='hint'>${message}</p>`;
        return;
      }

      const table = document.createElement("table");
      table.className = "table-history";
      table.innerHTML = `
    <thead>
      <tr>
        <th>#</th><th>Fecha</th><th>Pa√≠s</th><th>Horario</th>
        <th>N√∫mero</th><th>S√≠mbolo</th><th>Tipo</th><th>Acciones</th>
      </tr>
    </thead>
    <tbody></tbody>
  `;
      const tbody = table.querySelector("tbody");

      filtered.forEach((draw, idx) => {
        const numero = String(draw.numero).padStart(2, "0");
        const tr = document.createElement("tr");
        tr.innerHTML = `
      <td>${idx + 1}</td>
      <td>${draw.fecha}</td>
      <td>${draw.pais}</td>
      <td>${draw.horario}</td>
      <td class="num">${numero}</td>
      <td class="sym">${GUIA[numero]?.simbolo || "‚Äî"}</td>
      <td class="${draw.isTest ? "test" : ""}">${draw.isTest ? "prueba" : "real"}</td>
      <td>
        <button type="button" class="btn-del" data-id="${draw.id}">üóë</button>
      </td>
    `;
        tbody.appendChild(tr);
      });

      const meta = document.createElement("div");
      meta.className = "panel-meta";
      if (filtered.length === draws.length) {
        meta.textContent = `Mostrando ${filtered.length} sorteos registrados.`;
      } else {
        meta.textContent = `Mostrando ${filtered.length} de ${draws.length} sorteos (aplicando filtros).`;
      }

      allOut.innerHTML = "";
      allOut.appendChild(meta);
      allOut.appendChild(table);
    }

    const refreshAllTableIfVisible = (options) => {
      if (allOut?.dataset.visible === "true") {
        renderAllTable(options);
      }
    };

    btnListAll?.addEventListener("click", async () => {
      if (!allOut) return;

      if (allOut.dataset.visible === "true") {
        allOut.innerHTML = "";
        allOut.dataset.visible = "false";
        btnListAll.textContent = "Ver todos";
        return;
      }

      await renderAllTable({ forceReload: true });
      allOut.dataset.visible = "true";
      btnListAll.textContent = "Ocultar tabla";
    });

    allFilterDate?.addEventListener("input", () => refreshAllTableIfVisible());
    allFilterText?.addEventListener("input", () => refreshAllTableIfVisible());
    allFilterClear?.addEventListener("click", () => {
      if (allFilterDate) allFilterDate.value = "";
      if (allFilterText) allFilterText.value = "";
      refreshAllTableIfVisible();
    });

    // üîí Delegaci√≥n de eventos sobre el contenedor (funciona aunque se regenere la tabla)
    allOut?.addEventListener("click", async (ev) => {
      const delBtn = ev.target.closest?.(".btn-del");
      if (!delBtn) return;

      const id = Number(delBtn.dataset.id);
      if (!Number.isFinite(id)) return;

      const confirmar = await mostrarModal(
        "Eliminar sorteo",
        "¬øSeguro que deseas eliminar este sorteo permanentemente?",
        { okText: "Eliminar", cancelText: "Cancelar", okVariant: "danger" }
      );
      if (!confirmar) return;

      try {
        await DB.deleteDrawById(id);
        if (Array.isArray(allDrawsCache)) {
          allDrawsCache = allDrawsCache.filter((draw) => draw.id !== id);
        }
        await handleDrawsMutated();
        await renderAllTable();
        // Si queda la tabla vac√≠a, no forzamos recarga; el usuario puede pulsar "Ocultar" y "Ver todos".
        mostrarAviso("Sorteo eliminado correctamente.", { variant: "success" });
      } catch (err) {
        console.error("delete draw error", err);
        mostrarAviso(`Error al eliminar: ${err.message}`, { variant: "danger" });
      }
    });



    // === Bot√≥n para reiniciar completamente la base ===
    const btnNuke = document.getElementById("btn-nuke");
    btnNuke?.addEventListener("click", async () => {
      const confirmar = await mostrarModal(
        "Reiniciar base de datos",
        "‚ö†Ô∏è ¬øSeguro que deseas borrar TODOS los datos del sistema?",
        { okText: "Borrar todo", cancelText: "Cancelar", okVariant: "danger" }
      );
      if (!confirmar) return;
      try {
        await DB.nuke();
        showToast("Base de datos vaciada correctamente. Reinicia la p√°gina para comenzar desde cero.", {
          variant: "success",
          timeout: 6000,
        });
        await rebuildKnowledge();
        await handleDrawsMutated();
      } catch (err) {
        console.error("nuke error", err);
        showToast(`Error al intentar limpiar la base: ${err.message}`, { variant: "danger" });
      }
    });

  </script>

  <!-- === MODAL MIGRACI√ìN DEXIE ‚Üí SUPABASE === -->
  <div id="dexie-supabase-modal" class="modal hidden">
    <div class="modal-content modal-content--wide">
      <div class="modal-head modal-head--spread">
        <h3>Migraci√≥n Dexie ‚Üí Supabase</h3>
        <span id="dexie-migration-status" class="migration-chip">En espera</span>
      </div>
      <div class="modal-body">
        <p id="dexie-migration-summary" class="migration-summary">
          Listo para migrar con el importador existente.
        </p>
        <div id="dexie-migration-list" class="migration-table-list"></div>
        <div id="dexie-migration-errors" class="migration-errors hidden">
          <strong>Errores detectados</strong>
          <ul></ul>
        </div>
      </div>
      <div class="modal-foot">
        <button id="dexie-migration-close" disabled>Cerrar</button>
      </div>
    </div>
  </div>

  <!-- === MODAL DEL SISTEMA === -->
  <div id="sys-modal" class="modal hidden">
    <div class="modal-content">
      <div class="modal-head">
        <h3 id="modal-title">Confirmar acci√≥n</h3>
      </div>
      <div class="modal-body">
        <p id="modal-msg"></p>
      </div>
      <div class="modal-foot">
        <button id="modal-cancel">Cancelar</button>
        <button id="modal-ok">Aceptar</button>
      </div>
    </div>
  </div>
</body>

</html>
